# IO精讲

## 个人理解阻塞IO、非阻塞IO、poll、epoll、select

### 阻塞IO

如果内核的buffer内存中没有数据，那么用户线程会**阻塞等待**，直到内核的buffer内存中有数据了，才去将内核的buffer内存中的数据数据拷贝到用户应用内存中。当一个线程阻塞住了，会导致后续所有的线程都阻塞住，即使后面的读写数据已经就绪，也无法进行读写。

### 非阻塞IO

当用户应用线程调用Linux操作系统的函数读取数据的时候，如果内核的buffer内存中没有数据，那么用户线程会**直接拿到结果（没有数据）**不需要等待，于是又会再发起一次函数的调用，直到内核中的buffer内存有数据了，才去将内核的buffer内存中的数据拷贝到用户空间。

### select模式

用户应用线程调用select函数去监听多个文件描述符，如果没有数据，还是要等待，如果有就绪文件说明有数据。那就去读对应的FD就绪的文件数据，此时内核会将文件描述符拷贝到用户内存中，然后再去遍历文件描述符的集合，找到可以读的数据文件描述符，然后再去读取，读完之后会将文件描述符再拷贝回内核空间中。

### poll模式

他和select模式的原理差不多，不同的点在于，poll模式的底层添加了一个event事件，分成读事件，写事件，异常事件等等



### epoll模式

是在poll模式的基础上的再次改进，首先将内存事件的文件描述符改成了红黑树，红黑树的遍历性能稳定，其次就是将具体的就绪事件单独复制出来然后拷贝给用户缓冲区，用户缓冲区拿到的是已经就绪的事件，无需遍历性能再次提升。


