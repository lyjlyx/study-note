

# 微服务中的用户会话管理（一）

**不主动、不拒绝、不负责**





## 会话管理

### Session和Cookies



**自动保持会话**

通过打标签或者加标记等等方法来保持相识的关系

Token其实就是Session里面生成的唯一字符串，用来做鉴权用的，不基于Cookies的。Token可以跨平台



**User-Agent**

![image-20220209204002521](image/image-20220209204002521.png) 



### 浏览器同源策略

不同源会造成JS无法发送异步请求

Jsonp 手动

Cors  浏览器加服务器



如果使用ajax异步请求的话就不能再请求不同的域名地址，否则会触发跨域(其实是浏览器的保护机制)

Jsonp使用的是回调函数来处理跨域请求

![image-20220209211823017](image/image-20220209211823017.png) 

当浏览器解析到跨域地址的时候，浏览器会向这个地址发起一个get请求，请求回来的js后再执行这个js。

![image-20220209211858301](image/image-20220209211858301.png) 

![image-20220209212103306](image/image-20220209212103306.png) 

![image-20220209212123525](image/image-20220209212123525.png) 

![image-20220209212415848](image/image-20220209212415848.png) 

**JSONP只能发get请求**



##### CORS

在浏览器中指定Origin来源，如果在服务器接受范围，请求则成功

CORS与JSONP的使用目的相同，但是比JSONP更强大。

JSONP只支持`GET`请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。

**浏览器端和服务器端约定来源，在允许范围内的话，这次请求就相当于成功**



### Shiro

Shiro 是 Java 的一个安全框架。目前，使用 Apache Shiro 的人越来越多，因为它相 当简单，对比 Spring
Security，可能没有 Spring Security 做的功能强大，但是在实际工作时 可能并不需要那么复杂的东西，所以使用小而简单的Shiro 就足够了。

**认证**

**授权**

#### 核心功能

**Authentication**：身份认证/登录，验证用户是不是拥有相应的身份；

**Authorization**：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限；

**Session Manager**：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通JavaSE环境的，也可以是如Web环境的；

**Cryptography**：加密（解密 摘要算法），保护数据的安全性，如密码加密存储到数据库，而不是明文存储；

**Web Support**：Web支持，可以非常容易的集成到Web环境；

**Caching**：缓存，比如用户登录后，其用户信息、拥有的角色/权限不必每次去查，这样可以提高效率；
**Concurrency**：shiro支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；

**Testing**：提供测试支持；

**Run As**：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；

**Remember Me**：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。





## Spring security

Spring Security是一个能够为基于Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架。它提供了一组可以在Spring应用上下文中配置的Bean，充分利用了Spring IoC，DI（控制反转Inversion of Control ,DI:Dependency Injection 依赖注入）和AOP（面向切面编程）功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。

它是一个轻量级的安全框架，它确保基于Spring的应用程序提供身份验证和授权支持。

它与Spring MVC有很好地集成，并配备了流行的安全算法实现捆绑在一起。安全主要包括两个操作“认证”与“验证”（有时候也会叫做权限控制）。

“认证”是为用户建立一个其声明的角色的过程，这个角色可以一个用户、一个设备或者一个系统。“验证”指的是一个用户在你的应用中能够执行某个操作。在到达授权判断之前，角色已经在身份认证过程中建立了。



Spring Security 前身是Acegi Security



### SSO

SSO 是英文 Single Sign On 的缩写，翻译过来就是单点登录

**只要实现了一次登录，到处都能使用**

使用**第三方管理session实现**或者**同步**

**同步**

![image-20220209220157736](image/image-20220209220157736.png) 

**第三方共享组件**

![image-20220209220356628](image/image-20220209220356628.png) 



### Oauth

**统一网关**

OAuth在”客户端”与”服务提供商”之间，设置了一个授权层（authorization layer）。”客户端”不能直接登录”服务提供商”，只能登录授权层，以此将用户与客户端区分开来。”客户端”登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。

“客户端”登录授权层以后，”服务提供商”根据令牌的权限范围和有效期，向”客户端”开放用户储存的资料。

- Spring Social
- Spring Session
- JWT

![image-20220209220643695](image/image-20220209220643695.png) 



### CAS(CA 鉴权Server)

**鉴权专用的服务器**

中心认证服务（Central Authentication Service）SSO 仅仅是一种架构，一种设计，而 CAS 则是实现 SSO 的一种手段

![image-20220209222331900](image/image-20220209222331900.png) 



### CSRF XSS攻击安全与防御

**基于Cookies**

#### XSS(跨站点脚本攻击)



### CSRF 

CSRF (Cross Site Request Forgery)攻击，中文名：跨站请求伪造。其原理是攻击者构造网站后台某个功能接口的请求地址，诱导用户去点击或者用特殊方法让该请求地址自动加载。用户在登录状态下这个请求被服务端接收后会被误以为是用户合法的操作。对于 GET 形式的接口地址可轻易被攻击，对于 POST 形式的接口地址也不是百分百安全，攻击者可诱导用户进入到Form 表单可用POST方式提交参数的页面。

**防止：**

1. 敏感操作加验证->验证码
2. 每次请求带token
3. 第一次访问系统的时候需要登录，下发了Cookies(保持会话用的)，再额外下发一个hash码(用于下次请求)每次请求都要带上这个hash，不然系统验证不通过，如果hash和系统中存的hash匹配得上，那么这次请求成功展示下一个页面。所有展示的页面中的所有连接最好都是用post。

如果没办法做到全站post的话就在get请求后面都加上hash值

hash值前端后端都要保存，前端可以存在**页面上**(下发下来的hash不能放到Cookies上)

**每次的访问hash值都是会变的**



## 模拟登陆+解决CSRF方案

**配置类**

```JAVA
package com.mashibin.csrf;

import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.web.csrf.HttpSessionCsrfTokenRepository;

/**
 * @author LYX
 * @description
 * @date 2022/2/10 10:27
 */
@Configuration
@EnableWebSecurity
public class MyConfig extends WebSecurityConfigurerAdapter {

    //配置csrf验证
    //自定义hash
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        //super.configure(http);
        ----------------------------------------------------------------------
        http
                //相当于是一个xml
                //<父标签>
                .authorizeRequests()
                //<子标签>
                //树形
                .antMatchers("")
                .denyAll()
                //</子标签>
                //</父标签>
                //and退回到顶级标签
                .and()
                .csrf()
                .csrfTokenRepository(new HttpSessionCsrfTokenRepository())
                .and()
                .saml2Login();
        
        ----------------------------------------------------------------------
        //实现权限认证 所有请求都要经过登录认证
        http.authorizeRequests().anyRequest().authenticated()
        //配置登录页面
        //登录表单
        .formLogin()
        //登录表单的html
        .loginPage("/login.html")
        //这个页面不需要登录
        .permitAll();
            
        
    }
}


```

**HTML文件要放到resource/static文件夹下面(文件夹自己新建)**

![image-20220210123639978](image/image-20220210123639978.png) 

![image-20220210123846577](image/image-20220210123846577.png) 



**需要带上csrf，不然请求会不同，要么带上，要么加上disable方法**

```java
http.
                // 哪些 地址需要登录
                        authorizeRequests()
                //所有请求都需要验证
                .anyRequest().authenticated()
                .and()


                //permitAll 给没登录的 用户可以访问这个地址的权限
                //自定义登录页
                .formLogin().loginPage("/login.html")

                .loginProcessingUrl("/login").permitAll()
                // 登录失败 页面
                .failureUrl("/login.html?error")
                // 登录成功跳转的页面
                .defaultSuccessUrl("/ok", true).permitAll()
                // 配置 登录页 的表单name   admin -> 分权限 展示页面
                .passwordParameter("oo")
                .usernameParameter("xx")


                .failureHandler(new AuthenticationFailureHandler() {

                    @Override
                    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response,
                                                        AuthenticationException exception) throws IOException, ServletException {
                        // TODO Auto-generated method stub
                        exception.printStackTrace();

                        // 判断异常信息 跳转不同页面 比如 密码过期重置
                        request.getRequestDispatcher(request.getRequestURL().toString()).forward(request, response);

                        // 记录登录失败次数 禁止登录

                    }
                })


                //默认 所有的post请求 都会拦截
                .and()
                .csrf()
                .csrfTokenRepository(new HttpSessionCsrfTokenRepository());
```

**如果要防止CSRF的话post请求是必须的，还有就是禁止外链，或者在post和get请求上都下发token**





## SpringSecurityAPi详解

配置账号密码的参数名称

```java
//配置登录页的表单name
.usernameParameter("xx")
.passwordParameter("oo")
```

![image-20220210215844161](image/image-20220210215844161.png) 





```java
//session登录不适用于高并发登录的情况下  并发量高了就直接使用->JWT
//构建权限管理器 
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {

        auth.inMemoryAuthentication()
            .withUser("lyx")
                                //要加roles
                .password("123").roles("admin")
            .and()
            .withUser("hwl")
                .password("123").roles("user").and()
        

        ;
    }
```

**但是使用上面的代码进行登录还是会报错，提示要使用相应的对账号密码编码才能正常登录，所以我们需要对其进行加密**(PasswordEncoder)

![image-20220210222221185](image/image-20220210222221185.png)

**定义一个bean**

```java
    @Bean
    PasswordEncoder passwordEncoder() {
                //不推荐使用
        return NoOpPasswordEncoder.getInstance();
    }
```



## 密码存储安全问题

**正常情况下账号密码都不会使用明文进行存储**

明文存储有可能在网络中被偷窥





hash(明文)=摘要 快 不可逆 相同的源加密结果一样的



**MD5（不安全的）**特点就是快

1. 穷举
2. 字典
3. 彩虹表：彩虹表有点是分段的去碰撞的，把可能都分成了好几段，做密文的碰撞

![image-20220210223918116](image/image-20220210223918116.png) 



**hash(明文) + 盐**

盐：注册的时候、校验的时候

1、固定盐(不太行)；2、随机盐(规则随机)；

固定盐：

注册（456是固定值）

hash(123 + 456) = xxx

校验

username

hash(提交上来的明文+盐) == password

随机盐：

生成的随机数盐保存在数据库表里是没有意义的

生成的真随机数可以藏到hash里面，比对的时候将加密后的数据从数据库中拿出来，把随机数拿出来再执行一遍hash算法，之后再去跟提交上来的密文进行比对校验，比对上了就成功了。

![image-20220210225156785](image/image-20220210225156785.png) 

**还可以进行多次加密**

hash(hash(明文+随机盐) + 随机盐) 反复执行10次   几乎不可能破解开来

sha1 - sha256 区块链加密算法

### Bcrypt结构

![img](image/webp)



**使用加密算法，之后需要使用对应的加密对象将我们的密码加密**

![image-20220210231005185](image/image-20220210231005185.png)

![image-20220210231147179](image/image-20220210231147179.png) 



![image-20220210231526606](image/image-20220210231526606.png) 







## JDBC用户内存



添加的账号都会存在内存中

```java
@Override
    protected UserDetailsService userDetailsService() {
//>>>>>>>>>>>>>>>>>>>基于内存的存储用户<<<<<<<<<<<<<<<<<<<<<

        InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();

        //使用用户名找到user对象的
        //manager.loadUserByUsername(username);
        //修改密码
        //manager.changePassword(oldPassword, newPassword);
        User user = new User("a", new BCryptPasswordEncoder().encode("1"), true, true, true, true, Collections.singletonList(new SimpleGrantedAuthority("xx")));
        manager.createUser(user);
        manager.createUser(User.withUsername("lyx").password(new BCryptPasswordEncoder().encode("lyx")).roles("xxz").build());

        return manager;
        //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    }
```

![image-20220211130523384](image/image-20220211130523384.png) 

### 依赖

```
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jdbc</artifactId>
</dependency>
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
</dependency>
```

### 配置文件

```properties
spring.datasource.username=root
spring.datasource.password=840416
spring.datasource.url=jdbc:mysql:///mq?useUnicode=true&characterEncoding=UTF-8&serverTimezone=Asia/Shanghai
```



### 建表

Spring Security默认情况下需要两张表，用户表和权限表,可以参考

org.springframework.security.core.userdetails.jdbc.users.ddl



### 登录实现及用户注册

```java
	@Bean
	protected UserDetailsService userDetailsService() {
		
		JdbcUserDetailsManager manager = new JdbcUserDetailsManager(dataSource);
		
		if(manager.userExists("yiming")) {
			System.out.println("已注册");
		}else {
			
			manager.createUser(User.withUsername("yiming")
					.password(new BCryptPasswordEncoder().encode("123"))
					.roles("admin")
					.build()
					);
		}
		
		return manager;
	}
```

或者

```java
	@Override
	protected void configure(AuthenticationManagerBuilder auth) throws Exception {

		JdbcUserDetailsManager manager = auth.
			jdbcAuthentication()
		.dataSource(dataSource).getUserDetailsService();
		
		manager.createUser(User.withUsername("1112")
					.password(new BCryptPasswordEncoder().encode("123"))
					.roles("admin")
					.build());
```

### mysql

**使用security提供的默认建表语句建表**

```sql
create table users(username varchar(50) not null primary key,password varchar(500) not null,enabled boolean not null);

create table authorities (username varchar(50) not null,authority varchar(50) not null,constraint fk_authorities_users foreign key(username) references users(username));

create unique index ix_auth_username on authorities (username,authority);
```



```java

    @Autowired
    private DataSource dataSource;
@Bean
protected UserDetailsService userDetailsService() {
//>>>>>>>>>>>>>>>>>基于JDBC的用户存储<<<<<<<<<<<<<<<<<<<<<<<<<<
JdbcUserDetailsManager jdm = new JdbcUserDetailsManager(dataSource);
jdm.createUser(User.withUsername("lyx").password("111").roles("admin", "waiter").build());
return jdm;
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

//>>>>>>>>>>>>>>>>>>>>加密<<<<<<<<<<<<<<<<<<<<<<<<<<
        JdbcUserDetailsManager jdm = new JdbcUserDetailsManager(dataSource);
        jdm.createUser(User.withUsername("hwl").password(new BCryptPasswordEncoder().encode("111")).roles("admin", "waiter").build());
        return jdm;
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
}
```

启动之后springsecurity就会帮我们在数据库中创建这个用户

![image-20220211132610020](image/image-20220211132610020.png) 

![image-20220211132859772](image/image-20220211132859772.png) 



**如果我们想修改Manager的话，我们就需要给他重写一套就行了**

![image-20220211133913226](image/image-20220211133913226.png) 



**自定义ORM用户登录方法**

```java
//>>>>>>>>>>>>>>>>>>>>>>>自定义ORM用户登录方法>>>>>>>>>>>>>>>>>>>>>>>>>>>>
auth.userDetailsService(new MyDetailService());

public class MyDetailService implements UserDetailsService {

	//完全自定义  脱离了自动配置的数据源查询数据库
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        //从redis 取 mysql 取，jpa取
        if (new Random().nextBoolean()) {

            System.out.println("登录成功");
            throw new CredentialsExpiredException("密码已过期！请重新修改密码");

        } else {
            throw new LockedException("登录失败!已被锁定!");
        }
    }
}
```



## 自定义用户权限 



```java
auth.userDetailsService(new MyDetailService())

        //开关标签
        .and()
                
        //权限校验
        .authenticationProvider(new MyAuthenticationProvider());
        ;
        
 >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
     
     
package com.mashibin.csrf.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;

/**
 * @author LYX
 * @description
 * @date 2022/2/12 14:42
 */
public class MyAuthenticationProvider implements AuthenticationProvider {


    @Autowired
    private MyDetailService myDetailService;

    //权限校验方法
    @Override
    public Authentication authenticate(Authentication authentication) throws AuthenticationException {

        //穷举密码  限制 重试次数


        System.out.println("开始校验账号密码,是否匹配");

        //表单提交上来的数据
        Object userName = authentication.getPrincipal();
        //明文 和数据库中存的那个密文 不是一回事
        //给password加密是防程序员的
        Object password = authentication.getCredentials();

        System.out.println(userName);
        System.out.println(password);

        System.out.println(authentication);
        //去数据库中拿出User对象
        UserDetails userDetails = myDetailService.loadUserByUsername(userName.toString());

        //把传过来的密码进行加密 与我们去数据库中拿到的password密文进行比对
        //这样的写法加密出来的密文跟数据库中的密文是不一样的  我们需要使用matches
        //String encodePassword = new BCryptPasswordEncoder().encode(password.toString());

        //比对
        //错误比对方法
        //if (userDetails.getPassword().equals(encodePassword)) {
        if (new BCryptPasswordEncoder().matches(password.toString(), userDetails.getPassword())) {
            //密码通过，登录成功
            System.out.println("成功！");

            //credentials属性中应该放密文
            UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(
                    userName,
                    userDetails.getPassword(),
                    userDetails.getAuthorities());
            //可以拿用户名和其他值去生成   签名， 签名的作用是校验前面的数据对不对
            //JWT 不走会话也不查数据库
            return authenticationToken;
        } else {
            throw new BadCredentialsException("用户名或密码错误!");
        }

    }

    //是否支持自定义配置
    @Override
    public boolean supports(Class<?> authentication) {
        return true;
    }
}
```

框架帮我们把数据都隐藏住了，开发人员根本拿不到密码

![image-20220212150822894](image/image-20220212150822894.png) 



## 忽略静态请求

```java
//忽略静态请求 该路径下的所有静态数据都能直接访问
方法一
    //不需要登录就可以访问的资源
     .antMatchers("/img/**").permitAll()
                    
 方法二
    @Override
    public void configure(WebSecurity web) throws Exception {
		//不需要登录就可以访问的资源
        web.ignoring().antMatchers("/img/**");
    }
```



### Ant 风格路径表达式

| 通配符 | 说明                    |
| ------ | ----------------------- |
| ?      | 匹配任何单字符          |
| *      | 匹配0或者任意数量的字符 |
| **     | 匹配0或者更多的目录     |

#### 例子

| URL路径            | 说明                                                         |
| ------------------ | ------------------------------------------------------------ |
| /app/*.x           | 匹配(Matches)所有在app路径下的.x文件                         |
| /app/p?ttern       | 匹配(Matches) /app/pattern 和 /app/pXttern,但是不包括/app/pttern |
| /**/example        | 匹配(Matches) /app/example, /app/foo/example, 和 /example    |
| /app/**/dir/file.* | 匹配(Matches) /app/dir/file.jsp, /app/foo/dir/file.html,/app/foo/bar/dir/file.pdf, 和 /app/dir/file.java |
| /**/*.jsp          | 匹配(Matches)任何的.jsp 文件                                 |



#### 最长匹配原则

最长匹配原则(has more characters)
说明，URL请求/app/dir/file.jsp，现在存在两个路径匹配模式/**/*.jsp和/app/dir/*.jsp，那么会根据模式/app/dir/*.jsp来匹配

#### 匹配顺序

security像shiro一样，权限匹配有顺序，比如不能把.anyRequest().authenticated()写在其他规则前面

### 权限继承

​	

	RoleHierarchy roleHierarchy() {
		
		RoleHierarchyImpl impl = new RoleHierarchyImpl();
		impl.setHierarchy("ROLE_admin > ROLE_user");
		
		return impl;
		
	}



## remember me

```java
		http.
		// 哪些 地址需要登录
		authorizeRequests()
		//所有请求都需要验证
		.anyRequest().authenticated()
		.and()
		.formLogin()
		.and()
		.rememberMe()
		.and()
		.csrf().disable();
```

![image-20220212154411591](image/image-20220212154411591.png) 

勾选remember-me的时候会在Cookies中多出数据

![image-20220212155018499](image/image-20220212155018499.png) 

为什么会单独拎一个rember-me的cookies呢

remember-me主要是应对单点登录的，请求我们服务的不一定是浏览器，那么我们下发的remember-me就可以做为token开发的，使用session做的话集群的会话压力会很大(各个集群都要有session，如果session改动之后各个集群都得级联改)，token的机制是无会话



![image-20220212160016944](image/image-20220212160016944.png) 

remember-me中存储的value基于base64的可逆的一个字符串

![image-20220212160430374](image/image-20220212160430374.png) 

![image-20220212160547575](image/image-20220212160547575.png) 

```java
//账号 +  过期时间戳  +  secrete	= 摘要 【首次登陆(一定有服务端有客户端没有的东西)】 	sign值
		//hwl:1645862585961:518acd5bdfd3a2e564a8056a3e623fd7(sign值是用来校验前面两个值对不对的)
		byte[] dec = Base64.getDecoder().decode("aHdsOjE2NDU4NjI1ODU5NjE6NTE4YWNkNWJkZmQzYTJlNTY0YTgwNTZhM2U2MjNmZDc");
		System.out.println(new String(dec));
		//好处 不需要数据库连接和数据源的校验
```



**同一用户多地点登录**

```java
.sessionManagement()
				//设置最大用户登录数 允许同时登录的用户
				.maximumSessions(1)
    			//已经有用户登录的情况下，不允许相同的用户再次登录
				.maxSessionsPreventsLogin(true)
				.and().and()
```

![image-20220212165208960](image/image-20220212165208960.png) 

**如果有用户登录的时候就不能再继续登录了，但是他没有及时清理过期的session(因为我根本没有登录，Cookies已经清理了)**

![image-20220212165659675](image/image-20220212165659675.png) 

**及时清理过期session bean**

```java
	@Bean
	HttpSessionEventPublisher httpSessionEventPublisher() {
	    return new HttpSessionEventPublisher();
	}
```





## 防火墙

### ip白名单

#### 指定ip可以不登录

```
		http.
		// 哪些 地址需要登录
		authorizeRequests()
		//所有请求都需要验证
		.anyRequest().authenticated()
		
		.antMatchers("/ip1").hasIpAddress("127.0.0.1")
```

#### 禁止ip访问

用Filter 实现、或者用HandlerInterceptor 实现

### StrictHttpFirewall

spring security 默认使用StrictHttpFirewall限制用户请求

#### method

缺省被允许的`HTTP method`有 [`DELETE`, `GET`, `HEAD`, `OPTIONS`, `PATCH`, `POST`, `PUT`]

#### URI

**在其`requestURI`/`contextPath`/`servletPath`/`pathInfo`中，必须不能包含以下字符串序列之一 :**

```
["//","./","/…/","/."]
```



#### 分号

```
;或者%3b或者%3B
// 禁用规则
setAllowSemicolon(boolean)
```



#### 斜杠

```
%2f`或者`%2F
// 禁用规则
setAllowUrlEncodedSlash(boolean)
```

#### 反斜杠

```
\或者%5c或者%5B
// 禁用规则
setAllowBackSlash(boolean)
```

#### 英文句号

```
%2e或者%2E
// 禁用规则
setAllowUrlEncodedPeriod(boolean)
```

#### 百分号

```
%25
// 禁用规则
setAllowUrlEncodedPercent(boolean)
```

#### 防火墙与sql注入

' ; -- % 多数非法字符已经在请求的参数上被禁用

为啥用户名不能有特殊字符

preparestatement 

awf前端拦截

### SpringSecurity防火墙

SQL注入使用prepareStatement提交强制预编译，将值都变为？，这些问号都是占位符，先把SQL编译了，编译完成之后变为了代码级别的



**非法字符校验**





**DDOS 拒绝服务攻击**：

1、三次握手建立完成之后不再发送请求;(无法辨识，很难辨识)

2、三次握手客户端第一次发包，服务端回包，客户端不再向服务端发包(容易辨识)



解决方法只能买带宽，加服务器



## 注销登陆与控制器 

```java
				//自带登录界面和退出界面
                .formLogin()
```



### 注销登录



#### 开启CSRF之后 需要使用post请求退出接口



```
<a href="/logout">GET logout</a>
<br />
<form action="/logout" method="post">
    <input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}" />
    <input type="submit" value="POST Logout"/>
</form>
```

#### 默认方式 get /logout

**可以加多个logoutHandler**

```java
//退出逻辑处理器 可以用于清理用户资源
				.addLogoutHandler(new LogoutHandler() {
					@Override
					public void logout(HttpServletRequest request, HttpServletResponse response, Authentication authentication) {
						System.out.println("滚犊子");
					}
				})
				.addLogoutHandler(new LogoutHandler() {
					@Override
					public void logout(HttpServletRequest request, HttpServletResponse response, Authentication authentication) {
						System.out.println("赶紧滚");
					}
				})
				.and()
```



#### 自定义url

```
		.and()
		.logout()
		.logoutUrl("/out")
```

### 增加退出处理器

```
		.addLogoutHandler(new LogoutHandler() {
			
			@Override
			public void logout(HttpServletRequest request, HttpServletResponse response, Authentication authentication) {
				// TODO Auto-generated method stub
				System.out.println("退出1");
			}
		})
		
		
		.addLogoutHandler(new LogoutHandler() {
			
			@Override
			public void logout(HttpServletRequest request, HttpServletResponse response, Authentication authentication) {
				// TODO Auto-generated method stub
				System.out.println("退出2");
			}
		})
```

### 登录成功处理器

```java
				//在登录成功之后会被调起
				//用来锁定资源、初始化资源等等
				.successHandler(new AuthenticationSuccessHandler() {
					@Override
					public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {
						//其实就是userDetail
						Object user = authentication.getPrincipal();
						System.out.println(user);
						System.out.println("登录成功了老东西");
					}
				})
```

不同角色 跳转到不同页面

		.successHandler(new AuthenticationSuccessHandler() {
			
			@Override
			public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,
					Authentication authentication) throws IOException, ServletException {
				// TODO Auto-generated method stub
				
				System.out.println("登录成功1");
				// 根据权限不同，跳转到不同页面
				request.getSession().getAttribute(name)
				request.getRequestDispatcher("").forward(request, response);
			}
		})

其中 Authentication 参数包含了 用户权限信息



### 登录失败处理器

```java
				//登录失败的Handler
				.failureHandler(new AuthenticationFailureHandler() {
					//分析失败原因，统计失败次数
					@Override
					public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException {
						//登录失败异常信息 exception
						System.out.println("失败了臭老头");

					}
				})
```



```
		.failureHandler(new AuthenticationFailureHandler() {
			
			@Override
			public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response,
					AuthenticationException exception) throws IOException, ServletException {
				// TODO Auto-generated method stub
				exception.printStackTrace();
				request.getRequestDispatcher(request.getRequestURL().toString()).forward(request, response);
			}
		})
```

可以限制登录错误次数

## 权限控制与继承 (1)

### 访问权限

```java
				//这两个地址需要role才能登录
				//角色(admin) -> 权限(url) 但是粒度会比较粗
				//role = 角色
				//Authority指的是单条具体的权限
				.antMatchers("/admin/**").hasRole("admin")
				.antMatchers("/user/**")
				.hasRole("user")
				//.hasAnyAuthority()
```

访问权限可以配置URL匹配用户角色或权限

		http.authorizeRequests()
		
		.antMatchers("/admin/**").hasRole("admin")
		.antMatchers("/user/**").hasRole("user")

![image-20220213152750718](image/image-20220213152750718.png) 



### 匹配顺序

security像shiro一样，权限匹配有顺序，比如不能把.anyRequest().authenticated()写在其他规则前面

### 权限继承

```java
@Bean
RoleHierarchy roleHierarchy() {
	
	RoleHierarchyImpl impl = new RoleHierarchyImpl();
	//继承关系 这样子使用admin角色的用户就能访问user了
	impl.setHierarchy("ROLE_admin > ROLE_user");
	
	return impl;
	
}
```

## 权限控制细粒度注解

## 角色匹配

### 配置类

```
@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true,securedEnabled = true)
```

### **securedEnabled = true** 

方法验证

```java
	@GetMapping("/hi_admin")
	//@Secured("ROLE_admin") 配置单个角色  不支持并且的关系
	//配置多个角色
	@Secured({"ROLE_admin","ROLE_user"})
	public Authentication hi() {
```

开启简单验证，之验证单一角色是否持有

​	

### **注解中 prePostEnabled = true** 

支持更复杂的角色匹配，比如必须同时包含两个角色

​	**需包含user角色**

```java
//必须要有user的角色才能访问
@PreAuthorize("hasRole('ROLE_user')")
```

**需包含user或admin角色**

```java
@PreAuthorize("haAnyRole('ROLE_admin','ROLE_user')")
```



**同时需包含user和admin角色**

```java
	@PreAuthorize("hasRole('ROLE_admin') AND hasRole('ROLE_user')")
```

![image-20220213194649107](image/image-20220213194649107.png) 



### 根据方法返回值判断是否有权限

```java
//Spring EL表达式
//当表达式为ture 的时候有权限访问，如果是false就403
@PostAuthorize("returnObject==1")
//例:返回的对象是1才有是true
//方法中可以执行一遍业务逻辑，看看是否符合逻辑判断的权限
```



**在方法中配置了权限认证的话，在注解中就不能配了，同理也是，不然会冲突**

### 方法拦截

```java
	@GetMapping("/hi")
	@PreAuthorize("hasRole('ROLE_admin')")
	public String hi() {
	//	UserDetailsServiceAutoConfiguration
		System.out.println("来啦老弟~！");
		return "hi";
	}
	
	
	@PreAuthorize("hasRole('ROLE_user')")
	@GetMapping("/hiUser")
	public String hiuser() {
	//	UserDetailsServiceAutoConfiguration
		System.out.println("来啦老弟~！");
		return "hi";
	}
```

## 图形验证码

目的：防机器暴力登陆

### Kaptcha 

| Constant                         | 描述                                                         | 默认值                                                |
| -------------------------------- | ------------------------------------------------------------ | ----------------------------------------------------- |
| kaptcha.border                   | 图片边框，合法值：yes , no                                   | yes                                                   |
| kaptcha.border.color             | 边框颜色，合法值： r,g,b (and optional alpha) 或者 white,black,blue. | black                                                 |
| kaptcha.image.width              | 图片宽                                                       | 200                                                   |
| kaptcha.image.height             | 图片高                                                       | 50                                                    |
| kaptcha.producer.impl            | 图片实现类                                                   | com.google.code.kaptcha.impl.DefaultKaptcha           |
| kaptcha.textproducer.impl        | 文本实现类                                                   | com.google.code.kaptcha.text.impl.DefaultTextCreator  |
| kaptcha.textproducer.char.string | 文本集合，验证码值从此集合中获取                             | abcde2345678gfynmnpwx                                 |
| kaptcha.textproducer.char.length | 验证码长度                                                   | 5                                                     |
| kaptcha.textproducer.font.names  | 字体                                                         | Arial, Courier                                        |
| kaptcha.textproducer.font.size   | 字体大小                                                     | 40px.                                                 |
| kaptcha.textproducer.font.color  | 字体颜色，合法值： r,g,b  或者 white,black,blue.             | black                                                 |
| kaptcha.textproducer.char.space  | 文字间隔                                                     | 2                                                     |
| kaptcha.noise.impl               | 干扰实现类                                                   | com.google.code.kaptcha.impl.DefaultNoise             |
| kaptcha.noise.color              | 干扰 颜色，合法值： r,g,b 或者 white,black,blue.             | black                                                 |
| kaptcha.obscurificator.impl      | 图片样式：<br />水纹 com.google.code.kaptcha.impl.WaterRipple <br /> 鱼眼 com.google.code.kaptcha.impl.FishEyeGimpy <br /> 阴影 com.google.code.kaptcha.impl.ShadowGimpy | com.google.code.kaptcha.impl.WaterRipple              |
| kaptcha.background.impl          | 背景实现类                                                   | com.google.code.kaptcha.impl.DefaultBackground        |
| kaptcha.background.clear.from    | 背景颜色渐变，开始颜色                                       | light grey                                            |
| kaptcha.background.clear.to      | 背景颜色渐变， 结束颜色                                      | white                                                 |
| kaptcha.word.impl                | 文字渲染器                                                   | com.google.code.kaptcha.text.impl.DefaultWordRenderer |
| kaptcha.session.key              | session key                                                  | KAPTCHA_SESSION_KEY                                   |
| kaptcha.session.date             | session date                                                 | KAPTCHA_SESSION_DATE                                  |



```xml
<!-- https://mvnrepository.com/artifact/com.github.penggle/kaptcha -->
<dependency>
    <groupId>com.github.penggle</groupId>
    <artifactId>kaptcha</artifactId>
    <version>2.3.2</version>
</dependency>

```

### 

### 添加一个前置Filter

```java
http.addFilterBefore(new CodeFilter(), UsernamePasswordAuthenticationFilter.class);
```



```java
package com.mashibin.csrf;

import com.google.code.kaptcha.Constants;
import org.springframework.security.authentication.AuthenticationServiceException;
import org.springframework.util.StringUtils;

import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * @author LYX
 * @description
 * @date 2022/2/13 20:23
 */
public class CodeFilter implements Filter {
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        HttpServletRequest req = (HttpServletRequest)request;
        HttpServletResponse resp = (HttpServletResponse)response;
        //当前这个用户请求的url
        String uri = req.getServletPath();

        if(uri.equals("/login") && req.getMethod().equalsIgnoreCase("post")) {

            String sessionCode = req.getSession().getAttribute(Constants.KAPTCHA_SESSION_KEY).toString();
            String formCode = req.getParameter("code").trim();

            if(StringUtils.isEmpty(formCode)) {
                throw new RuntimeException("验证码不能为空");
            }
            if(sessionCode.equalsIgnoreCase(formCode)) {

                System.out.println("验证通过");

            } else {
                throw new RuntimeException("验证码错误!");
            }
            System.out.println(req.getSession().getAttribute(Constants.KAPTCHA_SESSION_KEY));
            throw new AuthenticationServiceException("xx");
        }
        chain.doFilter(request, response);
    }
}

```

显示验证码的Controller

```java
	@Autowired
    private Producer captchaProducer;
	
	@GetMapping("/kaptcha")
    public void getKaptchaImage(HttpServletRequest request, HttpServletResponse response) throws Exception {
        HttpSession session = request.getSession();
        response.setDateHeader("Expires", 0);
        response.setHeader("Cache-Control", "no-store, no-cache, must-revalidate");
        response.addHeader("Cache-Control", "post-check=0, pre-check=0");
        response.setHeader("Pragma", "no-cache");
        response.setContentType("image/jpeg");
        String capText = captchaProducer.createText();
        
        session.setAttribute(Constants.KAPTCHA_SESSION_KEY, capText);
        BufferedImage bi = captchaProducer.createImage(capText);
        ServletOutputStream out = response.getOutputStream();
        ImageIO.write(bi, "jpg", out);
        try {
            out.flush();
        } finally {
            out.close();
        }
    }
```



## Session共享 

**认证：账号密码对不对**

**授权：赋予的权限**

**JWT**(Java web token)

![image-20220213211537276](image/image-20220213211537276.png) 



![image-20220213211946925](image/image-20220213211946925.png) 

**用redis做session共享**

![image-20220213212222485](image/image-20220213212222485.png) 





**ip  hash 定向流量分发(很容易导致流量倾斜)，不止能发会话，比如用户我们根据他的ip地址取hash值，hash值取出来之后再取机器台数取余数，直接打到其中的一台机器上，如果ip不变的话，那么我们每次的请求都只会到一台机器上，每台机器上只要存储客户端打到他自己的session就够了**



**只要你有这个sessionId，就能够访问所有有这个sessionid的节点**



#### 配置文件

```
spring.redis.host=localhost
#spring.redis.password=
spring.redis.port=6379

spring.security.user.name=123
spring.security.user.password=123

server.port=81
```

#### 依赖

```
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-security</artifactId>
		</dependency>
		

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
			<exclusions>
				<exclusion>
					<groupId>org.junit.vintage</groupId>
					<artifactId>junit-vintage-engine</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
		<dependency>
			<groupId>org.springframework.security</groupId>
			<artifactId>spring-security-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-redis</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.session</groupId>
			<artifactId>spring-session-data-redis</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
```

## 



![image-20220214091823698](image/image-20220214091823698.png) 

**客户端登录系统生成的信息分为3部分**

1. 头信息：签名算法
2. 消息体：载荷(可以写：用户的唯一标识以及其他)
3. *签名：系统通过密文参与到签名的生成中

hash[base64(头+体) + 密文] = 签名

![image-20220214093445693](image/image-20220214093445693.png) 



**使用Https、ssl、tls或者对数据进行二次加密来防范http网络被截取的问题  主要是使用后三个**

**token被截取了怎么办？对数据做二次加密**

**JWT的缺点就是 发出去的token就没办法再控制了，只能靠服务端和客户端功能去维护token**



**服务端自己下发的字符串，要求不能被篡改，客户端提交请求的时候只要这个token是原模原样的，后端就能成功解析**



**服务端不存会话，但是服务器还要存JWT的授权信息**



### 密文如何防止外泄

可以靠SpringCloud Config统一配置文件下发，在开发过程中，可以通过权限控制来防止程序员知晓密文，创建开发分支，只能拉dev环境的配置，不能啦prod生成环境的配置。



![image-20220214124517787](image/image-20220214124517787.png) 

## JWT

JSON Web Token

https://jwt.io/

### 应用场景

JWT是一种基于JSON的令牌安全验证(在某些特定的场合可以替代Session或者Cookie)，一次生成随处校验



### JWT组成

#### 头部信息(header)

 作用:指定该JWT使用的签名

```
  {
      “alg”: “HS256”,// 签名算法
      “typ”: “JWT” //token类型  
  }
```

将上面的json，用Base64URL 算法转成字符串，即为header。

#### 消息体playload

也就是负载的信息

```
{
"exp" (expiration time)：过期时间
"sub" (subject)：主题,一般用用户id,用来标识用户会话
"iat" (Issued At)：签发时间
}
```

这个 JSON 对象也要使用 Base64URL 算法转成字符串。
**作用**:JWT的请求数据

#### 签名( signature)

Signature 部分是对前两部分的签名，防止数据篡改。
需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。

```
HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload),secret) header.payload.signature
```



**头部、声明、签名用 . 号**

最终：把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用"点"（.）分隔连在一起就得到了我们要的JWT



### 实现

#### pom依赖

```
<dependency>
      <groupId>io.jsonwebtoken</groupId>
      <artifactId>jjwt</artifactId>
      <version>0.7.0</version>
 </dependency>
```

#### 

#### JWT工具类

```java
package com.mashibing.admin;

import java.util.Base64;
import java.util.Calendar;
import java.util.Date;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.ExpiredJwtException;
import io.jsonwebtoken.Jwts;

/**
 * @author yueyi2019
 */
public class JwtUtil {
   /**
     * 密钥，仅服务端存储
     */
    private static String secret = "ko346134h_we]rg3in_yip1!";

    /**
     *
     * @param subject   消息体
     * @param issueDate 签发时间
     * @return
     */
    public static String createToken(String subject, Date issueDate) {
    	
    	
        Calendar c = Calendar.getInstance();  
        c.setTime(issueDate);  
        c.add(Calendar.DAY_OF_MONTH, 20);        
        
    	
    	
        String compactJws = Jwts.builder()
                .setSubject(subject)
                .setIssuedAt(issueDate)
                //过期时间
                .setExpiration(c.getTime())
                		
                .signWith(io.jsonwebtoken.SignatureAlgorithm.HS512, secret)
                .compact();
        return compactJws;

    }

    /**
     * 解密 jwt
     * @param token
     * @return
     * @throws Exception
     */
    public static String parseToken(String token) {
        try {
            Claims claims = Jwts.parser().setSigningKey(secret).parseClaimsJws(token).getBody();
            if (claims != null){
                return claims.getSubject();
            }
        }catch (ExpiredJwtException e){
            e.printStackTrace();
            System.out.println("jwt过期了");
        }

        return "";
    }

}
```

**main方法测试**

```java
public static void main(String[] args) {

        String token = createToken("userId=1,role=admin,price=398", new Date(System.currentTimeMillis()));
        System.out.println(token);
    }

eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJ1c2VySWQ9MSxyb2xlPWFkbWluLHByaWNlPTM5OCIsImlhdCI6MTY0NDgxNDcxMSwiZXhwIjoxNjQ2NTQyNzExfQ.qrCN_NE487n-KiYPLn6nI4CiUbhNDOOMGdq5DKQF9Lccpxvb9H_lMeEr7CYDV8EZ7m7fwUigFh35CJPH0ZJsmA

生成的token虽然可以用base64算法解析出来，但是我们有秘钥的存在他就不能进行修改，服务端只要校验token对不对就行了
    public static void main(String[] args) {
        byte[] bytes = Base64.decodeBase64("eyJhbGciOiJIUzUxMiJ9");
        System.out.println(new String(bytes));
    }
{"alg":"HS512"}

校验消息体
    
    public static void main(String[] args) {
        //返回消息体 校验token
        String subject = parseToken("eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJ1c2VySWQ9MSxyb2xlPWFkbWluLHByaWNlPTM5OCIsImlhdCI6MTY0NDgxNDcxMSwiZXhwIjoxNjQ2NTQyNzExfQ.qrCN_NE487n-KiYPLn6nI4CiUbhNDOOMGdq5DKQF9Lccpxvb9H_lMeEr7CYDV8EZ7m7fwUigFh35CJPH0ZJsmA");
        System.out.println(subject);
    }

userId=1,role=admin,price=398
    
```

#### Filter校验

```
@WebFilter(filterName = "authFilter", urlPatterns = "/**")
@Component
public class MyFi implements Filter {

	@Override
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
			throws IOException, ServletException {

		HttpServletRequest req = (HttpServletRequest) request;
		String token = req.getHeader("token");

		if (token != null) {
			// 判断解析token是否成功
			String parseToken = JwtUtil.parseToken(token);

			if (!StringUtils.isEmpty(parseToken)) {
				System.out.println("auth success");
				chain.doFilter(request, response);
			}

		} else {
			System.out.println("auth failed");
		}
	}

	@Override
	public void init(FilterConfig filterConfig) throws ServletException {
		// TODO Auto-generated method stub
		System.out.println("来了老弟");
		Filter.super.init(filterConfig);
	}
```

 请求一次但是打印了两次，是因为request和response都得走这个过滤器

![image-20220214130640932](image/image-20220214130640932.png)

**如果token过期了，会抛异常，重新登录**



![image-20220214132334114](image/image-20220214132334114.png) 	

**可以通过记录上下文表示来记录同一个用户登录了几次**



## JWT替换SpringSecurity session

jwt.io

## Jwt Token在浏览器如何防止重放攻击



**Token的安全性问题**



### Token的携带方式

**浏览器**

- http header
- url上的get请求
- Cookies
- localStorage



1.例如：在主站的页面中(没有跨域请求)的页面中，内嵌了一个非法的js页面，该js页面可以获取到服务端的接口，也能拿到token，通过get/post请求来完成非法的操作

![image-20220214214134056](image/image-20220214214134056.png) 

**App**

- 本地存储
- 前后端签名，私钥存储



**不管是web端还是APP端这个token是不可能防止被盗的**



### **HMAC**(对称加密 在浏览器中还是不安全)

hash(url + 时间戳 + token+ 盐) = hmac     

**但是为什么要加盐呢？**可以增加复杂度，可以增强内网安全认证

数据在传输过程中对数据产生的摘要，用于传输防篡改



### XSS重放攻击



**HTTPS、SSL、TLS**

1、数据防篡改 

2、防钓鱼网站, 有Ca认证(验证你这次请求是不是真实的请求，防止篡改用户的本地的host文件)



**每次请求都下发一个新的token，但是新的token还是会被窃取到**

**把token的过期时间设置的短一点，有一点效果，但是没什么实际作用**

![image-20220214222354513](image/image-20220214222354513.png) 







**解决办法：**

**Web端：**(防不住)

**转义，对URLEncode，对非法字符给编码成带%的字节码，在源头就把非法的表单提交给去除掉**

**定义扫描服务器上的静态资源，扫描数据库中的表字段，查看是否有非法字符，例如:<script src=""......**

**可以加入人机交互，对于请求一些敏感资源上可以加图形验证码或者发手机验证码，加图形验证码的验证是比较有效的**

**App端：**

**App中是没有XSS重放攻击的**

但是h5 webview是会有XSS重放攻击的隐患的，**可以用本地代理，在代理方法中过滤无效请求**



![image-20220214225223390](image/image-20220214225223390.png) 



**App加固**

**提升App安全，对代码进行混淆，混淆之后是无法反编译的**



![image-20220214225432221](image/image-20220214225432221.png) 



**最好的方式就是转移责任：1、提示用户不要在公有的网络下做转账操作；2、敏感信息做人机交互；**



防止假的App获取到我们的token后进行非法操作的解决办法：可以通过本地的自定义协议做动态验证，比如说每次发出去的数据都按照一定的规则去加密(类似于HMAC)

![image-20220214225921547](image/image-20220214225921547.png) 



**物理隔离**

内网隔离，跟税局网络运维差不多





## OAuth2.0

定义了一系列的流程和交互的模式

**用户登录了一个系统之后，通过authorization server会返回一个token，用户可以通过token访问Resource Server，但是如果想实现通过这个token还能访问AppClient的话，就需要OAuth2.0授权AppClient，可以授权给AppClient一些不私密的信息进行访问(比如说昵称、头像等等)，因为我能够标记我在Resource Server肯定是有的**(两边其实都是互为resource server)。这些角色每一个都是对外提供的服务，都是需要去authorization server授权服务去拿token的

![image-20220215123703509](image/image-20220215123703509.png) 





![img](image/160fd879095d008.jpg)

**OAuth 的核心就是向第三方应用颁发令牌**

能够做到一个应用向用户征求授权，来向资源服务器获取资源

### 应用场景

- 单点登录
- 第三方登录



### 角色

![Alt text](image/1)

**Resource Owner**

资源拥有者，对应微信的每个用户微信上设置的个人信息是属于每个用户的，不属于腾讯。

**Resource Server**

资源服务器，一般就是用户数据的一些操作（增删改查）的REST API，比如微信的获取用户基本信息的接口。

**Client Application**

第三方客户端，对比微信中就是各种微信公众号开发的应用，第三方应用经过`认证服务器`授权后即可访问`资源服务器`的REST API来获取用户的头像、性别、地区等基本信息。

**Authorization Server**

认证服务器，验证第三方客户端是否合法。如果合法就给客户端颁布token，第三方通过token来调用资源服务器的API。



### 授权认证流程

### 授权类型

**anthorization_code**

授权码类型，适用于Web Server Application。模式为：客户端先调用`/oauth/authorize/`进到用户授权界面，用户授权后返回`code`，客户端然后根据code和`appSecret`获取`access token`。

**implicit** 简化类型，相对于授权码类型少了授权码获取的步骤。客户端应用授权后认证服务器会直接将access token放在客户端的url。客户端解析url获取token。这种方式其实是不太安全的，可以通过**https安全通道**和**缩短access token的有效时间**来较少风险。

**password**

密码类型，客户端应用通过用户的username和password获access token。适用于资源服务器、认证服务器与客户端具有完全的信任关系，因为要将用户要将用户的用户名密码直接发送给客户端应用，客户端应用通过用户发送过来的用户名密码获取token，然后访问资源服务器资源。比如支付宝就可以直接用淘宝用户名和密码登录，因为它们属于同一家公司，彼此**充分信任**。

**client_credentials**

客户端类型，是不需要用户参与的一种方式，用于不同服务之间的对接。比如自己开发的应用程序要调用短信验证码服务商的服务，调用地图服务商的服务、调用手机消息推送服务商的服务。当需要调用服务是可以直接使用服务商给的`appID`和`appSecret`来获取token，得到token之后就可以直接调用服务。

#### 其他

- **scope**：访问资源服务器的哪些作用域。一组权限，Role
- **refresh token**：当access token 过期后，可以通过refresh token重新获取access token。

### 应用场景

#### 微信授权

https://developers.weixin.qq.com/doc/oplatform/Mobile_App/WeChat_Login/Development_Guide.html

### 实现

#### 依赖

```
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.2.7.RELEASE</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>
	<groupId>com.mashibing.admin</groupId>
	<artifactId>o1</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>o1</name>
	<description>Demo project for Spring Boot</description>

	<properties>
		<java.version>1.8</java.version>
		<spring-cloud.version>Hoxton.SR4</spring-cloud.version>
	</properties>

	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-security</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>


		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
			<exclusions>
				<exclusion>
					<groupId>org.junit.vintage</groupId>
					<artifactId>junit-vintage-engine</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
		<dependency>
			<groupId>org.springframework.security</groupId>
			<artifactId>spring-security-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-oauth2</artifactId>
		</dependency>
		
		
		<dependency>  
 <groupId>org.springframework.boot</groupId>  
 <artifactId>spring-boot-starter-data-redis</artifactId>  
</dependency>
	</dependencies>

	<dependencyManagement>
		<dependencies>
			<dependency>	
				<groupId>org.springframework.cloud</groupId>
				<artifactId>spring-cloud-dependencies</artifactId>
				<version>${spring-cloud.version}</version>
				<type>pom</type>
				<scope>import</scope>
			</dependency>
		</dependencies>
	</dependencyManagement>

	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>
		</plugins>
	</build>

</project>

```



#### 认证服务器

```java
package com.mashibing.oauth;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;
import org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;
import org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;
import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;
import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerSecurityConfigurer;

@EnableAuthorizationServer
@Configuration
public class AuthorizationServerConfiguration  extends AuthorizationServerConfigurerAdapter {


    /**
     * appid
     * secret
     *
     *
     * @param clients
     * @throws Exception
     */
    @Override
    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
        clients.inMemory()
                .withClient("client")
        //填写认证的地址 登录成功之后跳转的地址
        .redirectUris("http://localhost:8080/order")
                //指定权限
                .scopes("read","write")
                //秘钥
                .secret("secret")
                //支持的权限认证方式
                .authorizedGrantTypes("authorization_code","password","implicit","client_credentials");}

    @Override
    public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {
        super.configure(security);
    }

    @Override
    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {
       endpoints.authenticationManager(authenticationManager);
    }

    @Autowired
    @Qualifier("authenticationManagerBean")
    private AuthenticationManager authenticationManager;
}
```



#### security配置

```java
package com.mashibing.oauth;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.builders.WebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.crypto.password.NoOpPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.formLogin()
                .and().csrf().disable()
                .authorizeRequests().anyRequest().authenticated();
    }

    @Override
    public void configure(WebSecurity web) throws Exception {
        super.configure(web);
    }

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.inMemoryAuthentication().withUser("111").password("222").authorities("user")
                .and().withUser("admin").password("admin").authorities("admin");
    }

    @Bean
    @Override
    public AuthenticationManager authenticationManagerBean() throws Exception {
        return super.authenticationManagerBean();
    }


    @Bean
    PasswordEncoder passwordEncoder() {
        return NoOpPasswordEncoder.getInstance();
    }
}
```

#### 资源服务器(标记了用户访问哪些服务需要哪些的权限)

```java
package com.mashibing.oauth;


import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;
import org.springframework.security.oauth2.config.annotation.web.configuration.ResourceServerConfigurerAdapter;

@EnableGlobalMethodSecurity(prePostEnabled = true)
@EnableResourceServer
@Configuration
public class ResourceServerConfiguration extends ResourceServerConfigurerAdapter {
	@Override
	public void configure(HttpSecurity http) throws Exception {
		http.antMatcher("/oauth2/api/**").authorizeRequests()
			.antMatchers(HttpMethod.GET, "/oauth2/api/read/**")
				//作用域
				.access("#oauth2.hasScope('read')")
			.antMatchers(HttpMethod.GET, "/oauth2/api/write/**").access("#oauth2.hasScope('write')")
			;
	}

}
```



#### 第三方服务

```java
@RestController
public class MainController {
    
    @GetMapping("/oauth2/api/me")
    public Authentication me() {
        //for debug
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        return authentication;
    }
    
    
    @GetMapping("/oauth2/api/read/xxoo")
    public Authentication xxoo() {
        //for debug
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
      
        System.out.println("xxpp");
        
        return authentication;
    }
    
    @GetMapping("/oauth2/api/write/xxoo")
    public Authentication write() {
        //for debug
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        System.out.println("write");
        return authentication;
    }
}
```

 

#### 使用PostMan获取token



![image-20200525181255386](image/image-20200525181255386.png)

**需要先登录一下，才能给其他服务授权**

检查到没登录跳到登录中心



登录成功选择权限，你要给当前用户分配什么

![image-20220215160053924](image/image-20220215160053924.png) 

授权了一个read之后，权限认证中心就会下发一个token

![image-20220215160159206](image/image-20220215160159206.png) 

![image-20220215160240625](image/image-20220215160240625.png) 



**可以使用数据源去获取，放一个数据源进去，所有的字段都使用jdbc传输**

![image-20220215160551033](image/image-20220215160551033.png) 





![image-20220215161013752](image/image-20220215161013752.png) 



**他需要向认证中心去认证账号，认证完之后去换token，换完token的时候回到当前的Callback URL中**

**换回来的token是设置了一些的权限的**



做单点登录使用的，他和传统的单点登录的区别是，他提供了一种更加安全的机制，就是下发token，与jwt一样，也可以直接接入jwt把他变成jwt，还可以附带一些信息。如果有第三方的应用到我的系统。



### 学习资源



https://oauth.net/2/

OAuth2从RFC 6749开始

https://tools.ietf.org/html/rfc6749



### 阿里云的浏览器介入流程

https://help.aliyun.com/document_detail/135390.html?spm=a2c4g.11186623.6.559.179b3ccbNHt8PM

![a1](image/a1.png)



### 移动端和桌面端应用的OAuth2.0接入流程

https://help.aliyun.com/document_detail/135588.html?spm=a2c4g.11186623.6.561.1f382cb7Jc48oR

![img](image/b1.png)

## **OpenID**

![Back Home](image/openid-r-logo-900x360.png)

OpenID是一个去中心化的网上身份认证系统。对于支持OpenID的网站，用户不需要记住像用户名和密码这样的传统验证标记。取而代之的是，他们只需要预先在一个作为OpenID身份提供者（identity provider, IdP）的网站上注册。OpenID是去中心化的，任何网站都可以使用OpenID来作为用户登录的一种方式，任何网站也都可以作为OpenID身份提供者。OpenID既解决了问题而又不需要依赖于中心性的网站来确认数字身份。

https://openid.net
