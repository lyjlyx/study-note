# 多线程与高并发实战(一)



## 什么是进程线程纤程

### 从底层角度理解什么是进程

![image-20220306093323837](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220306093323837.png)

双击可执行程序之后他会到内存中变成一个进程

**操作系统进行资源分配的基本单位**



## 从通俗角度理解什么是线程

**一个程序里头不同的执行路径叫做线程**



## 从底层角度理解什么是线程

真正开始执行的时候，程序是以线程的单位来执行的

一个进程里面包含了多个线程(进程就是资源分配的基本单位)

线程在进程内部是调度执行的基本单位，多个线程共享同一个进程里面的所有资源



## 什么是线程的切换

**Context Switch(上下文切换)**

![image-20220306094834133](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220306094834133.png)



### 面试题

#### 单核CPU设定多线程是否有意义？

有意义，多线程的操作并不是所有的资源都消耗CPU的，比如某个线程要等待网络的输入，等到输入的数据过来之后我才能继续后续的运行指令，这个时候其实是不消耗cpu的，因为是在等待数据，所以并不消耗cpu，这个时候就可以把这个时间让给别的线程去执行了。



**CPU密集：**

包含计算消耗CPU



**IO密集：**

等待数据简单消耗CPU的操作



#### 工作线程数是不是设置的越大越好？

不是，线程之间的切换也是要消耗资源的



#### 工作线程数(线程池中的线程数量)设多少合适？

根据CPU的内核数和CPU的计算能力来设定到底需要多少个线程(可以通过压测来验证)，最好可以利用CPU的80%，另外的20%可以用来处理一些紧急情况。



#### 线程数量的设定公式

![image-20220306104314068](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220306104314068.png)

#### 怎么才能知道W/C是多少呢？

需要通过工具进行测算，Profiler，



## 创建线程的5种方法

1. new MyThread().start()
2. new Thread(r).start()
3. new Thread(lambda).start()
4. ThreadPool
5. Future Callable and FutrueTask 



![image-20220306110413885](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220306110413885.png) 

1. 继承Thread，重写run方法，start()方法调用
2. 实现Runnable接口



### 使用ThreadPool

后续会讲

### 线程池和Callable

Callable接口放到线程池中去执行

使用get()方法阻塞的获取线程的执行结果

### 运用FutureTask





## 线程的状态



### Java的6种线程状态

1. NEW:   线程刚刚创建，还没有启动
2. RUNNABLE   可运行状态， 由线程调度器可以安排执行
3. WAITING     等待被唤醒
4. TIMED WAITING     隔一段时间后自动唤醒
5. BLOCKED      被阻塞，正在等待锁
6. TERMINATED    线程结束



### 线程状态迁移

![image-20220306142440919](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220306142440919.png)

RUNNING：正在执行

READY：通过Thread.yield让出了CPU已经准备好了等着操作系统调度

BLOCKED：等待进入同步代码块的锁。synchronized

除了synchronized等待锁的状态叫BLOCKED，其他的状态都叫WAITING

TIMED WAITING：隔一段时间之后就醒了



### NEW_RUNNABLE_TERMINATED

时间片 轮到你了叫RUNNING，没有轮到叫READY

### WAITING_TIMEDWAITING



### BLOCKED

**锁住了争取不到的时候是BLOCKED状态**



**总结：**

**New一个线程还没有调用start的时候他是NEW状态，整个线程执行完成服务结束了之后，他是TERMINATED，只有synchronized阻塞住的时候才会有BLOCKED状态，其他的都是WAITING。只有经过操作系统的调度才会进入BLOCKED状态。**



## 线程的interruption

**线程的”打断“**，并不是线程的停止或者中断

![image-20220306150927985](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220306150927985.png)

- interrupt 设置中断标志位，线程看到这个标志位的时候要不要做什么处理由线程自己做决定  **设置标志位**

- isInterrupted 查看这个线程有没有设置标志位 **查询标志位**

- static interrupted 查看当前线程是否被打断过，查看线程是否被设定过标志位，如果被设定过则重置标志位。

   **查询标志位并重置也是线程结束的一种方案**

### interrupt_and_isInterrupted

![image-20220306151538996](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220306151538996.png) 



### interrupt_and_ interrupted

![image-20220306151947843](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220306151947843.png) 



### interrupt_and_sleep



**当我们调用sleep、wait、join的时候我们是可以向他们设置打断标志位interrupt的，但是设置的时候他们都会抛异常**

![image-20220306152352431](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220306152352431.png)

当抛出InterruptedException的时候Java会自动默认的帮我们把标志位复位为false



### interrupt_and_wait

![image-20220306152540111](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220306152540111.png)



### interrupt_and_synchronized

interrupt设置标志位是否可以打断争抢锁的过程呢？

不可以，他只是打个标记位而已。



### interrupt_and_lock





### interrupt_and_lockInterruptibly

如果想要打断锁的争抢过程则使用ReentrantLock类，里面的lockInterruptibly

![image-20220306154302432](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220306154302432.png)

### 总结

![image-20220306154333651](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220306154333651.png) 

可以比较优雅的终止一个线程。



## 线程的结束

**如何优雅的结束一个线程？**

![image-20220306154541675](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220306154541675.png) 



### 使用stop方法结束线程

**已经不建议使用了。**

stop方法容易产生数据不一致的问题

### 为什么不建议使用stop方法？

不管线程处于什么状态，他直接就把他给干掉了，他会释放该线程的所有锁，并且不做任何善后的工作。stop方法容易产生数据不一致的问题。



### suspend_resume

suspend恢复

resume暂停



### 为什么不建议使用suspend_resume

与stop被废原因相似，如果忘记设置resum恢复的话，很容易造成死锁的现象



### volatile结束线程

![image-20220306160157298](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220306160157298.png) 

volatile只要不依赖于中间状态，时间上的结束会比较难控制

### interrupt结束线程

比较优雅



### 总结

![image-20220306162246668](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220306162246668.png) 





# 并发编程三大特性开篇

- **可见性(visibility)**
- **有序性(ordering)**
- **原子性(atomicity)**



## 可见性的基本概念

![image-20220306163117745](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220306163117745.png)



**如果加上了sout的话这个线程就不会一直卡死，因为sout输出语句中有synchronized，他会造成数据的同步刷新，从而running更改为false就会被thread线程看到了。**

![image-20220306163657533](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220306163657533.png)



**volatile可以保持线程的可见性，volatile所修饰的这块内存，对于他的任何修改，另外一个线程都是立马可见的。被volatile修饰的内存每次都会去主内存去读一遍，如果另外一个线程修改了他，就会马上刷新到主内存中。**



### 某些语句触发内存缓存同步刷新

在某些语句执行的情况下，他是可以出发本地的缓存和我们主内存之间的刷新和同步的



### volatile修饰引用类型

**volatile 是一个引用类型(包括数组)，他只能保证引用本身的可见性，不能保证内部字段的可见性。修饰引用类型可以共享，修饰对象不行**



## 三级缓存



![image-20220306175020466](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220306175020466.png)

![image-20220306175219122](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220306175219122.png)



### 缓存行的基本概念

**程序的局部性原理:** 

**当我们读到某一块数据的时候，相邻的数据在一般情况下很快就会读到。**

**按块读取，程序局部性原理，可以提高效率，充分发挥总线CPU针脚等一次性读取更多数据的能力。**

**当我用到一个值的时候，我很快就会用到他相邻的那个值。**所以我们在读数据的时候就是直接把这一块都读出来。



**一行缓存行（cache line）大概是64个字节**

![image-20220306203020608](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220306203020608.png)



### 通过程序认识缓存一致性

long类型占用了8个字节，那么有8个long就能把一个缓存行给填满

![image-20220306204017310](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220306204017310.png) 

![image-20220306204032271](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220306204032271.png) 

没添加：791ms

上述程序中在x两边添加了毫无意义的两行long类型的变量   开始时间和结束时间为239ms



左边的计数器只要读x的但是把y也读进去了，而右边的只要读y的 但是把x给读进去了

![image-20220620231342850](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220620231342850.png) 

左右两边的寄存器都读到了同一块的数据，所以左边的x修改了数据之后要用一种机制通知右边的cpu，去刷新最新的数据。同理右边也一样。



**缓存一致性协议，当多线程修改的东西位于同一行的情况时，反而会互相干扰**



**上述程序中，左边加了7个long类型（56 字节），右边加了7个long类型，中间的数据x一定不会与另外一个线程中的x位于同一行。所以不用互相之间同步消息。**



**不止有volatile才会产生缓存一致性协议的问题，所以volatile和缓存行的概念不是一样的。**



### 认识Contended 只有1.8启用

被这个注解标记的数据不会跟缓存行位于同一行

默认是被限制住的

![image-20220306211932486](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220306211932486.png) 



### 认识硬件层面的缓存一致性

#### MESI Cache一致性协议

![image-20220306212518671](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220306212518671.png) 



### 为什么缓存一行是64字节？

缓存行越大，局部性空间效率越高，但读取时间慢

缓存行越小，局部性空间效率越低，但读取时间快

取一个折中值，目前都用：64字节



## 并发编程之有序性

### 程序真的是按顺序执行的吗？

未必



### 乱序的分析

![image-20220306225338718](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220306225338718.png) 



**两个语句之间有一定的概率会交换执行**

![image-20220306225318621](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220306225318621.png)



### 为何会存在乱序

**为了提高效率**

![image-20220306225717459](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220306225717459.png)

**一般情况下是很难发生乱序的情况的，但是如果前后指令没有依赖关系，那么这两条语句很有可能乱序**



### 乱序的原则



**as-if-serial**

**不影响单线程的最终一致性**



## 通过一个小程序认识可见性和有序性

ready和number有可能会换顺序

![image-20220307130322739](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220307130322739.png) 



## 对象的半初始化状态

![image-20220307131217972](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220307131217972.png) 



## this对象逸出



![image-20220307131433458](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220307131433458.png) 



![image-20220307131619489](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220307131619489.png) 



this的中间状态的逸出构造方法了

**一般不要在构造方法中new线程然后启动，确保构造方法完成之后再启动线程，不然可能会造成逸出。**



## 链接到美团7连问

![image-20220307133148308](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220307133148308.png)

### 关于Object o = new Object()

![image-20220307133126341](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220307133126341.png)



#### 请解释一下对象的创建过程？

首先向内存中申请内存空间设默认值，然后执行构造方法设置初始值，再与成员变量建立关联。



#### 加问DCL与Volatile问题？(指令重排)

volatile：保持线程可见性，禁止指令重排，因为volatile修饰的内存都是在前面加屏障后面加屏障，所以就能禁止重排列



**DCL**(Double Check Lock)

```java
public class SingletonDCL {

    private static volatile SingletonDCL INSTANCE;

    private SingletonDCL() {
    }

    private SingletonDCL getINSTANCE() throws InterruptedException {
        //为什么还要加一层if呢，为了提高性能，不让线程一进来就去抢锁
        if (INSTANCE == null) { //Double Check Lock 双重检查
            synchronized (SingletonDCL.class) {
                if (INSTANCE == null) {
                    Thread.sleep(1000);
                    INSTANCE = new SingletonDCL();
                }
            }
        }
        return INSTANCE;
    }

    public static void main(String[] args) {
        for (int i = 0; i < 10000; i++) {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        System.out.println(new SingletonDCL().getINSTANCE().hashCode());
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }

                }
            }).start();
        }
    }

}
```



![image-20220307225628162](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220307225628162.png)



**有可能进行指令重排序**

![image-20220307225617730](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220307225617730.png)

![image-20220307225828586](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220307225828586.png)

synchronized new对象的时候new了一半，可能发生了指令，第二个线程过来之后直接就用了



#### 对象在内存当中的存储布局

markword：标记字

class pointer：new 出来的对象，这个对象属于哪个class的指针

instance data：实例数据

padding：64位对齐8字节对齐，如果前面三块不能被8整除的话要补充上去，比如25字节，需要再加7个变成32字节

![image-20220307230610322](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220307230610322.png)

没压缩8字节，压缩了4字节

**压缩指针** 4字节



#### 普通对象指针

例如：指向一个string对象的指针，也是经过压缩的，会压缩成4个字节

#### 类指针

记录属于哪个class，默认是启动压缩的，压缩完是4个字节

**压缩是为了节省空间**

![image-20220308123530578](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220308123530578.png)



对象头：markWord 、类型指针class pointer



#### markword

使用jol

pom

```xml
		<!--观察Java对象布局-->
        <dependency>
            <groupId>org.openjdk.jol</groupId>
            <artifactId>jol-core</artifactId>
            <version>0.9</version>
        </dependency>
```



```java
public class HelloJol {

    public static void main(String[] args) {
        Object o = new Object();
        String s = ClassLayout.parseInstance(o).toPrintable();
        System.out.println(s);
        o.hashCode();
        System.out.println(ClassLayout.parseInstance(o).toPrintable());
    }
}
```

指针大小

![image-20220308124429433](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220308124429433.png)

压缩classpoint 压缩orderingpointer



-XX:-UseCompressedPointers -XX:UseCompressedOopt



#### 对象头具体包括什么？

**最重要的是包括锁信息，其他都是次要的hashCode，GC信息**



给Object上锁

```java
public class HelloJol {

    private static class T {
        int m = 8;
        String s = "hello";
    }

    public static void main(String[] args) {
        Object o = new Object();
        String s = ClassLayout.parseInstance(o).toPrintable();
        System.out.println(s);
        //如果打印了hashcode 那么他的头也是不一样的
		o.hashCode();
        synchronized (o) {
            System.out.println(ClassLayout.parseInstance(o).toPrintable());
        }
    }
}
```

![image-20220308131349448](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220308131349448.png)



这里的hashCode是**identity hashCode（独一无二的）**

包括markword、classpointer、synchronized锁信息。



**压缩普通对象指针**



#### 对象怎么定位

直接定位或间接定位

![image-20220308131622021](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220308131622021.png)



#### 对象怎么分配？

一个对象在new出来之后首先尝试的是在栈上分配，如果能在栈上分配那么就分配在栈上(效率极高，但不是所有的对象都能在栈上分配的，好处就在于一旦他弹出那么他的整个生命周期就结束了)，什么样的对象能在栈上分配呢？

**头易分析，可以进行标量替换。**



**TLAB(Thread Local Allocation Buffer)线程本地分配缓冲区**：

多个线程往同一块空间里头去分配对象的时候，必须要经过同步sync，同步就会损耗资源，所以有一个线程本地缓冲区

**当我们往一块内存区域new对象的时候总是要分配空间的，好多线程共同去抢这块空间的时候，必须要经过同步。需要做线程的协调，所以在Hotspot里面设计了TLAB。**

**线程本地缓冲区：当一个线程启动的时候，为这个线程本地分配一个小小的空间，供这个线程独享，这个线程new出来的对象都往里面放，他就不需要去跟别的线程抢了**



![image-20220308132844305](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220308132844305.png)

**头易分析，标量替换。**



#### Object o = new Object()占多少字节？

要看有没有压缩classpoint，有没有压缩oops

20字节（o也要占空间 4个字节）



#### Hotspot为什么不用C++对象？

C++ -> *virtual table指针 指向虚方法表，用来实现多态

OOP description class 二元机制 生成的C++对象

T.class C++对象(Instance class)



#### Class对象是在堆还是在方法区？

**无论JDK版本都在方法区(method area)**



**链接到美团7连问 (1小时52分31秒)需要去回顾一下最后的知识点(重要)**

![image-20220308140429938](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220308140429938.png) 

 

**首先在栈空间里面有一个o，new出来的Object在堆中，这个对象指向了一个class，而这个class是一个C++对象（instanceClassOop在方法区中），在C++中生成class对应的对象时候，这个对应的还有一个指针O.class，放到堆中，O.class是给反射用的。**

![image-20220621110632571](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220621110632571.png) 



## 如何阻止乱序执行

### happens-before原则



**JVM规定指令顺序不能替换的规则（不要去背，没有人会问）**

- 程序次序规则：同一个线程内，按照代码出现的顺序，前面的代码先于后面的代码，准确的说是控制流顺序，因为要考虑到分支和循环结构。
- 管程锁定规则：一个unlock操作先行发生于后面(时间上)对同一个锁的lock操作
- **volatile变量规则：对一个volatile变量的写操作先行发生于后面(时间上)对这个变量的读操作**
- 线程启动规则：Thread的start()方法先行发生于这个线程的每一个操作。
- 线程终止规则：线程的所有操作都先行于线程的终止检测。可以通过Thread.join()方法结束，Thread.isAlive()的返回值等手段检测线程的终止
- 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断时间的发送，可以通过Thread.interrupt()方法检测线程是否中断。
- 对象终结规则：一个对象的初始化完成先行于发生它的finalize()方法的开始。
- 传递性：如果操作A先行于操作B，操作B先行于操作C，那么操作A先行于操作C



### CPU用屏障指令阻止乱序

内存屏障是特殊指令：**看到这种指令，前面的必须执行完，后面的才能执行**

intel：Ifence sfence mfence(CPU特有指令)



### JVM内存屏障规则

Load读，Store写

![image-20220308154237914](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220308154237914.png)

只是要求JVM实现这几种功能。



### 用volatile禁止指令重排

保持线程可见性，禁止指令重排序

![image-20220308205607254](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220308205607254.png) 





### volatile在hotspot中的实现

![image-20220308210623939](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220308210623939.png)

volatile修饰的内存，不可以重排序，对volatile修饰变量的读写访问，都不可以换顺序



1: volatile i

2: ACC_VOLATILE

3: JVM的内存屏障

​	屏障两边的指令不可以重排！保障有序！

​    happends-before 

​    as - if - serial

4：hotspot实现

bytecodeinterpreter.cpp

```c++
int field_offset = cache->f2_as_index();
          if (cache->is_volatile()) {
            if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
              OrderAccess::fence();
            }
```

orderaccess_linux_x86.inline.hpp

```c++
inline void OrderAccess::fence() {
    //如果CPU内核是多核的
  if (os::is_MP()) {
    // always use locked addl since mfence is sometimes expensive
#ifdef AMD64
      //rsp加了个0  核心是lock
    __asm__ volatile ("lock; addl $0,0(%%rsp)" : : : "cc", "memory");
#else
      //对esp加了个0
    __asm__ volatile ("lock; addl $0,0(%%esp)" : : : "cc", "memory");
#endif
  }
}
```

> **LOCK 用于在多处理器中执行指令时对共享内存的独占使用。
> 它的作用是能够将当前处理器对应缓存的内容刷新到内存，并使其他处理器对应的缓存失效。**
> **另外还提供了有序的指令无法越过这个内存屏障的作用。**



### 面试题

DCL单例要不要加volatile？

要加，对象创建的时候半初始化的时候会被别人看到。



## 原子性

**原子性相对复杂**

从一个简单的小程序谈起：

```java
package com.mashibing.juc.c_001_sync_basics;

import java.util.concurrent.CountDownLatch;

public class T00_IPlusPlus {
    private static long n = 0L;

    public static void main(String[] args) throws Exception {

        Thread[] threads = new Thread[100];
        CountDownLatch latch = new CountDownLatch(threads.length);

        for (int i = 0; i < threads.length; i++) {
            threads[i] = new Thread(() -> {
                for (int j = 0; j < 10000; j++) {
                    //synchronized (T00_IPlusPlus.class) {
                    n++;
                    //}
                }
                latch.countDown();
            });
        }

        for (Thread t : threads) {
            t.start();
        }

        latch.await();

        System.out.println(n);

    }
}
```

**为什么会导致这个数据不一致的问题呢，是因为++操作先要从内存中读取数据到寄存器中，加完后再写回去，还没有来得及写回去的时候，有另外的线程又读到了原值，前一个线程执行的时候被后一个线程打断了。**



**要保证这种数据操作不被别的线程打断，他就不会出现数据不一致的现象**

**不能被打断的这种操作被称之为原子操作**

**一些基本概念**

race condition => 竞争条件 ， 指的是多个线程访问共享数据的时候产生竞争

数据的不一致（unconsistency)，并发访问之下产生的不期望出现的结果

如何保障数据一致呢？--> 线程同步（线程执行的顺序安排好），

monitor （管程） ---> 锁

critical section -> 临界区

如果临界区执行时间长，语句多，叫做 锁的粒度比较粗，反之，就是锁的粒度比较细



### 底层原子性和JVM原子性

![image-20220308220457288](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220308220457288.png) 



### 用上锁保证原子性

具体： 保障操作的原子性（Atomicity)

1. 悲观的认为这个操作会被别的线程打断（悲观锁）synchronized（上一个小程序）

2. 乐观的认为这个做不会被别的线程打断（乐观锁 自旋锁 无锁）cas操作
   CAS = Compare And Set/Swap/Exchange

   ```java
   /**
    * 解决同样的问题的更高效的方法，使用AtomXXX类
    * AtomXXX类本身方法都是原子性的，但不能保证多个方法连续调用是原子性的
    * @author mashibing
    */
   package com.mashibing.juc.c_018_00_AtomicXXX;
   
   import java.util.ArrayList;
   import java.util.List;
   import java.util.concurrent.atomic.AtomicInteger;
   
   
   public class T01_AtomicInteger {
   	/*volatile*/ //int count1 = 0;
   	
   	AtomicInteger count = new AtomicInteger(0);
   
   	/* synchronized */void m() {
   		for (int i = 0; i < 10000; i++)
   			//if count1.get() < 1000
   			count.incrementAndGet(); //count1++
   	}
   
   	public static void main(String[] args) {
   		T01_AtomicInteger t = new T01_AtomicInteger();
   
   		List<Thread> threads = new ArrayList<Thread>();
   
   		for (int i = 0; i < 100; i++) {
   			threads.add(new Thread(t::m, "thread-" + i));
   		}
   
   		threads.forEach((o) -> o.start());
   
   		threads.forEach((o) -> {
   			try {
   				o.join();
   			} catch (InterruptedException e) {
   				e.printStackTrace();
   			}
   		});
   
   		System.out.println(t.count);
   
   	}
   
   }
   
   ```




我们平时所说的"上锁"，一般指的是悲观锁

**synchronized保障不了有序性**



**上锁的本质就是把原来所谓的并发操作变成了序列化**



同时保障可见性

注意序列化并非其他程序一直没机会执行，而是有可能会被调度，但是抢不到锁，又回到Blocked或者Waiting状态（sync锁升级）

一定是锁定同一把锁（抢一个坑位）



## 一些同步的基本概念_锁的粒度

monitor(管程)---->锁

critical section (临界区)-->锁定的里面的代码

**如果临界区执行时间长，语句多，叫做锁的粒度比较粗，反之，就是锁的粒度比较细**

准确的来说并不是我锁定了某段代码，而是我锁定了某个对象，只有持有这个对象的锁的时候才能执行里面的代码，不管你的代码有多少行。只有我这个线程执行完了同样的代码才能在这个线程中执行。由于大家访问的都是同一份数据，按照序列化访问是没有问题的，所以他不会出现数据一致性的问题，保障了一致性。

具体：**保障操作的原子性**

### 两种方式保障原子性(Atomicity)

#### 悲观锁

悲观的认为这个操作一定会被别的线程打断(悲观锁)synchronized(上一个小程序)

#### 乐观锁

乐观的认为这个操作不会被别的线程打断(乐观锁  自旋锁 无锁) cas操作

CAS = Compare And Set/Swap/Exchange

例子：**当a值为0的时候，线程一将a拿过来做+1操作之后  a为1，然后去原值那里匹配，判断a值是否还是为0，如果a为0就代表a没有被别的线程操作过，就把1赋值进去。反之，如果这时候a值为8那么就证明a值被别的线程动过了，那么线程1再把8拿过来进行了+1操作，循此往复，直到成功赋值上为止。**

但是还是有可能在你比较这个值是不是还是原值的时候，另外一个线程给他改为了8，如果前面的比较是true那么这个值就又出问题了。



**如果要产生作用的话就要保证CAS本身就是原子性的**

![image-20220308223148036](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220308223148036.png)

##### CAS的ABA问题

其他线程修改次数最后值和原值相同，给数据加一个version、时间戳、或者数字、布尔等等都可以解决ABA问题。



##### 通过AtomicInteger类深入认识CAS

compareAndSwapInt类方法



#### 深入Hotspot代码深入理解CAS

![image-20220309130332352](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220309130332352.png) 



核心是调用Atomic::cmpxchg这个操作

![image-20220309130444779](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220309130444779.png) 

![image-20220309130625239](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220309130625239.png)



CPU底层就直接支持了CAS

CAS的ABA问题解决方案 - **Version**

CAS操作本身的原子性保障

AtomicInteger:

```java
public final int incrementAndGet() {
        for (;;) {
            int current = get();
            int next = current + 1;
            if (compareAndSet(current, next))
                return next;
        }
    }

public final boolean compareAndSet(int expect, int update) {
        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
    }
```

Unsafe:

```java
public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);
```

运用：

```java
package com.mashibing.jol;

import sun.misc.Unsafe;

import java.lang.reflect.Field;

public class T02_TestUnsafe {

    int i = 0;
    private static T02_TestUnsafe t = new T02_TestUnsafe();

    public static void main(String[] args) throws Exception {
        //Unsafe unsafe = Unsafe.getUnsafe();

        Field unsafeField = Unsafe.class.getDeclaredFields()[0];
        unsafeField.setAccessible(true);
        Unsafe unsafe = (Unsafe) unsafeField.get(null);

        Field f = T02_TestUnsafe.class.getDeclaredField("i");
        long offset = unsafe.objectFieldOffset(f);
        System.out.println(offset);

        boolean success = unsafe.compareAndSwapInt(t, offset, 0, 1);
        System.out.println(success);
        System.out.println(t.i);
        //unsafe.compareAndSwapInt()
    }
}
```

jdk8u: unsafe.cpp:

cmpxchg = compare and exchange set swap

```c++
UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))
  UnsafeWrapper("Unsafe_CompareAndSwapInt");
  oop p = JNIHandles::resolve(obj);
  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);
  return (jint)(Atomic::cmpxchg(x, addr, e)) == e;
UNSAFE_END
```

jdk8u: atomic_linux_x86.inline.hpp **93行**

is_MP = Multi Processors  

```c++
inline jint     Atomic::cmpxchg    (jint     exchange_value, volatile jint*     dest, jint     compare_value) {
  int mp = os::is_MP();
  __asm__ volatile (LOCK_IF_MP(%4) "cmpxchgl %1,(%3)"
                    : "=a" (exchange_value)
                    : "r" (exchange_value), "a" (compare_value), "r" (dest), "r" (mp)
                    : "cc", "memory");
  return exchange_value;
}
```

jdk8u: os.hpp is_MP()

```c++
  static inline bool is_MP() {
    // During bootstrap if _processor_count is not yet initialized
    // we claim to be MP as that is safest. If any platform has a
    // stub generator that might be triggered in this phase and for
    // which being declared MP when in fact not, is a problem - then
    // the bootstrap routine for the stub generator needs to check
    // the processor count directly and leave the bootstrap routine
    // in place until called after initialization has ocurred.
    return (_processor_count != 1) || AssumeMP;
  }
```

jdk8u: atomic_linux_x86.inline.hpp

```c++
#define LOCK_IF_MP(mp) "cmp $0, " #mp "; je 1f; lock; 1: "
```

最终实现：

cmpxchg = cas修改变量值

```assembly
lock cmpxchg 指令
```

**但是cmpxchg这条指令并不是原子的**

硬件：

**lock指令在执行的时候视情况采用缓存锁或者总线锁**



可以使用**AQS**这个框架来写我们想要的锁



#### 两种锁的效率

**乐观锁不一定比悲观锁效率高**

例如：

**悲观锁是一个一个进去的，所以队列中等待的人是不会消耗CPU资源的，而乐观锁就是会一直去询问锁有没有释放，这样的询问是消耗CPU资源的(自旋)**



不同的场景：

临界区执行时间比较长 ， 等的人很多 -> 重量级

时间短，等的人少 -> 自旋锁

实战最好就用synchronized，里面已经做了很多的优化了，又有自旋锁又有偏向锁



### synchronized和三大特性

**synchronized是可以保障可见性的，在我们解锁之后，他会把我们所有的内存状态跟我们本地的缓存做一个刷新对比，保障一致性，然后下一个线程才能够执行。**

![image-20220310131729286](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220310131729286.png) 



## synchronized&volatile你以为你真的懂了？*

![image-20220310132541293](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220310132541293.png) 



**CAS**

ABA问题，给数据打标签

```
CAS底层的实现是由
lock cmpxchg
cmpxchg这条命令cpu是有底层支持的，但是他不是原子的，他很有可能在执行的过程中被其他的CPU给打断，所以需要加锁
```

lock指令是在执行cmpxchg这条指令的过程当中把总线上锁，或者把某个信号上锁不允许被其他CPU打断。

![image-20220310133736320](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220310133736320.png)

**MP如果是多个处理器的话就加lock，如果不是多个处理器就不加lock。**



##  用户态与内核态

JDK早期synchronized叫做重量级锁，因为申请锁资源必须通过kernel，系统调用。

内核态是访问内核空间的他能执行系统的所有指令，而用户态只能访问用户能够访问的指令。



ring0~ring~3



![image-20220621143046446](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220621143046446.png) 



## markword

T.class

int m = 8;

**工具Java Object Layout**

**了解一个对象的内存布局吗？**

**例如：new T对象 里面有一个成员变量int m = 8，这个对象在堆内存就是有8个字节的markword（直接背过），classpoint是4个字节的类型指针(指向哪个类T.class)，instance state 成员变量 (上面的int类型) 占4个字节，一个对象在Hotspot中实现要求这个对象8字节对齐(对象的字节大小务必是8 的整数倍)，如果不是8的整数倍那么要补上。**



**markword中记录的最重要的信息就是锁**

![image-20220314160856343](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220314160856343.png) 

new-偏向锁-轻量级锁（无锁，自旋锁，自适应自旋）-重量级锁



如何区分是哪种锁呢？

先看markword最低两位，最低两位如果是00那么就是轻量级锁，最低两位如果是10那么就是重量级锁，最低两位如果是11，那么就是GC的标记（CMS过程用到的标记），无锁和偏向锁都为01，他们通过偏向锁位来区分0或者1

![image-20220314161055360](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220314161055360.png)



**轻量级锁也叫自旋锁**

**new出来的普通对象，普通对象加锁加synchronized关键字变成偏向锁，偏向锁轻度竞争变成轻量级锁，轻量级锁再竞争变成重量级锁。**



![image-20220314161824301](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220314161824301.png)

### 偏向锁

![image-20220314162506658](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220314162506658.png) 



StringBuffer线程安全，但是大多是的synchronized的代码段在多数时间实际运行的时候是只有一个线程的。

**偏向锁是没有必要设置锁的机制的，没有竞争，效率非常高，第一次第一个线程来的时候直接把自己的线程id写到markword里面，因此偏向锁其实只是把当前线程的指针扔到自己的markword里面。为了减少同一个线程对于加锁和解锁这两个步骤所消耗的时间。**



#### **什么叫自旋锁？**

偏向锁撤销，撤销之后让两个线程自旋竞争



#### 自旋锁竞争

每个线程在自己的线程栈内部生成一个LR（Lock Record）的东西，用自旋的方式将这个LockRecord指针添加到markword中。另外一方则



### 重量级锁

当这个锁必须得向操作系统申请的时候markword，markword里面记录的是一个叫Object Monitor这个就是在JVM空间写的一个C++对象，而这个C++系统在内部访问的时候要通过操作系统，经过操作系统之后拿到操作系统对应的那把锁，到了这种情况后你才能给他锁定，锁定完之后才能去干活



![image-20220314174740454](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220314174740454.png) 



#### 锁重入

synchronized是可重入锁，相当于是一个继承

重入次数必须记录，因为要解锁几次必须得对应

**偏向锁 自旋锁记录在线程栈里每重入一次LR+1**

**identityHashCode，所有的锁他的hashCode都存在了LR线程栈里了，LR里面备份自己的markword**

**重量级锁->ObjectMonitor字段上**



**synchronized方法是可以调用同一个线程的synchronized方法的，所以锁是可以重入的。**



#### 轻量级锁(自旋锁)什么时候升级为重量级锁

竞争加剧，有线程超过了10次自旋(可以用过参数控制,1.6之后就不要调了，有自适应)，或者线程数超过CPU的一半，

![image-20220314182207167](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220314182207167.png)

**为什么有自旋锁还需要重量级锁？**

自旋这个事情是会消耗CPU时间的，如果锁的时间长或者自旋线程多，CPU资源会被大量消耗。



**重量级锁核心在于，当你持有一把锁的时候，你想向操作系统申请这把锁，操作系统给你这把锁，但是他会把这个线程扔到锁上面的一些队列里面，如果说我们等到的线程数有很多，在那里消耗CPU时间，还不如把这个锁升级成重量级锁，升级完重量级锁之后他会做一个管理，凡是自旋等待拿不到锁的线程，都扔到一个WaitSet中，扔到一个队列中，不让你执行，冻结在那里。什么时候要抢那把锁需要通过操作系统的进程调度，不需要消耗CPU时间，把这个线程拿出来之后才有资格持有这把锁。这个时候重量级锁会比自旋锁更合适。**

linux内核对进程的调度叫CFS。

**重量级锁有等待队列，所有拿不到锁的进入等待队列，不需要消耗CPU资源**



****



**偏向锁是否一定比自旋锁效率高？**

不一定，在明确知道会有多线程竞争的情况下，这个时候是没有必要使用偏向锁的，因为偏向锁肯定会设计到锁撤销，锁撤销会平白无故的耗费时间，这时候直接关闭偏向锁，这时候直接使用自旋锁。

JVM启动过程会有很多线程竞争(明确)，所以默认启动时不打开偏向锁，等启动完成之后再打开



在偏向锁未启动的时候就是new的普通对象001，在偏向锁已启动的时候就是101(刚开始没有偏向任何线程，所以叫匿名偏向)



**synchronized锁升级深入详解 1小时.49分钟没看**

![image-20220314204455937](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220314204455937.png) 

启动线程的3种方法：1、Thread；2、Runnable；3、Executors.newCacheThread；





# 2019版多线程



### 异常跟锁

**程序在执行过程中，如果出现异常，默认情况锁会被释放**



### synchronized的底层实现

JDK早期的时候是重量级的

**有一个锁升级的概念**

**synchroized(Object)：不能用String常量，或其他的引用类型**



markword 记录这个线程号 ID(偏向锁，默认将来不会有第二个人抢这把锁)

如果有线程征用：升级为，自旋锁(10次，占用CPU但是不访问操作系统，所以他是在用户态解决这个问题，不在内核态)

10次之后如果还没有得到这把锁，那么就去升级为重量级锁(去找操作系统拿)

**锁只能升级，不能降级**



**执行时间比较长，线程比较多的情况下使用系统锁。**

**执行时间比较短(加锁代码)，线程较少的情况下使用自旋锁。**



### Volatile保证线程可见性 

 **保证线程可见性，禁止指令重排序**



 加了volatile之后能够保证一个线程改变了这个值之后另外一个线程能够立马改变

缓存一致性协议



编译器在编译对象的时候做了三步，1、申请内存；2、初始化成员变量；3、将这个对象赋值



### Volatile不能保证原子性



### synchronized优化

锁定某个对象o，如果o的属性发生了改变，不影响锁的使用，但是如果o变成了另外一个对象，则锁定的对象发生改变，但应该避免将锁定对象的引用变成另外的对象。



**锁定方法 非锁定方法是同时执行的**

**锁升级：**

偏向锁、自旋锁、重量级锁



在系统级别加上volatile我们是禁止不了指令重排序的，但是在虚拟机或语言级别的理论上就可以。



**volatile加上了读屏障和写屏障**

loadfence原语指令、storefence原语指令



### CAS

**无锁优化   自旋**

compare and set/swap



**AtomicInteger**

CAS是CPU指令级别的支持，中间是不能被打断的，CPU原语支持



#### ABA问题

加version



### Unsafe 等同于C和C++的指针

![image-20220317131838386](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220317131838386.png) 

![image-20220317132410641](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220317132410641.png) 



### LongAdder

![image-20220317133752403](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220317133752403.png)



**LongAddr为什么会比其他两个都快**

内部做了一个类似于分段锁的概念，像如果10000个线程的并发，他会先把2500加上锁，然后自增，再把自增的值统一一下，在并发线程数量特别高的情况下很有优势。



## 新类型的锁



### ReentrantLock

**可以替代synchronized的**

**原来写synchronized的地方直接写上这ReentrantLock对象.lock()，相当于加锁，但是一定要注意的是要unlock**



**比较灵活**

lockInterruptibly 可以对interrupt()方法做出响应

可以用trylock指定上锁，也可以用lockinterruptibly打断



**公平和非公平的切换**



### CountDownLatch

![image-20220317211511759](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220317211511759.png)

**类似于门栓，倒数基数**



### CyclicBarrier

**相当于是一个栅栏，满了之后把栅栏推到**

满了多少人之后，发车

![image-20220317223407095](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220317223407095.png)  

**应用场景：**

**限流：入口有很多，出口只有一个	**



### Phaser

按照不同的阶段对线程进行执行，每个阶段的人都到齐了再执行下一个阶段的方法

**遗传算法**





### ReadWriteLock

读写锁

**读写锁**

概念：

**共享锁**：

**排它锁**：

不管是写的时候还是读的时候都需要上一把锁



###  Semaphore

**信号灯**

**限流**：最多允许多少个线程同时运行

![image-20220318131927390](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220318131927390.png)

![image-20220318131934477](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220318131934477.png)

.**acquire()获得某个许可，而不是获得某个许可**





![image-20220318132338105](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220318132338105.png)



上面的锁其实都是通过队列来控制的。



**AQS类实现的队列**

**AbstractQueuedSynchronizer**



### Exchanger

**用于线程之间交换数据用的**

![image-20220318132649304](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220318132649304.png)  



可以想象成是一个容器，exchange方法是阻塞的，只能是两个线程之间的交换。



**去了解stampedLock是ReadWriteLock的升级态**



#### volatile的具体实现

保持数据的可见性，禁止指令的重排序，缓存一致性的协议，写入和读取之前添加内存屏障来禁止指令的重排序。



**synchronized和ReentrantLock有什么不同？**

synchronized能够自动加锁自动解锁，ReentrantLock则需要我们自己手动加锁手动解锁

ReentrantLock可以出现不同的等待队列 

ReentrantLock是CAS的实现，而synchronized是锁的升级



### LockSupport

专门为了支持锁的一个类

停止							解除停止

LockSupport.park()  LockSupport.unPark()



我们想要线程阻塞的话是需要使用wait()和await()方法的，而且这样还需要使用synchronized来配合，解除锁需要使用notify来解除

而LockSupport实现了当前线程阻塞和叫醒指定线程

 

**unPark可以先于park调用，这样即使调用了park线程也不会停**

![image-20220621202141503](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220621202141503.png)



### 面试题一(1)_volatile

第一个线程变了第二个线程并不会马上看见

![image-20220320145550802](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220320145550802.png) 

![image-20220320145810621](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220320145810621.png)  



也可以使用同步容器

![image-20220320145923439](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220320145923439.png)



**volatile没有绝对的把握最好别用，volatile最少修饰简单的值，不要去修饰引用值**

**如果volatile修饰的是一个引用对象，这个引用对象指向的是new出来的对象，如果这个对象里面的成员变量值改变了，是观察不到的**



### 面试题一(2)_wait,notify



![image-20220621173405034](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220621173405034.png) 



**notify不释放锁，只是叫醒被wait()的线程**

**叫醒线程之后还需要给自己加wait让出这个锁**



### 面试题一(3)_CountDownLatch

![image-20220621201926305](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220621201926305.png)

![image-20220621201944321](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220621201944321.png) 



### 面试题一(4)_Semaphore,其他思路



![image-20220320164933176](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220320164933176.png) 





### 面试题二(1)_synchronized

![image-20220320205658390](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220320205658390.png) 

**背**

```java
package com.msb.visibility;

import java.util.LinkedList;

/**
 * @author LYX
 * @description 写一个固定容量的同步容器，拥有put和get方法，以及getCount方法
 *              能够支撑2个生产者线程以及10个消费者线程的阻塞调用
 * @date 2022/3/20 20:59
 */
public class MyContainer<T> {

    final private LinkedList<T> lists = new LinkedList<>();
    final private int MAX = 10;
    private int count = 0;

    public synchronized void put(T t) {
        while (lists.size() == MAX) { //这里为什么用while而不是if
  			//因为this.wait()的时候当他再次被唤醒了，用if他就不会再去判断list.size=MAX了
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        lists.add(t);
        ++ count;
        this.notifyAll();//通知消费者线程进行消费
    }

    public synchronized T get() {
        T t = null;
        while (lists.size() == 0) {
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        t = lists.removeFirst();
        count --;
        this.notifyAll(); //通知生产者进行生产
        return t;
    }

    public static void main(String[] args) {

    }

}

```

![image-20220320211846834](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220320211846834.png) 





**Condition的本质就是不同的等待队列，一把锁原来只有一个队列，现在每一个Condition都是一个等待队列**

**使用Condition**

```java
package com.msb.visibility;

import java.util.LinkedList;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @author LYX
 * @description
 * @date 2022/3/20 21:28
 */
public class MyContainerCondition<T> {
    final private LinkedList<T> lists = new LinkedList<>();
    final private int MAX = 10;
    private int count = 0;

    private Lock lock = new ReentrantLock();
    private Condition producer = lock.newCondition();
    private Condition consumer = lock.newCondition();

    private void put(T t) {
        try {
            lock.lock();
            while (lists.size() == MAX) {
                producer.await();
            }
            lists.add(t);
            ++ count;
            consumer.signalAll();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    private T get(T t){
        try {
            lock.lock();
            while (lists.size() == MAX) {
                consumer.await();
            }
            lists.removeFirst();
            count --;
            producer.signalAll();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
        return t;
    }
}

```

### 面试题一CAS



### ReentrantLock源码讲解

![image-20220320214907501](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220320214907501.png)  



![image-20220621213317431](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220621213317431.png) 



### AQS（CLH）源码



AQS所有锁的核心

![image-20220320223121599](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220320223121599.png)

**同步队列里面是实现了同步方法，多线程可以安全的访问**

**等待队列，是指这把锁所附带的这些队列**



 **state AQS的核心**

![image-20220320222555302](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220320222555302.png) 

一开始state是0，表示还没获得这把锁，当他变成1的时候就会变成1，什么时候释放了就变成0，所以state代表了加锁和解锁(如果重入了那么就从1再往上加)



**看CountDownLatch源码**

 

**为什么你说AQS的底层是CAS+volatile**

因为里面有一个state常量是volatile的，保障线程可见。

AQS里面有一个内部类Node，里面保留了一个线程，所以这个队列是一个线程队列，并且他有两个Node一个指向前面节点，一个指向后面的节点。所以这个队列是一个一个的Node，是个双向链表。

![image-20220621214903355](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220621214903355.png) 



**AQS的核心是一个state，以及监控这个state的双向链表，每个node里面装的都是一个Thread**

![image-20220621214406499](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220621214406499.png) 

state所代表的意思都是由子类来定义的。

![image-20220320223344002](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220320223344002.png) 

![image-20220320223519823](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220320223519823.png)



![image-20220321131948725](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220321131948725.png) 

![image-20220321132210003](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220321132210003.png)



**compareAndSetTail方法操作就不需要把我们整个的链表进行上锁了，效率上会有所提高**

![image-20220321133023388](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220321133023388.png) 



**VarHandle 是1.9之后才有出现的，指的是指向某个变量的引用，但是本来就有一个变量指向这个对象了，为什么还需要这个varHandle也指向呢？**

![image-20220321133812249](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220321133812249.png)

![image-20220321134052078](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220321134052078.png) 

**VarHandle跟反射比起来效率会更高，VarHandler直接操作二进制码**



### ThreadLocal

我们在使用ThreadLocal的时候里面所设置的值是线程独有的（就是说这个线程里只有自己往里面设置，只有当前线程能够访问到的），而另外一个线程往里设置的时候也是设置自己能够访问到的。

```java
public class ThreadLocalTest {

    static ThreadLocal<Person> tl = new ThreadLocal<>();

    public static void main(String[] args) {
        new Thread(() -> {
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(tl.get());
        }).start();

        new Thread(() -> {
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            tl.set(new Person());
        }).start();
    }

    static class Person{
        String name = "zhangsan";
    }

}
```

**结果: null**



**源码：**

**ThreadLocal泛型里面设置的值是线程独有的**

![image-20220321210630038](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220321210630038.png) 

![image-20220621220259000](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220621220259000.png) 

**ThreadLocalMap是在Thread这个类里的**

![image-20220321210709482](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220321210709482.png)

**Thread.currentThread.map(ThreadLocal, Object)**



**所以当我们set的时候，就是把set的值set到了当前的线程里面的某一个map里面。**

**其实是把value 设到当前这个线程中的一个map里面**

**所以说当一个线程set进去的时候另外一个线程是读不到的**



**ThreadLocal用途：**

**声明式事务保证同一个Connection（配置文件中的连接）**



#### 强引用



**Java的四种引用分别为：**

**强、软、弱、虚**



只要有引用指向一个对象，垃圾回收器就永远不会回收他，这也叫强引用，只有没有引用指向他的时候他才会回收。

![image-20220321212328465](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220321212328465.png) 

![image-20220321212322456](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220321212322456.png)



#### 软引用

SoftReference

**当有一个对象，被一个软引用指向时，只有系统内存不够用了 才会回收他**



![image-20220321212811801](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220321212811801.png) 

![image-20220321212824354](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220321212824354.png) 



#### 弱引用



WeakReference

**只要遭遇到GC就会被回收**

![image-20220321220154107](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220321220154107.png)

**这个弱引用就在于，如果有另外一个强引用指向他的时候，只要这个强引用消失了，那么他就应该被回收**

**一般用在容器中**



了解：WeakHashMap

 ![image-20220321220459943](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220321220459943.png) 

![image-20220321221901779](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220321221901779.png)

使用ThreadLocal如果不用了的话务必要remove掉



#### 虚引用



**堆外内存**



**PhantomReference**

一旦虚引用被回收的时候，这个虚引用会被装到这个队列里面(扔进去一个值相当于是一个通知)。

如果想得到这个通知，我们就要不断的去检测这个队列里面有没有值，如果有值则说明虚引用被回收了。

![image-20220321223346170](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220321223346170.png)



**直接内存（是可以指向堆外内存的）**

![image-20220321223708297](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220321223708297.png)

使用**Unsafe**里面可以直接回收对外内存

allocateMemory直接分配内存

freeMemory	手动回收







### 容器

![容器](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/%E5%AE%B9%E5%99%A8-16479231591151.png)



**容器通过接口来说分为两大类**

**Collection集合**

**Map**



Queue最主要的原因是实现任务的装和取，是为了高并发做准备的，他实现了很多高并发下才要实现的方法



HashTable和Vector：

**自带锁，基本上不用**

 

Collections



HashTable、HashMap、SynchronizedHashMap



**由于hashmap内部没有锁，所以多线程访问的时候会出问题**



#### ConcurrentHashMap的发展



**ConcurrentHashMap比HashTable和SynchronizedHashMap的效率要高，为什么？**

ConcurrentHashMap 在插入的时候的效率并没有比其他的map效率高，**在读的方面上比其他map效率高很多**

在插入的时候经过了各种各样的判断，要变成红黑树还有CAS的判断



#### Vector到Queue的发展

虽然Vector在每个使用的方法上面都加了synchronized，但是在程序执行的过程中(比如其他未加锁的流程)就很容易出现错误。

![image-20220322134403438](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220322134403438.png)



**多线程的程序在考虑容器的时候少考虑list，应该多去考虑concurrent或者Queue**

**tickets.poll()方法上加了很多对于多线程访问的友好的方法**

![image-20220322134759114](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220322134759114.png) 

**poll的原子性的实现是用CAS操作来实现的**

![image-20220322135027248](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220322135027248.png) 	



使用什么集合都是结合实际情况下使用的，例如：如果是当线程的就直接用HashMap、LinkedList、ArrayList，如果是高并发的执行时间比较短的话那么就直接用ConcurrentHash、ConcurrentQueue，但是代码的执行时间特别长，线程的并发量不是特别高的情况下的话，用synchronized，任何情况下都是需要测试和压测来使用哪种容器。



### 经常在多线程情况 下使用的容器1



**跳表ConcurrentSkipListMap**



**CopyOnWriteArrayList**

写时复制

写的时候加锁，读的时候不加锁，在原来的list拷贝一个新的list出来，把添加的数据放到新的list位置末尾，与此同时把指向老的容器的引用指向新的。



**CopyOnwriteSet**



### 经常在多线程情况下使用的容器2

LinkedBlockingQueue

ArrayBlockingQueue

DelayQueue

SynchronusQueue

TransferQueue



**BlockingQueue天生的实现了生产者消费者的功能**

![image-20220322210501227](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220322210501227.png) 



![image-20220322211600022](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220322211600022.png) 

**Queue和List的区别主要是在于添加了  put()、add()、offer()、take()、peek()、offer()、poll()这些对线程友好的方法**

主要在于Queue添加了对线程友好的api offer peek poll，其中Queue的子类BlockingQueue 在原来的基础上又加上了put  take这两个api(主要用于阻塞)



#### DelayQueue

能够按照在里面等待的时间来进行排序

![image-20220322214022304](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220322214022304.png)

![image-20220322214123073](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220322214123073.png)

![image-20220322214133345](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220322214133345.png)

![image-20220322214209824](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220322214209824.png) 

**按照谁等待时间最短来拿**

**一般用来按时间进行任务调度**



#### PriorityQueue 

![image-20220322214641990](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220322214641990.png)

**会按照大小来排序，内部实现了一个优先级，最小的优先，内部实现是一个二叉树，二叉树可以认为是最小堆里面值排到最上面**



#### SynchronusQueue

让一个线程给另一个线程下达任务的，用法与Exchanger相似

![image-20220322215014417](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220322215014417.png) 



#### TransferQueue

**把值装进队列中，需要另外一个线程取走之后他才算完成，不然就一直阻塞在那里**



### 面试题

#### 要求打印A1B2C3D4E5......Z26

##### **使用wait和notify**

wait和notify必须要被synchronized锁定的，不然这两个方法是调用不了的。

```java
public class Question1 {

    public static void main(String[] args) {
        final Object o = new Object();
        char[] ar1 = "1234567".toCharArray();
        char[] ar2 = "ABCDEFG".toCharArray();

        new Thread(() -> {
            synchronized (o) {
                for (char c : ar2) {

                    System.out.println(c);
                    o.notify();
                    try {
                        o.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                o.notify(); //必须notify，否则无法停止程序
            }
        }, "t2").start();

        new Thread(() -> {
            synchronized (o) {
                for (char c : ar1) {
                    System.out.println(c);
                    o.notify();
                    try {
                        o.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                o.notify();
            }
        }, "t1").start();

    }

}
```

**LockSupport方式实现**

```java
public class Question2LockSupportPrintA1B2C3 {

    static Thread t1 = null;
    static Thread t2 = null;
    public static void main(String[] args) {

        char[] ar1 = "1234567".toCharArray();
        char[] ar2 = "ABCDEFG".toCharArray();

        t1 = new Thread(()->{
            for (char c : ar2) {
                System.out.println(c);
                LockSupport.unpark(t2);
                LockSupport.park(); //t1阻塞
            }
        });

        t2 = new Thread(()->{
            for (char c : ar1) {
                LockSupport.park();
                System.out.println(c);
                LockSupport.unpark(t1);
            }
        });

        t1.start();
        t2.start();
    }
}
```



##### **使用ReadyToRun**

![image-20220323131521851](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220323131521851.png)

ps:加volatile是保证线程的可见性



#####  **BlockingQueue**

![image-20220323132011884](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220323132011884.png)

![image-20220323132020179](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220323132020179.png)

##### pipedStream**了解**

![image-20220323132400191](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220323132400191.png) 



![image-20220323132429716](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220323132429716.png)



![image-20220323132437395](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220323132437395.png)





##### **TransferQueue**

![image-20220323132751463](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220323132751463.png) 

![image-20220323132852067](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220323132852067.png) 



### 线程池几个常用类的拓展



#### Executor执行器

**因为executor是一个接口，所以他可以有很多的实现，因此，一个任务的定义和运行就可以分开了**

![image-20220323133331301](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220323133331301.png)

Callable这个接口跟Runnable类似，这个接口设计出来是为了让潜在的两个线程运行。Callable也可以弄出一个线程去运行他。

**因为Callable接口会返回值**



Future ：Callable线程执行完成之后的返回结果

![image-20220323134312609](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220323134312609.png) 

![image-20220323134558576](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220323134558576.png)

Executor相当于是一个线程池里面，找了个线程去运行他

一般来说异步是要求要有一个返回值的



**FutureTask既是一个Future也是一个Task，相当于自己作为一个任务来用，同时这个任务完成的结果也存在我这个任务的对象中。**

**RunnableTask也是一样**

![image-20220323135417295](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220323135417295.png) 

FutureTask会比较灵活



**总结：**

Callable类似于Runnable,但是他有返回值

Future  存储执行的将来才会产生的结果

FutureTask 相当于Future加上Runnable，既可以执行又可以存结果



### CompletableFuture

![image-20220323205737904](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220323205737904.png) 

![image-20220323210615307](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220323210615307.png) 

![image-20220323210224318](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220323210224318.png) 

CompletableFuture相当于是一个任务的管理类。



### 线程池参数



#### ThreadPoolExecutor



**线程池如何自定义**？

**线程池维护了两个集合，一个是线程的集合里面是一个个线程，还有一个是任务的集合里面是一个个任务，这些任务都是放在一个个任务队列中的。**

![image-20220323220538025](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220323220538025.png) 



如何定义一个线程池？

![image-20220622114630522](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220622114630522.png) 



**1、corePoolSize：核心线程数**

**2、maximumPoolSize：最大线程数**

**3、keepAliveTime：生存时间**

**如果线程很长时间没干活了，那就把它归还给操作系统，如果一个线程中起的线程数量越多的话消耗资源也大，所以如果某个线程没活用不着的线程就应该归还给操作系统。**

**4、时间单位**

**5、任务队列**

用各种各样的**BlockingQueue**来存储队列的时候，就会产生各种各样不同的线程池

**6、线程工厂**

需要先去实现ThreadFactory接口(他是一个专门产生线程的接口)

**7、拒绝策略**

线程的执行顺序，例如：corePoolSize = 2。线程池里面没有线程任务，来了一个任务启动一个线程，由于核心线程总数还没到呢，所以这个线程不会归还，一直呆着，如果到第三个任务的时候核心线程没空理他（在工作），则将该任务加入任务队列，假如任务队列满了，并且核心线程也没空处理，则启动新线程去处理，当到达最大线程数，并且大家都忙着的时候，执行拒绝策略。**拒绝策略可以自定义，JDK默认提供了四种**

![image-20220622115854950](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220622115854950.png) 



![image-20220323221650775](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220323221650775.png) 

![image-20220323222201970](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220323222201970.png) 



**一开始线程池里面是一个线程都没有的，后来来一个任务启动一个核心线程池，就算是这个任务执行完了这个核心线程也不会归还，就一直呆在池子里，后来再来一个任务启动一个线程，假如在第三个任务来的时候，核心线程都在操作任务没有空闲去理会第三个任务，就把第三个任务加入到任务队列中，假如任务队列满了并且两个核心线程都忙，又来了第7个任务，那就启动新的线程去处理他，第8个也是。**

**如果所有的线程都忙着，任务队列也满了，那么就执行拒绝策略。**

```java
public class HelloThreadPool1 {


    static class Task implements Runnable{

        private int i;

        public Task(int i) {
            this.i = i;
        }

        @Override
        public void run() {
            System.out.println(Thread.currentThread().getName() + " Task" + i);
            try {
                System.in.read();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        @Override
        public String toString() {
            return "Task{" +
                    "i=" + i +
                    '}';
        }
    }



    public static void main(String[] args) {
        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(2, 4,
                60, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(4),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.AbortPolicy());

        for (int i = 0; i < 7; i++) {
            threadPoolExecutor.execute(new Task(i));
        }

        System.out.println(threadPoolExecutor.getQueue());

        threadPoolExecutor.execute(new Task(100));

        System.out.println(threadPoolExecutor.getQueue());

        threadPoolExecutor.shutdown();
    }
}
```

```
result>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[Task{i=2}, Task{i=3}, Task{i=4}, Task{i=5}]
pool-1-thread-1 Task0
pool-1-thread-2 Task1
[Task{i=2}, Task{i=3}, Task{i=4}, Task{i=5}]
pool-1-thread-4 Task100
pool-1-thread-3 Task6
```

像上面所说的，如果核心线程都在工作的话，并且是第三个线程过来了，就把线程2放入任务队列中，依次类推，直到把任务队列给放满，放满后核心线程还忙着的话，那么就执行新的线程去处理。



**7、拒绝策略**

拒绝策略是可以默认的，JDK给我提供了4种

- Abort：抛异常
- Discard：扔掉，不抛异常
- DiscardOldest：扔掉排队时间最久的
- CallerRuns：调用者处理任务

**实际当中默认的策略都用不上，大都是用自定义的策略，实现接口，然后把没有处理的信息保存在中间件中，比如kafka.......**



### Executors-线程池的工厂

**SingleThreadPool，只有一个线程的线程池，可以保证我们的任务是顺序执行的。**

为什么要有单线程的线程池？

​	1、线程池是有任务队列的，我们可以使用任务队列。

​	2、单线程的线程池的特点是他完整的生命周期管理，线程池能够帮我们提供



![image-20220323230634600](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220323230634600.png) 

为什么不建议使用JDK自带的线程池？

主要的原因是 Queue中是有一个上界的，过了这个上界之后越积越多很有可能会OOM。还有就是如果装不下了的话，他就会使用JDK默认的拒绝策略，这些拒绝策略我们是一定要自定义的。



### CachedPool

![image-20220324123735262](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220324123735262.png) 

来一个任务如果没有别的线程空着就开一个线程，线程数没有上限。不建议使用

SynchronousQueue是一个手递手容量为空的Queue，来一个任务后必须有一个线程拿走，不然提交的任务就阻塞住了



### FixedThreadPool



![image-20220324131358049](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220324131358049.png) 

线程数是固定的

**什么时候用Fixed 什么时候用Cached？**

如果来的任务量忽高忽低，并且还要保证来的任务必须要有人来处理的话就用Cached，但是要保证这个任务不会堆积。

任务来得比较平稳就用Fixed

> 阿里都不用，自己估算，估算好后再进行精确的定义



要预估并发量，看看池里面起了多少个线程

![image-20220324131643023](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220324131643023.png) 



### ForkJoinPool

分解汇总的任务，用很少的线程可以执行很多的任务(子任务) TPE做不到先执行子任务，CPU密集型



### ScheduledPool 定时任务线程池

**专门用来执行定时任务的线程池**

![image-20220324132315851](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220324132315851.png) 

![image-20220324132345536](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220324132345536.png) 

使用的是DelayWorkQueue，隔了多少时间后可以用的Queue

> quartz



![image-20220324132545294](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220324132545294.png)

> 假如提供了一个闹钟服务，订阅这个服务的人特别多，10亿，意味着每天都有10亿的并发量，怎么优化？

主服务器把定时任务分发到边缘的服务器上，在每一台服务器上用线程池加任务队列



### 并发和并行对比

concurrent vs parallel

并发是指任务提交，并行是指任务执行

并行是并发的子集

并行指的是在多个任务在多颗CPU上同时并行处理



**FixedPool**可让任务并行处理

![image-20220324133419191](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220324133419191.png)

![image-20220324133408709](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220324133408709.png)

![image-20220324133359492](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220324133359492.png)

![image-20220324133320416](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220324133320416.png)



### 手敲一个定义拒绝策略的例子

```java
public class MyRejectedHandler {
    public static void main(String[] args) {
        ExecutorService executorService = new ThreadPoolExecutor(
                4, 4, 0, TimeUnit.SECONDS,
                new ArrayBlockingQueue<>(6),
                Executors.defaultThreadFactory(), new MyHandler());

    }
    static class MyHandler implements RejectedExecutionHandler {

        //策略
        @Override
        public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
            //例子：
            //做好日志
            //log("r rejected")
            //保存任务到中间件，kafka或者mysql redis

            //try  3 次尝试
            //判断这个queue是否有空了
            if(executor.getQueue().size() < 10000) {
                //try put again()
            }
        }
    }

}
```



**复习**

**Executor **

**ExecutorService**

AbstractExecutor

**ThreadPoolExecutor**

1. corePoolSize
2. MaxPS
3. keepAliveTime
4. TimeUnit
5. BlockingQueue任务队列
6. ThreadFactory线程工厂
7. RejectStrategy拒绝策略

> Abort、Discard、DiscardOld、CallerRuns





### ThreadPoolExecutor**源码解析**

线程池的五种状态按大小排序：RUNNING< SHUTDOWN<STOP<TIDYING<TERMINATED

![image-20220324231016227](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220324231016227.png) 

![image-20220324231244755](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220324231244755.png) 



![image-20220324231301659](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220324231301659.png) 

![image-20220324231411654](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220324231411654.png) 

reject 拒绝掉

**首先先启动核心线程，核心线程满了的话往队列里面放，队列里面满了之后，里面也没有能够执行任务的线程了，再加非核心线程**



addWorker()就是添加线程的方法，这个线程是存在一个容器里的



线程吃worker()单元

![image-20220324232458782](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220324232458782.png) 

由继承类来看这个worker本身就是一把锁



runWoker()



### WorkStealingPool

**每一个线程都有自己单独的队列，当某一个线程执行完了自己的任务之后，他就会去另外的线程去拿他们还未执行的任务来执行。**



![image-20220325123444704](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220325123444704.png) 

自己去push或者自己去pop的时候不需要加锁，但是别人去拿你这个线程的时候则要加锁



![image-20220325123437533](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220325123437533.png)



###  ForkJoinPool

适合把大任务切分成一个一个小任务执行，这些小任务执行完之后会有一个汇总的过程。

子任务汇总到父任务，父任务在汇总到根任务



RecursiveAction

![image-20220325131727955](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220325131727955.png)

![image-20220325131822807](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220325131822807.png)

![image-20220325131812826](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220325131812826.png)

100万个数决定把这些任务砍成一个个小任务，这个小任务最长不超过5w

![image-20220325132017270](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220325132017270.png) 

还可以通过RescursiveTask去继承，这个类是需要返回值的

![image-20220325132234909](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220325132234909.png)

![image-20220325132305071](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220325132305071.png) 

![image-20220325132622267](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220325132622267.png)

### 两个Pool的区别

![image-20220325132927253](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220325132927253.png)



### 流式API和day8课后总结



![image-20220325133445170](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220325133445170.png)



### day9课前导读和JMH创建

JMH专业测试工具



包含系统的环境变量

![image-20220326113359142](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220326113359142.png)

上图操作是因为JMH包含我们本地的环境变量,JMH在执行的时候就不会在我们的C盘中执行了，会往临时目录里面写

![image-20220326113551847](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220326113551847.png) 

### Disruptor的核心

![image-20220326155445681](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220326155445681.png) 

分裂、瓦解

一个线程中每秒处理600万订单

速度最快的MQ

性能极高，无锁cas，单机支持高并发

用于存放元素的高效率的队列

**Disruptor是一个环形的Buffer，RaingBuffer,是由数组实现的，是一个首尾相连的ArrayQueue**

对于遍历来说，链表的遍历一定会比数组低，但是JDK中没有ConcurrentArrayQueue

**环形数组只要维护一个东西就是sequence序列，这个序列代表的是下一个有效的元素指在哪个位置上。**



对比ConcurrentLikedQueue：链表实现，用数组的实现更快

> 假如长度为8，当添加到12个元素的时候在哪个序号上呢？用12%8决定
>
> 当Buffer被填满的时候到底是覆盖还是等待，由Producer决定
>
> 长度设为2的n次幂，利于二进制计算，例如12%8=12&(8-1)   pos=num&(size -1)



生产者生产特别多消息，消费者来不及消费，那还没被消费的元素是不是就会被覆盖掉？

如果有任务还没有被消费的话是不能被覆盖的，有一个等待策略(7种)，BlockingWait比较常用



**在环形队列中存的是一个一个的事件**



### Disruptor开发步骤

1. 定义Event - 队列中需要处理的元素

2. 定义Event工厂，用于填充队列

   > 这里牵扯到效率问题：disruptor初始化的时候，会调用Event工厂，对ringBuffer进行内存的提前分配
   >
   > GC产频率会降低

3. 定义EventHandler（消费者），处理容器中的元素



可以调用这个时间的工厂来产生这个对象，环的每个位置都有一个这样的事件对象，以后再有新的过来的时候就不用new这个对象而是直接给他里面的值改掉。





### ProducerType

Disruptor生产者是有好多种生产方式的，默认是多线程生产者。

![image-20220326171018968](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220326171018968.png) 



### 等待策略

![image-20220326171105218](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220326171105218.png) 



### 消费者的指定和异常处理



### Disruptor总结

核心是一个RingBuffer，这个环有多个生产者在里面生产，效率高。

环里面有多个生产者可以往里面生产

想定义好Event消息的格式，然后定义消息工厂(初始化环响应位置上的对象)，


