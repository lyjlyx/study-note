# 技术随笔

### 2022.3.2

#### CAP

CAP原则指的是Consistency(一致性)、Availability(可用性)、Partition tolerance(分区容错性)

一致性和可用性从字面上比较好理解，但是分区容错性就比较抽象了

P(分区容错性)详解：

一个分布式系统里面，节点组成的网络本来是连通的。然而可能因为一些故障，使得有些节点之间不连通了

，整个网络就分成了几块区域。数据就散布在了这些不连通的区域中。这就叫**分区**。

当你一个数据项只在一个节点中保存，那么分区出现后，和这个节点不连通的部分就访问不到这个数据了。这时分区就是无法容忍的。

提高分区容忍性的办法就是一个数据项复制到多个节点上，那么出现分区之后，这一数据就可能分布到各个区里。容忍性就提高了。

然而，要把数据复制到多个节点，就会带来一致性的问题，就是多个节点上面的数据可能是不一致的。要保证一致，每次写操作就都要等待全部节点写成功，而这等待又会带来可用性的问题。

总的来说就是，数据存在的节点越多，分区容忍性越高，但要复制更新的数据就越多，一致性就难保证。为了保证一致性，更新所有节点数据所需要的时间越长，可用性就会越低。





### Spring

spring用了哪些设计模式

单例模式、工厂模式、模板模式、





### Java开发

lambda表达式对一个集合中的某个属性去重

```java

List<BloodAssetVO> bloodAssetVOS = bloodAssetVOList.stream().filter(distinctByKey(BloodAssetVO::getTableName)).collect(Collectors.toList());


private static <T> Predicate<T> distinctByKey(Function<? super T,?> keyExtractor){
        Map<Object,Boolean> map=new ConcurrentHashMap<>();
        return t -> map.putIfAbsent(keyExtractor.apply(t),Boolean.TRUE)==null;
    }
```



lambda表达式对两个集合中的某个属性取差集

```java

List<MocCollectOffice> collect = oldMocCollectOfficeList.stream()
                    .filter(oldMoc -> !newReqVOList.stream().map(MocCollectOfficeReqVO::getId)
                            .collect(Collectors.toList()).contains(oldMoc.getId())).collect(Collectors.toList());

```





### 通信协议架构

在软件架构中，Pull（拉取）模型和Push（推送）模型是描述组件如何通信的两种不同的方式。这两种模型定义了数据如何在系统中流动，尤其是在分布式系统或客户端-服务器架构中。

#### Pull 模型（拉取模型）

在 Pull 模型中，接收方（通常是客户端）会主动请求或拉取信息。这意味着数据的传输是由数据的接收者初始化的。这种模型常见于传统的客户端-服务器架构，其中客户端会定期轮询服务器以检查更新。

**优点**:
- 控制性：客户端可以控制请求数据的时间和频率。
- 简单性：通常更容易实现，因为客户端知道何时需要数据。

**缺点**:
- 延迟：更新可能不会立即传达给客户端，因为它依赖于客户端的轮询间隔。
- 资源消耗：如果轮询频率很高，可能会导致不必要的网络流量和服务器负载。

#### Push 模型（推送模型）

在 Push 模型中，发送方（通常是服务器）会主动发送或推送信息到接收方。当有新数据可用时，服务器会立即将其发送给客户端，而不是等待客户端的请求。

**优点**:
- 及时性：数据可以实时或几乎实时传输给客户端。
- 效率：只有当有新数据时，才会产生网络流量，减少了不必要的通信。

**缺点**:
- 控制性：客户端对接收数据的时间和频率的控制较少。
- 复杂性：可能需要更复杂的实现，如长轮询、WebSockets 或服务器发送事件（Server-Sent Events，SSE）。

#### 其他模型架构

除了 Pull 和 Push 模型，还有一些其他的架构模型，例如：

- **发布/订阅模型（Pub/Sub）**：在这种模型中，生产者（发布者）发布消息，而消费者（订阅者）订阅感兴趣的消息。消息代理负责维护主题和分发消息。这种模型可以是基于 Push 的，也可以是基于 Pull 的。
  
- **事件驱动架构（EDA）**：这种架构侧重于事件的生成、检测、消费和响应。系统的组件通过事件进行通信，而不是直接调用彼此的方法。

- **点对点模型**：在这种模型中，每个节点既是客户端又是服务器。节点可以直接相互通信，而不需要中央服务器。

- **请求/响应模型**：这是最传统的通信模型，客户端发送请求到服务器，然后服务器处理请求并返回响应。

- **CQRS（命令查询责任分离）**：这种模型将读操作（查询）和写操作（命令）分离开来，可以优化性能和扩展性。

每种模型都有其适用场景，选择哪种模型取决于应用程序的具体需求，比如数据的实时性要求、系统的扩展性、以及网络资源的利用效率等。





