# 算法与数据结构基础班

设计一个流程就是算法

### 评估算法优劣的核心指标是什么？

时间复杂度（流程决定）

额外空间复杂度（流程决定）

常数项时间（实现细节决定）



### 何为常数时间的操作？

**如果一个操作的执行时间不以具体样本量为转移，每次执行时间都是固定的事件。称这样的操作为常数时间的操作。**（数组的寻址就是一个固定时间的操作，他的执行时间不会随你的样本量变大而发生改变）

![image-20250809091309487](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20250809091309487.png)

**总之，执行时间固定的操作都是常数时间的操作**

**反之，执行时间不固定的操作，都不是常数时间的操作**



![image-20250809092340500](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20250809092340500.png)

**时间复杂度表达式的列式会忽略掉低阶项和系数所剩下来的东西就是时间复杂度。**

**最终都是要把低阶项和系数抹掉的。**

![image-20250809092552416](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20250809092552416.png)

**我们只要确保流程划分的过程中都是常数级别的操作，不用严格精细的纠结他发生了多少次，只要我们保证他是常数级别的操作就够了，因为最终的时间复杂度是不看低阶项也不要高阶项的系数留下来的东西，这就是时间复杂度。**



### 如何确定算法流程的总操作数量与样本数量之间的表达式关系？

1、想象该算法流程所处理的数据状况，要按照最差的情况来。

2、把整个流程彻底拆分为一个个基本动作，保证每个动作都是常数时间的操作。

3、如果数据量为N，看看基本动作的数量和N是什么关系。



### 如何确定算法流程的时间复杂度

**当完成了表达式的建立，只要吧最高阶项留下即可。低阶项都去掉，高阶项的系数也去掉。**

**记为：O(忽略掉系数的高阶项)**



**当我们样本量大到一定程度，或者足够大的时候，我们会发现低阶项是什么高阶项的系数是什么都变得不再重要了。**

![image-20250809093626623](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20250809093626623.png)

![image-20250809093725309](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20250809093725309.png)

**衡量算法流程的复杂程度的一种指标。**



选择排序、冒泡排序、插入排序的时间复杂度都是O(N²)

选择排序：0~N-1范围最小值交换，1~N-1范围最小值交换，2~N-1范围最小值交换......

冒泡排序：0~N 之间 0和1谁大谁交换，1和2谁大谁交换，2和3谁大谁交换....到最后就是最大的值后面的数就搞定了。再就是0~N-1之间的数谁大谁交换。

插入排序：0~0范围之间的数保证有序，0~1范围之间保证有序，0~2范围之间保证有序，从右往左谁小谁交换，往左移动，一路往前换直到最左边没有数了。



**要拿最差的例子得出时间复杂度**



**算法的过程，和具体的语言是无关的**

**想分析一个算法流程的时间复杂度的前提，是对该流程非常熟悉**

**一定要确保在拆分算法流程的时候，拆分出来的所有行为都是常数时间的操作。这意味着你写算法的时候对自己用过的每一个系统API，都非常的熟悉，否则会影响你对时间复杂度的估算。**



### 额外空间复杂度

**常数操作就是时间复杂度为O(1)的操作**



你要实现一个算法流程，在实现算法流程的过程中，你需要开辟一些空间来支持你的算法流程。

作为输入参数的空间，不算额外空间。

作为输出结果的空间，也不算额外空间。

因为这些都是必要的、和现实目标有关的，所以都不算。

但除此之外，你流程如果还需要开辟空间才能让你的流程继续下去，这部分空间就是额外空间。

如果你的流程只需要开辟有限几个变量，额外空间复杂度就是0(1)



### 算法流程的常数项的比拼方式

**放弃理论分析，生成随机数据直接测试**

为什么不去理论？

不是不能纯分析，而是没有必要。因为不同常数时间的操作，虽然都是固定时间，但还是有快慢之分的。

比如，位运算的常数时间远小于算数运算的常数时间，这两个运算的常数时间又远小于数组寻址的时间。

所以如果纯理论分析，往往会需要非常多的分析过程。都已经到了具体细节的程度，莫不如交给实验数据好了。





### 面试、比赛、刷题中，一个问题的最优解是什么意思

**一般情况下，认为解决一个问题的算法流程，在时间复杂度的指标上，一定要尽可能的低，先满足了时间复杂度最低这个指标之后，使用最少的空间算法流程，叫这个问题的最优解**

**一般来说最优解都是忽略掉常数项这个因素的，因为这个因素只决定了实现层次的优化和考虑，而和怎么解决整个问题的思想无关。**





### 常见的时间复杂度

![image-20250810163538909](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20250810163538909.png) 





### 算法和数据结构学习的大脉络

知道怎么算的算法

知道怎么试的算法

所有题目的讲解，对于大脉络的实践贯穿始终。



### 什么叫对数器

![image-20250810165946828](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20250810165946828.png)

#### 认识对数器

![image-20250818105909119](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20250818105909119.png)



### 什么叫二分



![image-20250818161750667](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20250818161750667.png)

**有序数组**

int mid = (L + R) /2   用这个表达式的话可能会导致整数溢出。

如果L 为10亿  R为18亿的情况下 他们两相加就溢出了。

 int mid = L + (R - L) / 2  让L 加上 R- L 一半的数就不会溢出了。

N / 2 == N >> 1

并且 一个数除以二 就等同于这个数二进制的形式带符号右移一位

扩展：

N *2  相当于 N << 1  那么N * 2相当于( N << 1 ) | 1  (N向左移动一位或一个1)





### 局部最小值

**什么叫做局部最小值**

1、位置的数如果比1位置的数小，他就是局部最小

2、N位置的数如果比N-1位置的数小，他就叫做局部最小

3、i -1  i  i + 1  i位置的数既比i-1位置的数小，又比i + 1位置的数小，i位置的数据就是局部最小



arr无序数组，这个数组中任意两个相邻的数都不相等，只要求范围一个局部最小的数返回就行，随便哪一个就行。

可以使用二分法。

arr[ 0 ~ N -1 ] 无序，相邻不等

思路：先看0 位置的数是否比1位置的数大，如果是的话他就不是局部最小，他的趋势是一个向下的↓

再看N-1位置的数是否比N-2位置的数大，如果N-1位置的数更大，那他的趋势是向上的↑

![image-20250818165009554](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20250818165009554.png)

综上所述：**中间必有局部最小值**

我们使用mid标记，从中间开始找

mid - 1 |  mid | mid  + 1 如果 mid比他-1和+1的位置都小的话直接返回mid位置的数，mid就是局部最小的数。



**只要我们构建出一个排掉另外一测的逻辑，而且这个逻辑是正确的，其实就可以使用二分法**



### 认识异或运算

异或运算：相同为0，不同为1

同或运算：相同为1，不同为0

能长时间记住的概率接近0%

**所以，异或运算就记成无进位相加！**

异或运算的性质

1）0^N == N    N^N == 0

2）异或运算满足交换律和结合率（不用管a,b,c,d,e是什么顺序，只要是同一批数异或起来的东西都是一样的）

上面两个性质用无进位相加来理解就非常的容易。





#### 如何不用额外变量交换两个数的值



![image-20250824162423650](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20250824162423650.png)

不申请任何额外变量的情况下把a和b的值交换

![image-20250824162844513](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20250824162844513.png)

a = a ^ b;     a =  甲 ^ 乙，  b = 乙

b = a ^ b;     a = 甲 ^ 乙,     b = 甲 ^ 乙 ^ 乙 ===>  b = 甲 ^ 0  ===> b = 甲

a = a ^ b;     a =  甲 ^ 乙 ^ 甲，  b = 甲  ===>    a = 乙



如果相同的值的情况下是没问题的，因为a和b指向的内存并非同一个，**如果指向的内存是同一个的话就会出问题。**

![image-20250824163824144](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20250824163824144.png)

**必须要保证内存是独立的**

![image-20250824164526646](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20250824164526646.png)



#### 一个数组中只有一种数出现了奇数次，其他数都出现了偶数次，怎么找到这种数

![image-20250824164957608](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20250824164957608.png)

eor向右异或数组的所有数，最后eor是什么就是那个出现了奇数次的数。

异或运算和异或的顺序无关，异或运算满足交换律和结合律

![image-20250824165146940](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20250824165146940.png)

所以我们把eof把整个数组异或起来其实就等同于，把所有相同的数一组一组的异或起来。

![image-20250824165330623](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20250824165330623.png)

偶数次的异或都变成了0，最后奇数次的数得到为4

```java
public class EventTimesOddTime {
    public static void printOddTime(int[] arr) {
        int eor = 0;
        for (int i = 0; i < arr.length; i++) {
            eor ^= arr[i];
        }
        System.out.println(eor);
    }
    public static void main(String[] args) {
        int[] arr = {2,2,2,3,5,3,5,6,8,8,8,8,6,6,6,7,7,7,7};
        printOddTime(arr);
    }
}
```



#### 怎么把一个int类型的数，提取出最右侧的1来

如何把N最右侧的1提取出来其他的都变成0

![image-20250824173607301](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20250824173607301.png)

**N&(~N + 1)**

N = 0 0 1 1 0 1 0 1 0 0 0 0

~N = 1 1 0 0 1 0 1 0 1 1 1 1

~N + 1 = 1 1 0 0 1 0 1 1 0 0 0 0 

![image-20250824174022917](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20250824174022917.png)

**我们可以发现他们&上之后就只留下了最右侧的1**

**可以认为，取反加1，其实就是把我们除了最右边的1之外的所有东西都求反了。最右侧的1在取反的时候会被拆成0，后面的所有0都会被拆成1的状态，+1之后就相当于把变成1的数都恢复回去了，把最右侧的1也恢复回去了。**



#### 一个数组中有两种数出现了奇数次，其他的数都出现了偶数次，怎么找到这两种数

eor

arr[  ]



















































