# 算法和数据结构新手班



## 什么是算法

1、有具体的问题

2、有设计解决这个问题的具体流程

3、有评价处理流程的可量化指标



## 算法的分类

分类非常之多

算法不挑语言



## 简单的功能代码



### 题目一：阶乘

![image-20220819131038419](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220819131038419.png) 

当前阶乘的结果是上一步阶乘的结果乘以自己这一步。

时间复杂度、空间复杂度。



交换器

```JAVA
public static void convert(int[] arry, int i, int j) {
  int tmp = arry[i];
  arry[i] = arry[j];
  arry[j] = tmp;
}
```



### 题目二：选择排序

从小到大排序

每次找到最小值放到前面往后移动，直到全部排好

```java
    /**
     * 选择
     * @param arry
     */
    public static void selectSort(int[] arry) {
        if (arry.length < 2) {
            return;
        }
        int N = arry.length;
        for (int i = 0; i < N; i++) {
            int minIndex = i;
            for (int j = i + 1; j < N; j++) {
                minIndex = arry[minIndex] < arry[j] ? minIndex : j;
            }
            convert(arry, i, minIndex);
        }
    }
```



### 题目三：冒泡排序

相邻两个数之间比较交换

```java
    /**
     * 冒泡
     * @param arry
     */
    public static void popSort(int[] arry) {
        if (arry == null || arry.length < 2) {
            return;
        }
        int N = arry.length;
        // 0 ~ N - 1
        // 0 ~ end
        for (int end = N - 1; end > 0; end--) {
            // 0 ~ end 干一件事
            // 1 2 2 3 3 4
            for (int second = 1; second <= end; second++) {
                if (arry[second - 1] > arry[second]) {
                    convert(arry, second - 1, second);
                }
            }
        }
    }
```



### 题目四：插入排序

遍历数组，每个数都比对是否比前一个数小，如果小的话就换位置，继续向前比对，如果比前一个数大的话就停止比对。

相当于是从牌堆里面抓一张牌，从右往左找到合适的位置插入

每次遍历都要保证范围之间的有序

![image-20231203174310931](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20231203174310931.png) 



```java
    /**
     * 插入排序
     *
     * @param arry
     */
    public static void insertSort(int[] arry) {
        if (arry == null || arry.length < 2) {
            return;
        }
        // 0~0完成的数
        // 0~1
        // 0~2
        // 0~3
        // 0~n-1范围上有序
        int N = arry.length;
        for (int end = 1; end < N; end++) {
            // 当前数的位置
            int currentIdx = end;
            // 我当前数的位置前面有数   并且  当前这个位置的数左边的数，比我当前这个位置的数还要大，则进行位置的交换
            while (currentIdx - 1 >= 0 && arry[currentIdx - 1] > arry[currentIdx]) {
                // 当前位置左边的数和当前位置的数进行交换
                convert(arry, currentIdx - 1, currentIdx);
                // 然后往左移动
                currentIdx --;
                // 左边不在有数了，或者左边有数但是已经不大于你了，则跳出
            }
        }

    }
```



### 题目五：插入排序优化

```java
/**
     * 插入排序（优化）
     *
     * @param arry
     */
    public static void insertSortOptimize(int[] arry) {
        if (arry == null || arry.length < 2) {
            return;
        }
        // 0~0完成的数
        // 0~1
        // 0~2
        // 0~3
        // 0~n-1范围上有序
        int N = arry.length;
        for (int end = 1; end < N; end++) {
            // int pre = end -1;
            // pre就是我们现在处理的前一个数(新数的前一个位置)
            // 新数一开始就在end上所以新数前一个就是end - 1
            // pre >= 0
            // 如果前一个位置真的没有越界说明就是有前一个位置
//            arry[pre] > arry[pre + 1];
            // 而且前一个位置的数会大于新位置的数，arry[pre + 1]其实就是新位置的数现在在哪
            // 意思就是如果前一个位置的数会比后一个位置的数大，其实相当于当前的数就在pre + 1的位置，并且发现比pre位置还要小就交换。
            // pre --
            // 这样当前位置就来到的pre，所以就pre --，当前位置就继续往前
            for (int pre = end - 1; pre >= 0 && arry[pre] > arry[pre + 1]; pre--) {
                convert(arry, pre, pre + 1);
            }
        }
    }
```



## 前缀和数组、对数器和随机行为

### 什么叫数据结构

其实我们看到的数据结构在计算机里面的内存结构都是一块空间里面存放着值，并且存放了相对应的内存地址供他去指向。

任何数据结构都是由两种数据原件构成：

连续结构或者跳转结构，或者是跳转结构。

**数学概念为：线性、非线性**

1、数据结构是存储、组织数据的方式

2、精心选择的数据结构可以带来更高的运行或者存储效率

3、数据结构是很多算法得以进行的载体

![image-20231203225603963](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20231203225603963.png) 



### 最基本的数据结构



#### 题目一：

#### 查询数组位置中L位置到R位置的累加和，这个查询非常的频繁

![image-20231203230109937](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20231203230109937.png) 

**第一种设计：**

建立一个正方形表，左边的数加上自己就是，L~R的累加和。

![image-20231203230623505](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20231203230623505.png) 

L <= R的

这张表成立之后后续的查询就会非常快，直接从表里拿值就行。

这张表的空间复杂度为：S(T) = T(n^2/2)



**第二种数据结构：前缀和数**

建立一个help数组

![image-20231203231113405](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20231203231113405.png)

H[i] 代表的是arr一路从0累加到i的整体结构 

H[i]=arr[0...i]的累加和

例如我们要查 3~7之间的累加和sum(3~7)

H[7] = 0~7

H[2]=0~2

所以

H[3~7] = H[7]-H[2]

并且当L=0的时候直接就哪H[R]的累加和就行了

当L!=0的时候就等于H[R]-H[L-1]

**这两种方法各有各的优点，一般来说前缀和的方案比较好，但是并不是绝对的，因为如果查询非常频繁，可能百亿次，使用第一种方法更好，因为他是直接拿值返回给我们的，后续不需要进行任何运算。但是第二种的话还要减一下。**

**没有剂量，不谈毒性**

![image-20231203231855679](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20231203231855679.png) 

 

 



### 二分、复杂度、动态数组、哈希表和有序表



### 有序数组中找到num

```java
package com.msb.arith1;
/**
 * 有序数组中找到num
 * 二分法   数据都是有序的情况下
 * @author Karry
 * @date 2023-01-31  12:16
 */
public class Dichotomy {
    public static boolean find(int[] arr, int num) {
        if (arr == null || arr.length == 0) {
            return false;       
}
        //定义左边界
        int L = 0;
        int R = arr.length - 1;
        //arr[0...N-1]
        // 如果左边界比右边界大+就跳出循环
        while (L <= R) {
            int mid  = (L + R) / 2;
            if (arr[mid] == num) {
                return true;
                //当mid的值小于 num的时候我们不要左边界的数据了
                // 将L的值定义到mid + 1上  同理：右边界也一样
            } else if (arr[mid] < num) {
                L = mid + 1;
            } else if (arr[mid] > num) {
                R = mid - 1;           
}
        }
        return false;
    }
}
```





### 有序数组中找到=num最左的位置

例如：

[1,1,1,2,2,2,3,4,4,5,5,6]

 要找>=2的

![image-20230131193942785](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20230131193942785.png)



**使用二分法不一定要有序**





### 局部最小值问题



**一个数组无序，但是有条件就是任意两个相邻的数不相等。**



依然可以二分：

先拿两头来比喻

1.[0] < [1]  就可以直接证明 0位置的数最小

2.[N-2] > [N-1] 可以证明N-1位置的数是局部最小的，因为他们一个是左边的边界一个是右边的边界，只需要判断一遍就行了。

3.中间的话就需要    左 > [i] < 右  i位置的数才是最小的

思路：

如果0位置的数小于1位置的数，直接就返回0位置的数，如果不小的话就可以直接证明0位置的数大于1位置的数（因为条件中是不相等的），同理N-1位置的数也一样。**一开始下降最后上扬，中间必然存在局部最小**



这样0位置的数到1位置的数呈下降趋势，n-2~n-1位置的数呈上升

**左边的局部是下降，右边的局部是上扬，所以一定是存在局部最小的情况才可能上扬。**

![image-20230131202803674](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20230131202803674.png) 



 **当我们使用二分法用mid取中间值的时候，如果mid位置比他左边小，右边也小，那么我们也直接返回mid的位置就行了**

![image-20230131203044554](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20230131203044554.png) 



**如果上述情况不成立，如果mid不同时小于自己的左和自己的右，我们不妨设左边比他小，0~1位置的数是大于1位置的，他小局部是一个下降趋势，而mid-1~mid又是上扬的，那么结合上面两个条件，我们可以直接就可以断定0~mid之间必有局部最小，可以直接把右边砍掉。同理如果mid右边比他小，也一样**

![image-20230131203316394](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20230131203316394.png) 

先判断mid比不比左侧大，如果mid比左侧大我们直接不用管右边怎么样，直接砍掉找左边。如果mid没有比左边大，也一样

**第一版核心实现 + 对数器**

```java
package com.msb.arith1;

/**
 * 局部最小问题
 * 无序，但是任意两个相邻的数不相等
 * 例如:
 * 5位置的数一定不会4、6位置的数相等
 * 任意两个相邻的数一定不等
 * 虽然他是无序的，但是也可以使用二分法
 * 边界条件：
 * [0] < [1]  0为局部最小
 * [n-2] > [n-1]  n-1位置是局部最小
 * 左>[i]<右   这样i位置的数是局部最小
 */
public class LocalMinimum1 {


    /**
     * arr整体无序
     * arr相邻的数不相等！
     *
     * @param arr
     * @return
     */
    public static int onMinIndex(int[] arr) {
        // 如果只有一个数
        if (arr == null || arr.length == 0) {
            return -1;
        }

        // 一个数的时候默认0位置局部最小
        if (arr.length == 1) {
            return 0;
        }

        int N = arr.length;
        //====如果长度等于二，这两个if一定会返回===
        // 边界设置
        if (arr[0] < arr[1]) {
            return 0;
        }
        if (arr[N - 1] < arr[N - 2]) {
            return N - 1;
        }
        // =============
        // arr.length > 2
        int L = 0;
        int R = N - 1;
        int ans = -1;
        while (L <= R) {
            int mid = (L + R) / 2;
            //================旧写法====================
//            // 中间位置左右两边同时小
//            if (arr[mid] < arr[mid - 1] && arr[mid] < arr[mid] + 1) {
//                ans = mid;
//                break;
//            }
//            // 中间位置大于左边，那么直接放弃右边找左边的
//            if (arr[mid] > arr[mid - 1]) {
//                R = mid - 1;
//                continue;
//            }
//            // 中间位置大于右边，那么直接放弃左边找右边的
//            if (arr[mid] > arr[mid + 1]) {
//                L = mid + 1;
//                continue;
//            }
            // ========================================
            // 新写法

            // 中间位置左右两边同时小
            if (arr[mid] < arr[mid - 1] && arr[mid] < arr[mid] + 1) {
                ans = mid;
                break;
            } else {
                // 不同时小
                // 不同时小的情况有三种
                //  1.左 > mid mid < 右
                //  2.左 < mid mid < 右
                //  3.左 < mid mid > 右
                // 中间位置大于左边，那么直接放弃右边找左边的
                //  这个if的情况是2、3
                if (arr[mid] > arr[mid - 1]) {
                    R = mid - 1;
                } else {
                    //中间位置大于右边，那么直接放弃左边找右边的
                    //arr[mid] > arr[mid + 1] 一定大于
                    L = mid + 1;
                }
            }
        }
        return ans;
    }

    // 生成随机的数组,并且保证两个数之间要相邻不相等
    public static int[] randomArray(int maxLen, int maxValue) {
        int length = (int) (Math.random() * maxLen);
        int arr[] = new int[length];
        if (length > 0) {
            // 先把第一位的数随机出来
            arr[0] = (int) (Math.random() * maxValue);
            // 接下来从1位置的数开始生成，但是不能跟0位置的数一样
            for (int i = 1; i < length; i++) {
                do {
                    arr[i] = (int) (Math.random() * maxValue);
                    // 如果生成的数==前面那个数了，就重新生成，这样就能保证相邻不相等了
                } while (arr[i] == arr[i - 1]);
            }
        }
        return arr;
    }

    // 测试用
    public static boolean check(int[] arr, int minIndex) {
        // =0的情况局部最小返回的是-1
        if (arr.length == 0) {
            return minIndex == -1;
        }
        int left = minIndex - 1;
        int right = minIndex  + 1;
        // 如果生成的数组不越界，那就真的拿去比一下，如果越界了就可以认为他不破坏这个规则
        // 左边是否大于minIndex
        boolean leftBigger = left >= 0 ? arr[left] > arr[minIndex] : true;
        //                      如果是不越界真实的位置  并且右边的位置是否会大于局部最小位置
        boolean rightBigger = right < arr.length ? arr[right] > arr[minIndex] : true;
        return leftBigger && rightBigger;
    }

    public static void printArray(int[] arr) {
        for (int i : arr) {
            System.out.print(i + " ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        int maxLen = 10;
        int maxValue = 20;
        int testTime = 100000;
        System.out.println("测试开始");
        for (int i = 0; i < testTime; i++) {
            // 生成数组
            int[] arr = randomArray(maxLen, maxValue);
            int ans = onMinIndex(arr);
            boolean check = check(arr, ans);
            if (!check) {
                printArray(arr);
                System.out.println(ans);
                break;
            }
        }
        System.out.println("测试结束");
    }

}
```

执行结果为

![image-20240201132056711](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240201132056711.png) 

但是当我们将maxLen扩大的时候，发现会有下标数组越界的问题。

![image-20240201132137775](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240201132137775.png) 

问题是我们想要的是M-1位置和M+1位置还在L~R范围内，如果超过L~R了就会出现数组越界的问题。

 ![image-20240201132409399](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240201132409399.png) 



**会有一个问题，当二分到只剩两个了的时候，因为我们使用的条件都是mid左边和mid右边，如果只剩两个的时候会造成某一边没数据，导致数组下标越界，所以我们需要保证当只剩两位的时候直接比较这两位就行了，所以要限制这个数组三个数或三个数以上再判断**

解决的方式就是让L < R-1，限定一下L~R是三个数或者三个数以上在让他二分，如果不够三个数的话我们就单独验证这两个数谁是最小值返回。

修改过后的代码：

```java
    /**
     * arr整体无序
     * arr相邻的数不相等！
     * 解决数组越界问题
     * @param arr
     * @return
     */
    public static int onMinIndexAnswer(int[] arr) {
        // 如果只有一个数
        if (arr == null || arr.length == 0) {
            return -1;
        }

        // 一个数的时候默认0位置局部最小
        if (arr.length == 1) {
            return 0;
        }

        int N = arr.length;
        //====如果长度等于二，这两个if一定会返回===
        // 边界设置
        if (arr[0] < arr[1]) {
            return 0;
        }
        if (arr[N - 1] < arr[N - 2]) {
            return N - 1;
        }
        // =============
        // arr.length > 2
        int L = 0;
        int R = N - 1;
        while (L < R - 1) {
            int mid = (L + R) / 2;
            // 中间位置左右两边同时小
            if (arr[mid] < arr[mid - 1] && arr[mid] < arr[mid + 1]) {
               return mid;
            } else {
                if (arr[mid] > arr[mid - 1]) {
                    R = mid - 1;
                } else {
                    //中间位置大于右边，那么直接放弃左边找右边的
                    //arr[mid] > arr[mid + 1] 一定大于
                    L = mid + 1;
                }
            }
        }
        return arr[L] < arr[R] ? L : R;
    }
```



造成前面那版问题数组例子：[3,2,3,2,3]

![image-20230131210803135](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20230131210803135.png) 

![image-20240202152329741](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240202152329741.png) 



**二分不一定要有序，要再某一个规定下，比如：确定某一侧一定有就可以用二分法**



### 什么是常数操作



**等差数列求和公式**

 ![image-20240202152605744](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240202152605744.png)



#### **时间复杂度**

他是用来描述到底发生了几次常数操作的一个指标。

**常数操作就是他跟数据量没有关系，他就是固定时间的。**

**比如：int 1+1，int 100w + 100w这两个都是32位的整数这两个经历的过程是一样的。**

+、-、*、/、数组寻址等等都是常数操作，都是固定时间的。

当我们调用某一个语句的时候，他可能有些传参，调用的这一段语句是固定时间能完的，还是他是跟数据量有关的。如果他是跟数据量有关的语句他就不是一个常数操作，如果是跟数据量无关的操作他就是一个固定时间的操作。



### 什么是时间复杂度

以冒泡排序为例子：

![image-20240202153617056](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240202153617056.png) 

0-1之间谁大谁交换，我们先把这个时间设置为a操作，a是固定时间，后面的1-2，2-3.....这些都可以是常数操作，一共进行了7次交换。

![image-20240202153725245](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240202153725245.png) 

后续以此类推：7次、6次、5次......相当于是一个等差数列



### 等差数列求和公式

![image-20240202154006474](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240202154006474.png)

整个表达式中最高阶的东西就是他的时间复杂度。 

![image-20240202155653969](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240202155653969.png)

所以说冒泡排序就是复杂度为O(n^2)的算法。

复杂度不关心低阶项也不关心系数，他只关心最高阶是什么，这就叫做时间复杂度。



**为什么把时间复杂度做得怎么模糊呢**？

原因在于他就关心最高阶，当他的数据量很大的时候算法运行过程中的关系。



不管常数项多大，算法1的时间复杂度都是最高的

![image-20240202160056041](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240202160056041.png) 

不要系数，不要低阶项，因为如果n趋近于无穷，那么所有低阶项都变得不重要了，所以O(n)的算法就是比O(n^2)的算法好。

**决定这个算法运行时间的就是最高阶项的系数**。

所以时间复杂度是一个指标，他在于数据量很大的情况下，该怎么去描述算法时间之间的关系。



**二分的时间复杂度为：O(log2N),他会比O(N)低很多**



时间复杂度的概述图

![image-20240202160733742](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240202160733742.png) 

O(log2N)往往会忽略这个底，因为他比2大或者等于2，他出来的结果往往都会很小，所以可以忽略不计，后面默认都会写成O(logN)

常数:O(1)

估计时间复杂度用的都是最差的情况，要用怎么让这个流程最难受的情况来估计整个流程，假设最差情况。

![image-20240202161428729](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240202161428729.png)







### 什么是动态数组

规定长度之后不能再变的数组叫固定数组。

Java中的ArrayList就是动态数组。



### 动态数组使用和扩容

原来固定长度的时候，找到index位置的数的时间复杂度为O(1)固定时间的。



但是现在在ArrayList里面找index的数，这个行为中包含了另外一个行为就是扩容，扩容行为是否会影响ArrayList整体的表现？

当加入N个数的时候扩容行为的总代价是什么？（把数组扩容）

![image-20240219160408842](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240219160408842.png) 

扩容的过程为：1-2-4-8-16...-N

扩容代价为：1+2+4+8+16+...+N，这是一个等比数列，可以得出扩容的总代价为O(N)

加入N个数的时候代价为O(N)，那加入N个数的时候就是O(N)/N，均摊下来扩容代价到了某一步之后就变成了O(1)的一件小事。

所以总结：动态数组虽然有扩容，但是其实对于他的整体性能在时间复杂度的影响上是没有的，他做到了跟固定数组一样好还能支持动态扩容。但是并不是说他比固定数组就好，因为ArrayList当然会比固定数组要慢，但是这种慢只是常数时间的慢，从复杂度的角度来说的话是没有影响的。

所以从时间复杂度的角度上来说ArrayList和正常的固定数组一样还支持扩容，因为他的常数时间会比单纯的固定数组差一点，但是他只是不影响时间复杂度的差，在工程上我们几乎感觉不到。



### 哈希表和有序表的使用

在hash表中原生类型内部要值传递，非基础原生类型内部按照引用（内存地址作为key）传递。

以金庸为key他的所有作品为value，放到HashMap里面，问这条记录占用Hash表的字节数是多少

![image-20240219161643247](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240219161643247.png) 

答：金庸两个字的字节数+他所有作品的字节数



问HashMap里面的key和value都是Node对象，Key的Node里面放了个str为金庸，value的Node里面也有个str放了作品内容，问这个Hash表里面占用的字节数是多少

![image-20240219161754143](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240219161754143.png)

答：在hash表中他不会吧所有的字节都拷贝到hash表里面去，对于hash表来说你如果不是按值传递的，他在hash表空间占用的时候只是一个地址，所以两个node塞进去的话就是一个地址8字节、一个地址8字节，hash表的占用为16字节，不管你node占用多大，在hash表中就占用那么多。

![image-20240219162312778](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240219162312778.png) 





TreeMap<Integer,String>里面跟hash表一样，也是按值传递的。

但是他里面也很多工具方法。对于treeMap来说，内部会按照key排好序。

![image-20240219162455441](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240219162455441.png)

我们可以认为TreeMap上面的这些方法他的时间复杂度都是O(logN)级别的



如果是Node类型的呢？

有序表就不能直接用了，会报错，因为我们要求key一定要是可以比较的，如果不能比较是不被允许的。

![image-20240219162708201](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240219162708201.png)

如果你要自己定义接口的话，就需要自己去定义如何比较，不然用不了有序表。





## 单链表及其简单题目



### 介绍单链表和双链表

![image-20240219171709294](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240219171709294.png) 

### 单链表的反转

下面是一条链表，所谓的反转就是把指针全部都逆序了。

![image-20240219172137032](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240219172137032.png)



会有一个问题，当链表逆序之后，head引用要是还是指向a的话，后面的b,c,d都会不见，所以在这个情况下jvm会把这个链表给释放掉，因为没有任何引用去找到bcd。

![image-20240219172409513](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240219172409513.png)



所以我们需要写一个f()把头传进去Head = f(head)，我们在写这个函数的时候一定要写一个返回值，让这个头的值被使用，不然这个链表就会被当成垃圾回收。



任何一个引用都找不到剩下的空间，JVM会把它们认为是无用的，直接释放。**根可达**

![image-20240219172948264](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240219172948264.png)

单链表逆序代码

```java
public class RevertList {

    public static class Node {
        public int value;
        public Node next;

        public Node(int value) {
            this.value = value;
        }
    }
    
     /**
     * 单链表反转
     */
    public static Node reverseLinkedList(Node head) {

        Node pre = null;
        Node next = null;
        while (head != null) {

            next = head.next;
            head.next = pre;
            pre = head;
            head = next;
        }
        return pre;
    }
    public static void main(String[] args) {
        Node n1 = new Node(1);
        n1.next = new Node(2);
        n1.next.next = new Node(3);
        // 返回Head头部
        n1 = reverseLinkedList(n1);
        while (n1 != null) {
            System.out.print(n1.value + " ");
            n1 = n1.next;
        }
        System.out.println();
    }
 }
```



![image-20240219222312675](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240219222312675.png) 



### 双链表的反转

题目

![image-20240220130905419](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240220130905419.png) 



反转的结果：

![image-20240220131005368](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240220131005368.png)



双向链表的反转过程

![1](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/1.jpg) 

![2](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/2.jpg) 

![3](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/3.jpg) 

双向链表反转代码：

```java
public class RevertList {
   public static class DoubleNode {
        public int value;

        public DoubleNode last;

        public DoubleNode next;

        public DoubleNode(int value) {
            this.value = value;
        }
    }
   /**
     *  1-2-3-4-null
     *  1~2~3~4~null
     */
    /**
     * 双链表反转
     * @param head
     * @return
     */
    public static DoubleNode reverseDoubleLinkedList(DoubleNode head) {
        DoubleNode next = null;
        DoubleNode pre = null;
        while (head != null) {
            // 先把头的next节点记住
            next = head.next;
            head.next = pre;
            // 原先的last要反转指向next
            head.last = next;
            pre = head;
            head = next;
        }
        return pre;
    }
 }
```



### 用单链表结构实现队列

队列的话就是像排队一样先进先出，栈的话就像弹夹一样先进后出。

#### 队列

第一次插入

![image-20240220213629005](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240220213629005.png)

![image-20240220213859911](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240220213859911.png) 

**每加一个数都往尾巴加值，保证从head出发都可达**

![image-20240220215325926](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240220215325926.png) 



当所有的值都弹出之后，要让h和tail保持一致都为Null

![image-20240220215509718](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240220215509718.png) 



```java
package com.msb.arith2;

public class LinkedListToQueueAndStack {

    public static class Node<V> {

        public V value;
        public Node<V> next;

        public Node(V value) {
            this.value = value;
        }
    }

    public static class MyQueue<V> {
        private Node<V> head;
        private Node<V> tail;
        private int size;

        public MyQueue() {
            head = null;
            tail = null;
            size = 0;
        }

        public boolean isEmpty() {
            return size == 0;
        }

        public int size() {
            return size;
        }

        /**
         * 添加节点
         * @param value
         */
        public void offer(V value) {
            // 保证值一进来就先建出来一个节点
            Node<V> cur = new Node<V>(value);
            if (tail == null) {
                head = cur;
                tail = cur;
            } else {
                // 尾巴的next指针指向当前节点
                tail.next = cur;
                // 尾巴跳到当前节点位置
                tail = cur;
            }
            size ++;
        }

        /**
         * 弹出节点
         * @return
         */
        public V poll() {
            V ans = null;
            if (head != null) {
                // 从头开始弹出，先进先出的原理
                ans = head.value;
                head = head.next;
                size --;
            }
            // 当所有的值都弹出之后，要让h和tail保持一致都为Null
            if (head == null) {
                // 如果不这样释放，tail指向最后一个数，而h指向null，那这个tail就不会被释放，就是一个脏数据
                tail = null;
            }
            return ans;
        }

        public V peek() {
            V ans = null;
            if (head != null) {
                ans = head.value;
            }
            return ans;
        }

    }

}
```



#### 栈

压栈

![image-20240220221048333](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240220221048333.png)

弹出 

![image-20240220221158697](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240220221158697.png)



```java
public static class MyStack<V> {
        private Node<V> head;
        private int size;

        MyStack() {
            head = null;
            size = 0;
        }

        public boolean isEmpty() {
            return size == 0;
        }

        public int size() {
            return size;
        }

        public void push(V value) {
            Node<V> cur = new Node<>(value);
            if (head == null) {
                head = cur;
            } else {
                cur.next = head;
                head = cur;
            }
            size ++;
        }

        public V pop() {
            V ans = null;
            if (head != null) {
                ans = head.value;
                head = head.next;
                size --;
            }
            return ans;
        }

        public V peek() {
            return head != null ? head.value : null;
        }
    }
```





### 用双链表结构实现双端队列

可以头部加数据，头部出数据，也可以尾部加数据尾部出数据。

**![image-20240221130826911](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240221130826911.png) **



**单链表只支持头部加头部出，不支持尾部出，因为这样从尾部弹出的话会找不到之前的值。**

![image-20240221131038755](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240221131038755.png) 

代码示例：

```java
package com.msb.arith2;

/**
 * 双端链表队列
 */
public class DoubleLinkedListToDeque {

    public static class Node<V> {
        public V value;
        public Node<V> last;
        public Node<V> next;
        public Node(V v) {
            value = v;
            last = null;
            next = null;
        }
    }

    public static class MyDeque<V> {
        private Node<V> head;
        private Node<V> tail;
        private  int size;

        public MyDeque() {
            head = null;
            tail = null;
            size = 0;
        }

        public boolean isEmpty() {
            return size == 0;
        }

        public int size() {
            return size;
        }

        /**
         * 从头部加
         * @param value
         */
        public void pushHead(V value) {
            //当前节点
            Node<V> cur = new Node<V>(value);
            if (head == null) {
                head = cur;
                tail = cur;
            } else {
                // 新进来的next指针指向head
                cur.next = head;
                // 老的head的上一个节点last指针指向新进来的节点
                head.last = cur;
                // 因为cur的last指针没设置，那就默认指向Null
                // 头调到当前节点上去
                head = cur;
            }
            size ++;
        }

        /**
         * 尾巴加入
         * @param value
         */
        public void pushTail(V value) {
            //当前节点
            Node<V> cur = new Node<V>(value);
            if (head == null) {
                head = cur;
                tail = cur;
            } else {
                tail.next = cur;
                cur.last = tail;
                tail = cur;
            }
            size ++;
        }
    }
}

```





### K个节点的组内逆序调整

一个单向链表，给你一个k值如果是3，请把这个链表按照三个三个分组，不足3个的不管他，然后每组给他逆序调整

比如:

1-2-3-4-5-6-7-8

123一组456一组 78 不管他结果应该为

3-2-1-6-5-4-7-8这样的链式结构

![image-20240222192347369](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240222192347369.png)



**给定链表的开始节点，数到第k位把第k位的数据返回。**

```java
public static ListNode getGroupEnd(ListNode start, int k) {
                        // --k调到null就没有值了
        while (--k !=0 && start != null) {
            start = start.next;
        }
        return start;
    }
```

![image-20240223131030455](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240223131030455.png)

start != null

![image-20240223131205446](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240223131205446.png)

reverse函数功能为

![image-20240223131525600](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240223131525600.png)

先把s的next指针指向null，然后其他的指针除了k以外统一都往回指，并且在e往回值之前先把k的位置记住

![image-20240223131643000](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240223131643000.png) 

再让s的next指针指向k

![image-20240223131702444](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240223131702444.png) 





为什么要让end先往前一步，是因为当完成了开始和结束之后要把连表反过来指向。
// a-b-c-d-f ， 要把abcd反过来，要让a指向f这个工作，所以才要记这个位置。

因为到了e才停，而abcd这几个都是要干事的

1、

![image-20240225131017849](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240225131017849.png)

2、

![image-20240225131735156](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240225131735156.png)

3、

![image-20240225131753152](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240225131753152.png)



![image-20240225131806970](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240225131806970.png)

相关实现代码：

```java
package com.msb.arith2;

/**
 * K个节点的组内逆序调整
 * 一个单向链表，给你一个k值如果是3，请把这个链表按照三个三个分组，不足3个的不管他，然后每组给他逆序调整
 * 比如:
 * 1-2-3-4-5-6-7-8
 * 123一组456一组 78 不管他结果应该为
 * 3-2-1-6-5-4-7-8这样的链式结构
 */
public class ReverseNodesInKGroup {
    public static class ListNode {
        private ListNode next;
        private int size;

        public ListNode(ListNode next) {
            this.next = next;
        }
    }
    /**
     * 给定链表的开始节点，数到第k位把第k位的数据返回。
     * @param start
     * @param k
     * @return
     */
    public static ListNode getGroupEnd(ListNode start, int k) {
                        // --k调到null就没有值了
        while (--k !=0 && start != null) {
            start = start.next;
        }
        return start;
    }
    public static void reverse(ListNode start, ListNode end) {
        // 这里为什么要让他指向下一个节点是因为当完成了开始和结束之后要把连表反过来指向。
        // a-b-c-d-f // 要把abcd反过来，要让a指向f这个工作，所以才要记这个位置。
        end = end.next;
        ListNode pre = null;
        ListNode cur = start;
        ListNode next = null;
        while (cur != end) {
            next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        start.next = end;
    }
}
```













































































































































































## 算法资料

算法课资料、规划、代码：
1，打开链接：https://cloud.fynote.com/share/s/7615

2，上面链接是所有课程介绍，打开“马士兵教育算法系列课程”，找到“通过世界上任何大厂算法面试扎实路线”，是学习路线。

3，课上所有代码：https://github.com/algorithmzuo

4，课上所有ppt文字合集、算法知识脉络及其脑图：https://github.com/algorithmzuo/class-notes

5，如果你不能翻墙，无法打开github，如下是马士兵代码平台算法课所有代码：https://git.mashibing.com/msb_14613/algorithm-class

6，每周算法直播课链接：https://www.mashibing.com/live/1240

根据1打开链接。可以熟悉整套课程，资料非常全：课程介绍、每节课梗概、讲述题目汇总、所有代码实现、知识脑图、学习路线，详细笔记全部都有，先熟悉一下。

接下来是规划路线。

==============

如果你的准备时间超过7个月，按照最稳妥的路线学习：

根据1和2打开，可以看到课程简介、学习顺序，因为你有时间掌握所有的课，所以我就推荐按顺序全看全练。

一周看课和练习一共投入12小时的话，整套课程6-7个月可拿下所有的850+题。即便进度慢，也可拿下600题，面大厂很稳。

==============

如果你准备时间不够7个月，可以按照高频内容先看的路线：

1. 新手班只看链表题目、二叉树题目题目

1）体系学习班，章节1~27全部，章节39～40只看有关“根据数据量猜解法”的部分。

2）大厂刷题班，章节28~38，打开资料里对应这门课的代码，找到class28～class38，每一个目录里都有“说明”，把说明文件看一下。详细列出了leetcode高频题目列表。

3）大厂刷题班，章节1~27

4）体系学习班，章节28~48，跳过四边形不等式、DC3算法的内容

5）大厂刷题班其他所有内容、每周直播课

==============

最后是学习注意点如下

不需要自己找题刷！我就推荐看课！只需要刷课上的题！因为课上覆盖了大厂需要的几乎所有题。题目总数850多个，其中包含600多的leetcode原题。几乎没有简单题，都是leetcode上最值得练的题，以及大厂真实面试题，已经为你选好了。当你想试试自己的学习状态，你可以每周三晚8点来参加算法直播课，都是大厂最新考的、不重复的算法题。

看课的时候，对每一个内容，看懂课上解析+自己独立写出来。每看懂一个题，就写总结笔记，可以只写你自己能看懂的话，但是要求笔记能帮你回忆起算法大概的流程，能在脑海中勾勒code怎么组织。这样的笔记对你复习很重要，复习就不需要看视频了，想不起来再翻视频。不要频繁复习！因为后面的题会把之前学过的内容反复练习，整套课自带复习效果。看懂+自己写出+笔记，持续推进即可。

===============

仔细阅读上面发的所有资料和提醒。

然后开始看课，练题。

过程中任何困惑求解答、debug不出错误、见到新的算法面试题目不会做。都可以官网发帖，或者通过班主任拉群联系到我。



