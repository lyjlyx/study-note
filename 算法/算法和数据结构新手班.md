# 算法和数据结构新手班



## 什么是算法

1、有具体的问题

2、有设计解决这个问题的具体流程

3、有评价处理流程的可量化指标



## 算法的分类

分类非常之多

算法不挑语言



## 简单的功能代码



### 题目一：阶乘

![image-20220819131038419](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220819131038419.png) 

当前阶乘的结果是上一步阶乘的结果乘以自己这一步。

时间复杂度、空间复杂度。



交换器

```JAVA
public static void convert(int[] arry, int i, int j) {
  int tmp = arry[i];
  arry[i] = arry[j];
  arry[j] = tmp;
}
```



### 题目二：选择排序

从小到大排序

每次找到最小值放到前面往后移动，直到全部排好

```java
    /**
     * 选择
     * @param arry
     */
    public static void selectSort(int[] arry) {
        if (arry.length < 2) {
            return;
        }
        int N = arry.length;
        for (int i = 0; i < N; i++) {
            int minIndex = i;
            for (int j = i + 1; j < N; j++) {
                minIndex = arry[minIndex] < arry[j] ? minIndex : j;
            }
            convert(arry, i, minIndex);
        }
    }
```



### 题目三：冒泡排序

相邻两个数之间比较交换

```java
    /**
     * 冒泡
     * @param arry
     */
    public static void popSort(int[] arry) {
        if (arry == null || arry.length < 2) {
            return;
        }
        int N = arry.length;
        // 0 ~ N - 1
        // 0 ~ end
        for (int end = N - 1; end > 0; end--) {
            // 0 ~ end 干一件事
            // 1 2 2 3 3 4
            for (int second = 1; second <= end; second++) {
                if (arry[second - 1] > arry[second]) {
                    convert(arry, second - 1, second);
                }
            }
        }
    }
```



### 题目四：插入排序

遍历数组，每个数都比对是否比前一个数小，如果小的话就换位置，继续向前比对，如果比前一个数大的话就停止比对。

相当于是从牌堆里面抓一张牌，从右往左找到合适的位置插入

每次遍历都要保证范围之间的有序

![image-20231203174310931](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20231203174310931.png) 



```java
    /**
     * 插入排序
     *
     * @param arry
     */
    public static void insertSort(int[] arry) {
        if (arry == null || arry.length < 2) {
            return;
        }
        // 0~0完成的数
        // 0~1
        // 0~2
        // 0~3
        // 0~n-1范围上有序
        int N = arry.length;
        for (int end = 1; end < N; end++) {
            // 当前数的位置
            int currentIdx = end;
            // 我当前数的位置前面有数   并且  当前这个位置的数左边的数，比我当前这个位置的数还要大，则进行位置的交换
            while (currentIdx - 1 >= 0 && arry[currentIdx - 1] > arry[currentIdx]) {
                // 当前位置左边的数和当前位置的数进行交换
                convert(arry, currentIdx - 1, currentIdx);
                // 然后往左移动
                currentIdx --;
                // 左边不在有数了，或者左边有数但是已经不大于你了，则跳出
            }
        }

    }
```



### 题目五：插入排序优化

```java
/**
     * 插入排序（优化）
     *
     * @param arry
     */
    public static void insertSortOptimize(int[] arry) {
        if (arry == null || arry.length < 2) {
            return;
        }
        // 0~0完成的数
        // 0~1
        // 0~2
        // 0~3
        // 0~n-1范围上有序
        int N = arry.length;
        for (int end = 1; end < N; end++) {
            // int pre = end -1;
            // pre就是我们现在处理的前一个数(新数的前一个位置)
            // 新数一开始就在end上所以新数前一个就是end - 1
            // pre >= 0
            // 如果前一个位置真的没有越界说明就是有前一个位置
//            arry[pre] > arry[pre + 1];
            // 而且前一个位置的数会大于新位置的数，arry[pre + 1]其实就是新位置的数现在在哪
            // 意思就是如果前一个位置的数会比后一个位置的数大，其实相当于当前的数就在pre + 1的位置，并且发现比pre位置还要小就交换。
            // pre --
            // 这样当前位置就来到的pre，所以就pre --，当前位置就继续往前
            for (int pre = end - 1; pre >= 0 && arry[pre] > arry[pre + 1]; pre--) {
                convert(arry, pre, pre + 1);
            }
        }
    }
```



## 前缀和数组、对数器和随机行为

### 什么叫数据结构

其实我们看到的数据结构在计算机里面的内存结构都是一块空间里面存放着值，并且存放了相对应的内存地址供他去指向。

任何数据结构都是由两种数据原件构成：

连续结构或者跳转结构，或者是跳转结构。

**数学概念为：线性、非线性**

1、数据结构是存储、组织数据的方式

2、精心选择的数据结构可以带来更高的运行或者存储效率

3、数据结构是很多算法得以进行的载体

![image-20231203225603963](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20231203225603963.png) 



### 最基本的数据结构



#### 题目一：

#### 查询数组位置中L位置到R位置的累加和，这个查询非常的频繁

![image-20231203230109937](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20231203230109937.png) 

**第一种设计：**

建立一个正方形表，左边的数加上自己就是，L~R的累加和。

![image-20231203230623505](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20231203230623505.png) 

L <= R的

这张表成立之后后续的查询就会非常快，直接从表里拿值就行。

这张表的空间复杂度为：S(T) = T(n^2/2)



**第二种数据结构：前缀和数**

建立一个help数组

![image-20231203231113405](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20231203231113405.png)

H[i] 代表的是arr一路从0累加到i的整体结构 

H[i]=arr[0...i]的累加和

例如我们要查 3~7之间的累加和sum(3~7)

H[7] = 0~7

H[2]=0~2

所以

H[3~7] = H[7]-H[2]

并且当L=0的时候直接就哪H[R]的累加和就行了

当L!=0的时候就等于H[R]-H[L-1]

**这两种方法各有各的优点，一般来说前缀和的方案比较好，但是并不是绝对的，因为如果查询非常频繁，可能百亿次，使用第一种方法更好，因为他是直接拿值返回给我们的，后续不需要进行任何运算。但是第二种的话还要减一下。**

**没有剂量，不谈毒性**

![image-20231203231855679](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20231203231855679.png) 

 

 



### 二分、复杂度、动态数组、哈希表和有序表



### 有序数组中找到num

```java
package com.msb.arith1;
/**
 * 有序数组中找到num
 * 二分法   数据都是有序的情况下
 * @author Karry
 * @date 2023-01-31  12:16
 */
public class Dichotomy {
    public static boolean find(int[] arr, int num) {
        if (arr == null || arr.length == 0) {
            return false;       
}
        //定义左边界
        int L = 0;
        int R = arr.length - 1;
        //arr[0...N-1]
        // 如果左边界比右边界大+就跳出循环
        while (L <= R) {
            int mid  = (L + R) / 2;
            if (arr[mid] == num) {
                return true;
                //当mid的值小于 num的时候我们不要左边界的数据了
                // 将L的值定义到mid + 1上  同理：右边界也一样
            } else if (arr[mid] < num) {
                L = mid + 1;
            } else if (arr[mid] > num) {
                R = mid - 1;           
}
        }
        return false;
    }
}
```





### 有序数组中找到=num最左的位置

例如：

[1,1,1,2,2,2,3,4,4,5,5,6]

 要找>=2的

![image-20230131193942785](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20230131193942785.png)



**使用二分法不一定要有序**





### 局部最小值问题



**一个数组无序，但是有条件就是任意两个相邻的数不相等。**



依然可以二分：

先拿两头来比喻

1.[0] < [1]  就可以直接证明 0位置的数最小

2.[N-2] > [N-1] 可以证明N-1位置的数是局部最小的，因为他们一个是左边的边界一个是右边的边界，只需要判断一遍就行了。

3.中间的话就需要    左 > [i] < 右  i位置的数才是最小的

思路：

如果0位置的数小于1位置的数，直接就返回0位置的数，如果不小的话就可以直接证明0位置的数大于1位置的数（因为条件中是不相等的），同理N-1位置的数也一样。**一开始下降最后上扬，中间必然存在局部最小**



这样0位置的数到1位置的数呈下降趋势，n-2~n-1位置的数呈上升

**左边的局部是下降，右边的局部是上扬，所以一定是存在局部最小的情况才可能上扬。**

![image-20230131202803674](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20230131202803674.png) 



 **当我们使用二分法用mid取中间值的时候，如果mid位置比他左边小，右边也小，那么我们也直接返回mid的位置就行了**

![image-20230131203044554](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20230131203044554.png) 



**如果上述情况不成立，如果mid不同时小于自己的左和自己的右，我们不妨设左边比他小，0~1位置的数是大于1位置的，他小局部是一个下降趋势，而mid-1~mid又是上扬的，那么结合上面两个条件，我们可以直接就可以断定0~mid之间必有局部最小，可以直接把右边砍掉。同理如果mid右边比他小，也一样**

![image-20230131203316394](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20230131203316394.png) 

先判断mid比不比左侧大，如果mid比左侧大我们直接不用管右边怎么样，直接砍掉找左边。如果mid没有比左边大，也一样

**第一版核心实现 + 对数器**

```java
package com.msb.arith1;

/**
 * 局部最小问题
 * 无序，但是任意两个相邻的数不相等
 * 例如:
 * 5位置的数一定不会4、6位置的数相等
 * 任意两个相邻的数一定不等
 * 虽然他是无序的，但是也可以使用二分法
 * 边界条件：
 * [0] < [1]  0为局部最小
 * [n-2] > [n-1]  n-1位置是局部最小
 * 左>[i]<右   这样i位置的数是局部最小
 */
public class LocalMinimum1 {


    /**
     * arr整体无序
     * arr相邻的数不相等！
     *
     * @param arr
     * @return
     */
    public static int onMinIndex(int[] arr) {
        // 如果只有一个数
        if (arr == null || arr.length == 0) {
            return -1;
        }

        // 一个数的时候默认0位置局部最小
        if (arr.length == 1) {
            return 0;
        }

        int N = arr.length;
        //====如果长度等于二，这两个if一定会返回===
        // 边界设置
        if (arr[0] < arr[1]) {
            return 0;
        }
        if (arr[N - 1] < arr[N - 2]) {
            return N - 1;
        }
        // =============
        // arr.length > 2
        int L = 0;
        int R = N - 1;
        int ans = -1;
        while (L <= R) {
            int mid = (L + R) / 2;
            //================旧写法====================
//            // 中间位置左右两边同时小
//            if (arr[mid] < arr[mid - 1] && arr[mid] < arr[mid] + 1) {
//                ans = mid;
//                break;
//            }
//            // 中间位置大于左边，那么直接放弃右边找左边的
//            if (arr[mid] > arr[mid - 1]) {
//                R = mid - 1;
//                continue;
//            }
//            // 中间位置大于右边，那么直接放弃左边找右边的
//            if (arr[mid] > arr[mid + 1]) {
//                L = mid + 1;
//                continue;
//            }
            // ========================================
            // 新写法

            // 中间位置左右两边同时小
            if (arr[mid] < arr[mid - 1] && arr[mid] < arr[mid] + 1) {
                ans = mid;
                break;
            } else {
                // 不同时小
                // 不同时小的情况有三种
                //  1.左 > mid mid < 右
                //  2.左 < mid mid < 右
                //  3.左 < mid mid > 右
                // 中间位置大于左边，那么直接放弃右边找左边的
                //  这个if的情况是2、3
                if (arr[mid] > arr[mid - 1]) {
                    R = mid - 1;
                } else {
                    //中间位置大于右边，那么直接放弃左边找右边的
                    //arr[mid] > arr[mid + 1] 一定大于
                    L = mid + 1;
                }
            }
        }
        return ans;
    }

    // 生成随机的数组,并且保证两个数之间要相邻不相等
    public static int[] randomArray(int maxLen, int maxValue) {
        int length = (int) (Math.random() * maxLen);
        int arr[] = new int[length];
        if (length > 0) {
            // 先把第一位的数随机出来
            arr[0] = (int) (Math.random() * maxValue);
            // 接下来从1位置的数开始生成，但是不能跟0位置的数一样
            for (int i = 1; i < length; i++) {
                do {
                    arr[i] = (int) (Math.random() * maxValue);
                    // 如果生成的数==前面那个数了，就重新生成，这样就能保证相邻不相等了
                } while (arr[i] == arr[i - 1]);
            }
        }
        return arr;
    }

    // 测试用
    public static boolean check(int[] arr, int minIndex) {
        // =0的情况局部最小返回的是-1
        if (arr.length == 0) {
            return minIndex == -1;
        }
        int left = minIndex - 1;
        int right = minIndex  + 1;
        // 如果生成的数组不越界，那就真的拿去比一下，如果越界了就可以认为他不破坏这个规则
        // 左边是否大于minIndex
        boolean leftBigger = left >= 0 ? arr[left] > arr[minIndex] : true;
        //                      如果是不越界真实的位置  并且右边的位置是否会大于局部最小位置
        boolean rightBigger = right < arr.length ? arr[right] > arr[minIndex] : true;
        return leftBigger && rightBigger;
    }

    public static void printArray(int[] arr) {
        for (int i : arr) {
            System.out.print(i + " ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        int maxLen = 10;
        int maxValue = 20;
        int testTime = 100000;
        System.out.println("测试开始");
        for (int i = 0; i < testTime; i++) {
            // 生成数组
            int[] arr = randomArray(maxLen, maxValue);
            int ans = onMinIndex(arr);
            boolean check = check(arr, ans);
            if (!check) {
                printArray(arr);
                System.out.println(ans);
                break;
            }
        }
        System.out.println("测试结束");
    }

}
```

执行结果为

![image-20240201132056711](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240201132056711.png) 

但是当我们将maxLen扩大的时候，发现会有下标数组越界的问题。

![image-20240201132137775](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240201132137775.png) 

问题是我们想要的是M-1位置和M+1位置还在L~R范围内，如果超过L~R了就会出现数组越界的问题。

 ![image-20240201132409399](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240201132409399.png) 



**会有一个问题，当二分到只剩两个了的时候，因为我们使用的条件都是mid左边和mid右边，如果只剩两个的时候会造成某一边没数据，导致数组下标越界，所以我们需要保证当只剩两位的时候直接比较这两位就行了，所以要限制这个数组三个数或三个数以上再判断**

解决的方式就是让L < R-1，限定一下L~R是三个数或者三个数以上在让他二分，如果不够三个数的话我们就单独验证这两个数谁是最小值返回。

修改过后的代码：

```java
    /**
     * arr整体无序
     * arr相邻的数不相等！
     * 解决数组越界问题
     * @param arr
     * @return
     */
    public static int onMinIndexAnswer(int[] arr) {
        // 如果只有一个数
        if (arr == null || arr.length == 0) {
            return -1;
        }

        // 一个数的时候默认0位置局部最小
        if (arr.length == 1) {
            return 0;
        }

        int N = arr.length;
        //====如果长度等于二，这两个if一定会返回===
        // 边界设置
        if (arr[0] < arr[1]) {
            return 0;
        }
        if (arr[N - 1] < arr[N - 2]) {
            return N - 1;
        }
        // =============
        // arr.length > 2
        int L = 0;
        int R = N - 1;
        while (L < R - 1) {
            int mid = (L + R) / 2;
            // 中间位置左右两边同时小
            if (arr[mid] < arr[mid - 1] && arr[mid] < arr[mid + 1]) {
               return mid;
            } else {
                if (arr[mid] > arr[mid - 1]) {
                    R = mid - 1;
                } else {
                    //中间位置大于右边，那么直接放弃左边找右边的
                    //arr[mid] > arr[mid + 1] 一定大于
                    L = mid + 1;
                }
            }
        }
        return arr[L] < arr[R] ? L : R;
    }
```



造成前面那版问题数组例子：[3,2,3,2,3]

![image-20230131210803135](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20230131210803135.png) 

![image-20240202152329741](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240202152329741.png) 



**二分不一定要有序，要再某一个规定下，比如：确定某一侧一定有就可以用二分法**



### 什么是常数操作



**等差数列求和公式**

 ![image-20240202152605744](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240202152605744.png)



#### **时间复杂度**

他是用来描述到底发生了几次常数操作的一个指标。

**常数操作就是他跟数据量没有关系，他就是固定时间的。**

**比如：int 1+1，int 100w + 100w这两个都是32位的整数这两个经历的过程是一样的。**

+、-、*、/、数组寻址等等都是常数操作，都是固定时间的。

当我们调用某一个语句的时候，他可能有些传参，调用的这一段语句是固定时间能完的，还是他是跟数据量有关的。如果他是跟数据量有关的语句他就不是一个常数操作，如果是跟数据量无关的操作他就是一个固定时间的操作。



### 什么是时间复杂度

以冒泡排序为例子：

![image-20240202153617056](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240202153617056.png) 

0-1之间谁大谁交换，我们先把这个时间设置为a操作，a是固定时间，后面的1-2，2-3.....这些都可以是常数操作，一共进行了7次交换。

![image-20240202153725245](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240202153725245.png) 

后续以此类推：7次、6次、5次......相当于是一个等差数列



### 等差数列求和公式

![image-20240202154006474](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240202154006474.png)

整个表达式中最高阶的东西就是他的时间复杂度。 

![image-20240202155653969](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240202155653969.png)

所以说冒泡排序就是复杂度为O(n^2)的算法。

复杂度不关心低阶项也不关心系数，他只关心最高阶是什么，这就叫做时间复杂度。



**为什么把时间复杂度做得怎么模糊呢**？

原因在于他就关心最高阶，当他的数据量很大的时候算法运行过程中的关系。



不管常数项多大，算法1的时间复杂度都是最高的

![image-20240202160056041](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240202160056041.png) 

不要系数，不要低阶项，因为如果n趋近于无穷，那么所有低阶项都变得不重要了，所以O(n)的算法就是比O(n^2)的算法好。

**决定这个算法运行时间的就是最高阶项的系数**。

所以时间复杂度是一个指标，他在于数据量很大的情况下，该怎么去描述算法时间之间的关系。



**二分的时间复杂度为：O(log2N),他会比O(N)低很多**



时间复杂度的概述图

![image-20240202160733742](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240202160733742.png) 

O(log2N)往往会忽略这个底，因为他比2大或者等于2，他出来的结果往往都会很小，所以可以忽略不计，后面默认都会写成O(logN)

常数:O(1)

估计时间复杂度用的都是最差的情况，要用怎么让这个流程最难受的情况来估计整个流程，假设最差情况。

![image-20240202161428729](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240202161428729.png)







### 什么是动态数组

规定长度之后不能再变的数组叫固定数组。

Java中的ArrayList就是动态数组。



### 动态数组使用和扩容

原来固定长度的时候，找到index位置的数的时间复杂度为O(1)固定时间的。



但是现在在ArrayList里面找index的数，这个行为中包含了另外一个行为就是扩容，扩容行为是否会影响ArrayList整体的表现？

当加入N个数的时候扩容行为的总代价是什么？





































































































































































































