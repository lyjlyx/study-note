# 算法



## 什么是算法

1、有具体的问题

2、有设计解决这个问题的具体流程

3、有评价处理流程的可量化指标



## 算法的分类

分类非常之多

算法不挑语言



## 简单的功能代码



### 题目一：阶乘

![image-20220819131038419](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220819131038419.png) 

当前阶乘的结果是上一步阶乘的结果乘以自己这一步。

时间复杂度、空间复杂度。



交换器

```JAVA
public static void convert(int[] arry, int i, int j) {
  int tmp = arry[i];
  arry[i] = arry[j];
  arry[j] = tmp;
}
```



### 题目二：选择排序

从小到大排序

每次找到最小值放到前面往后移动，直到全部排好

```java
    /**
     * 选择
     * @param arry
     */
    public static void selectSort(int[] arry) {
        if (arry.length < 2) {
            return;
        }
        int N = arry.length;
        for (int i = 0; i < N; i++) {
            int minIndex = i;
            for (int j = i + 1; j < N; j++) {
                minIndex = arry[minIndex] < arry[j] ? minIndex : j;
            }
            convert(arry, i, minIndex);
        }
    }
```



### 题目三：冒泡排序

相邻两个数之间比较交换

```java
    /**
     * 冒泡
     * @param arry
     */
    public static void popSort(int[] arry) {
        if (arry == null || arry.length < 2) {
            return;
        }
        int N = arry.length;
        // 0 ~ N - 1
        // 0 ~ end
        for (int end = N - 1; end > 0; end--) {
            // 0 ~ end 干一件事
            // 1 2 2 3 3 4
            for (int second = 1; second <= end; second++) {
                if (arry[second - 1] > arry[second]) {
                    convert(arry, second - 1, second);
                }
            }
        }
    }
```



### 题目四：插入排序

遍历数组，每个数都比对是否比前一个数小，如果小的话就换位置，继续向前比对，如果比前一个数大的话就停止比对。

相当于是从牌堆里面抓一张牌，从右往左找到合适的位置插入

每次遍历都要保证范围之间的有序

![image-20231203174310931](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20231203174310931.png) 



```java
    /**
     * 插入排序
     *
     * @param arry
     */
    public static void insertSort(int[] arry) {
        if (arry == null || arry.length < 2) {
            return;
        }
        // 0~0完成的数
        // 0~1
        // 0~2
        // 0~3
        // 0~n-1范围上有序
        int N = arry.length;
        for (int end = 1; end < N; end++) {
            // 当前数的位置
            int currentIdx = end;
            // 我当前数的位置前面有数   并且  当前这个位置的数左边的数，比我当前这个位置的数还要大，则进行位置的交换
            while (currentIdx - 1 >= 0 && arry[currentIdx - 1] > arry[currentIdx]) {
                // 当前位置左边的数和当前位置的数进行交换
                convert(arry, currentIdx - 1, currentIdx);
                // 然后往左移动
                currentIdx --;
                // 左边不在有数了，或者左边有数但是已经不大于你了，则跳出
            }
        }

    }
```



### 题目五：插入排序优化

```java
/**
     * 插入排序（优化）
     *
     * @param arry
     */
    public static void insertSortOptimize(int[] arry) {
        if (arry == null || arry.length < 2) {
            return;
        }
        // 0~0完成的数
        // 0~1
        // 0~2
        // 0~3
        // 0~n-1范围上有序
        int N = arry.length;
        for (int end = 1; end < N; end++) {
            // int pre = end -1;
            // pre就是我们现在处理的前一个数(新数的前一个位置)
            // 新数一开始就在end上所以新数前一个就是end - 1
            // pre >= 0
            // 如果前一个位置真的没有越界说明就是有前一个位置
//            arry[pre] > arry[pre + 1];
            // 而且前一个位置的数会大于新位置的数，arry[pre + 1]其实就是新位置的数现在在哪
            // 意思就是如果前一个位置的数会比后一个位置的数大，其实相当于当前的数就在pre + 1的位置，并且发现比pre位置还要小就交换。
            // pre --
            // 这样当前位置就来到的pre，所以就pre --，当前位置就继续往前
            for (int pre = end - 1; pre >= 0 && arry[pre] > arry[pre + 1]; pre--) {
                convert(arry, pre, pre + 1);
            }
        }
    }
```



## 前缀和数组、对数器和随机行为

### 什么叫数据结构

其实我们看到的数据结构在计算机里面的内存结构都是一块空间里面存放着值，并且存放了相对应的内存地址供他去指向。

任何数据结构都是由两种数据原件构成：

连续结构或者跳转结构，或者是跳转结构。

**数学概念为：线性、非线性**

1、数据结构是存储、组织数据的方式

2、精心选择的数据结构可以带来更高的运行或者存储效率

3、数据结构是很多算法得以进行的载体

![image-20231203225603963](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20231203225603963.png) 



### 最基本的数据结构



#### 题目一：

#### 查询数组位置中L位置到R位置的累加和，这个查询非常的频繁

![image-20231203230109937](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20231203230109937.png) 

**第一种设计：**

建立一个正方形表，左边的数加上自己就是，L~R的累加和。

![image-20231203230623505](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20231203230623505.png) 

L <= R的

这张表成立之后后续的查询就会非常快，直接从表里拿值就行。

这张表的空间复杂度为：S(T) = T(n^2/2)



**第二种数据结构：前缀和数**

建立一个help数组

![image-20231203231113405](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20231203231113405.png)

H[i] 代表的是arr一路从0累加到i的整体结构 

H[i]=arr[0...i]的累加和

例如我们要查 3~7之间的累加和sum(3~7)

H[7] = 0~7

H[2]=0~2

所以

H[3~7] = H[7]-H[2]

并且当L=0的时候直接就哪H[R]的累加和就行了

当L!=0的时候就等于H[R]-H[L-1]

**这两种方法各有各的优点，一般来说前缀和的方案比较好，但是并不是绝对的，因为如果查询非常频繁，可能百亿次，使用第一种方法更好，因为他是直接拿值返回给我们的，后续不需要进行任何运算。但是第二种的话还要减一下。**

**没有剂量，不谈毒性**

![image-20231203231855679](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20231203231855679.png) 

 

 



### 二分、复杂度、动态数组、哈希表和有序表



### 有序数组中找到num

```java
package com.msb.arith1;
/**
 * 有序数组中找到num
 * 二分法   数据都是有序的情况下
 * @author Karry
 * @date 2023-01-31  12:16
 */
public class Dichotomy {
    public static boolean find(int[] arr, int num) {
        if (arr == null || arr.length == 0) {
            return false;       
}
        //定义左边界
        int L = 0;
        int R = arr.length - 1;
        //arr[0...N-1]
        // 如果左边界比右边界大+就跳出循环
        while (L <= R) {
            int mid  = (L + R) / 2;
            if (arr[mid] == num) {
                return true;
                //当mid的值小于 num的时候我们不要左边界的数据了
                // 将L的值定义到mid + 1上  同理：右边界也一样
            } else if (arr[mid] < num) {
                L = mid + 1;
            } else if (arr[mid] > num) {
                R = mid - 1;           
}
        }
        return false;
    }
}
```





### 有序数组中找到=num最左的位置

例如：

[1,1,1,2,2,2,3,4,4,5,5,6]

 要找>=2的

![image-20230131193942785](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20230131193942785.png)



**使用二分法不一定要有序**





### 局部最小值问题



**一个数组无序，但是有条件就是任意两个相邻的数不相等。**



依然可以二分：

先拿两头来比喻

1.[0] < [1]  就可以直接证明 0位置的数最小

2.[N-2] > [N-1] 可以证明N-1位置的数是局部最小的，因为他们一个是左边的边界一个是右边的边界，只需要判断一遍就行了。

3.中间的话就需要    左 > [i] < 右  i位置的数才是最小的

思路：

如果0位置的数小于1位置的数，直接就返回0位置的数，如果不小的话就可以直接证明0位置的数大于1位置的数（因为条件中是不相等的），同理N-1位置的数也一样。



**左边的局部是下降，右边的局部是上扬，所以一定是存在局部最小的情况才可能上扬。**

![image-20230131202803674](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20230131202803674.png) 



 **当我们使用二分法用mid取中间值的时候，如果mid位置比他左边小，右边也小，那么我们也直接返回mid的位置就行了**

![image-20230131203044554](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20230131203044554.png) 

**所以通过上述的推断，如果mid不同时小于自己的左和自己的右，不妨设左边比他小，那么结合上面两个条件，0~mid之间又是一个局部下降，局部上升的趋势，我们可以直接就可以断定0~mid之间必有局部最小，可以直接把右边砍掉。同理如果mid右边比他小，也一样**

![image-20230131203316394](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20230131203316394.png) 

**会有一个问题，当二分到只剩两个了的时候，因为我们使用的条件都是mid左边喝mid右边，如果只剩两个的时候会造成某一边没数据，导致数组下标越界，所以我们需要保证当只剩两位的时候直接比较这两位就行了，所以要限制这个数组三个数或三个数以上再判断**

![image-20230131210803135](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20230131210803135.png) 

![image-20230131210846202](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20230131210846202.png) 

**二分不一定要有序，要再某一个规定下，比如：确定某一侧一定有**



































































































































































