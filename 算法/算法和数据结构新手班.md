# 算法和数据结构新手班



## 什么是算法

1、有具体的问题

2、有设计解决这个问题的具体流程

3、有评价处理流程的可量化指标



## 算法的分类

分类非常之多

算法不挑语言



## 简单的功能代码



### 题目一：阶乘

![image-20220819131038419](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220819131038419.png) 

当前阶乘的结果是上一步阶乘的结果乘以自己这一步。

时间复杂度、空间复杂度。



交换器

```JAVA
public static void convert(int[] arry, int i, int j) {
  int tmp = arry[i];
  arry[i] = arry[j];
  arry[j] = tmp;
}
```



### 题目二：选择排序

从小到大排序

每次找到最小值放到前面往后移动，直到全部排好

```java
    /**
     * 选择
     * @param arry
     */
    public static void selectSort(int[] arry) {
        if (arry.length < 2) {
            return;
        }
        int N = arry.length;
        for (int i = 0; i < N; i++) {
            int minIndex = i;
            for (int j = i + 1; j < N; j++) {
                minIndex = arry[minIndex] < arry[j] ? minIndex : j;
            }
            convert(arry, i, minIndex);
        }
    }
```



### 题目三：冒泡排序

相邻两个数之间比较交换

```java
    /**
     * 冒泡
     * @param arry
     */
    public static void popSort(int[] arry) {
        if (arry == null || arry.length < 2) {
            return;
        }
        int N = arry.length;
        // 0 ~ N - 1
        // 0 ~ end
        for (int end = N - 1; end > 0; end--) {
            // 0 ~ end 干一件事
            // 1 2 2 3 3 4
            for (int second = 1; second <= end; second++) {
                if (arry[second - 1] > arry[second]) {
                    convert(arry, second - 1, second);
                }
            }
        }
    }
```



### 题目四：插入排序

遍历数组，每个数都比对是否比前一个数小，如果小的话就换位置，继续向前比对，如果比前一个数大的话就停止比对。

相当于是从牌堆里面抓一张牌，从右往左找到合适的位置插入

每次遍历都要保证范围之间的有序

![image-20231203174310931](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20231203174310931.png) 



```java
    /**
     * 插入排序
     *
     * @param arry
     */
    public static void insertSort(int[] arry) {
        if (arry == null || arry.length < 2) {
            return;
        }
        // 0~0完成的数
        // 0~1
        // 0~2
        // 0~3
        // 0~n-1范围上有序
        int N = arry.length;
        for (int end = 1; end < N; end++) {
            // 当前数的位置
            int currentIdx = end;
            // 我当前数的位置前面有数   并且  当前这个位置的数左边的数，比我当前这个位置的数还要大，则进行位置的交换
            while (currentIdx - 1 >= 0 && arry[currentIdx - 1] > arry[currentIdx]) {
                // 当前位置左边的数和当前位置的数进行交换
                convert(arry, currentIdx - 1, currentIdx);
                // 然后往左移动
                currentIdx --;
                // 左边不在有数了，或者左边有数但是已经不大于你了，则跳出
            }
        }

    }
```



### 题目五：插入排序优化

```java
/**
     * 插入排序（优化）
     *
     * @param arry
     */
    public static void insertSortOptimize(int[] arry) {
        if (arry == null || arry.length < 2) {
            return;
        }
        // 0~0完成的数
        // 0~1
        // 0~2
        // 0~3
        // 0~n-1范围上有序
        int N = arry.length;
        for (int end = 1; end < N; end++) {
            // int pre = end -1;
            // pre就是我们现在处理的前一个数(新数的前一个位置)
            // 新数一开始就在end上所以新数前一个就是end - 1
            // pre >= 0
            // 如果前一个位置真的没有越界说明就是有前一个位置
//            arry[pre] > arry[pre + 1];
            // 而且前一个位置的数会大于新位置的数，arry[pre + 1]其实就是新位置的数现在在哪
            // 意思就是如果前一个位置的数会比后一个位置的数大，其实相当于当前的数就在pre + 1的位置，并且发现比pre位置还要小就交换。
            // pre --
            // 这样当前位置就来到的pre，所以就pre --，当前位置就继续往前
            for (int pre = end - 1; pre >= 0 && arry[pre] > arry[pre + 1]; pre--) {
                convert(arry, pre, pre + 1);
            }
        }
    }
```



## 前缀和数组、对数器和随机行为

### 什么叫数据结构

其实我们看到的数据结构在计算机里面的内存结构都是一块空间里面存放着值，并且存放了相对应的内存地址供他去指向。

任何数据结构都是由两种数据原件构成：

连续结构或者跳转结构，或者是跳转结构。

**数学概念为：线性、非线性**

1、数据结构是存储、组织数据的方式

2、精心选择的数据结构可以带来更高的运行或者存储效率

3、数据结构是很多算法得以进行的载体

![image-20231203225603963](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20231203225603963.png) 



### 最基本的数据结构



#### 题目一：

#### 查询数组位置中L位置到R位置的累加和，这个查询非常的频繁

![image-20231203230109937](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20231203230109937.png) 

**第一种设计：**

建立一个正方形表，左边的数加上自己就是，L~R的累加和。

![image-20231203230623505](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20231203230623505.png) 

L <= R的

这张表成立之后后续的查询就会非常快，直接从表里拿值就行。

这张表的空间复杂度为：S(T) = T(n^2/2)



**第二种数据结构：前缀和数**

建立一个help数组

![image-20231203231113405](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20231203231113405.png)

H[i] 代表的是arr一路从0累加到i的整体结构 

H[i]=arr[0...i]的累加和

例如我们要查 3~7之间的累加和sum(3~7)

H[7] = 0~7

H[2]=0~2

所以

H[3~7] = H[7]-H[2]

并且当L=0的时候直接就哪H[R]的累加和就行了

当L!=0的时候就等于H[R]-H[L-1]

**这两种方法各有各的优点，一般来说前缀和的方案比较好，但是并不是绝对的，因为如果查询非常频繁，可能百亿次，使用第一种方法更好，因为他是直接拿值返回给我们的，后续不需要进行任何运算。但是第二种的话还要减一下。**

**没有剂量，不谈毒性**

![image-20231203231855679](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20231203231855679.png) 

 

 



### 二分、复杂度、动态数组、哈希表和有序表



### 有序数组中找到num

```java
package com.msb.arith1;
/**
 * 有序数组中找到num
 * 二分法   数据都是有序的情况下
 * @author Karry
 * @date 2023-01-31  12:16
 */
public class Dichotomy {
    public static boolean find(int[] arr, int num) {
        if (arr == null || arr.length == 0) {
            return false;       
}
        //定义左边界
        int L = 0;
        int R = arr.length - 1;
        //arr[0...N-1]
        // 如果左边界比右边界大+就跳出循环
        while (L <= R) {
            int mid  = (L + R) / 2;
            if (arr[mid] == num) {
                return true;
                //当mid的值小于 num的时候我们不要左边界的数据了
                // 将L的值定义到mid + 1上  同理：右边界也一样
            } else if (arr[mid] < num) {
                L = mid + 1;
            } else if (arr[mid] > num) {
                R = mid - 1;           
}
        }
        return false;
    }
}
```





### 有序数组中找到=num最左的位置

例如：

[1,1,1,2,2,2,3,4,4,5,5,6]

 要找>=2的

![image-20230131193942785](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20230131193942785.png)



**使用二分法不一定要有序**





### 局部最小值问题



**一个数组无序，但是有条件就是任意两个相邻的数不相等。**



依然可以二分：

先拿两头来比喻

1.[0] < [1]  就可以直接证明 0位置的数最小

2.[N-2] > [N-1] 可以证明N-1位置的数是局部最小的，因为他们一个是左边的边界一个是右边的边界，只需要判断一遍就行了。

3.中间的话就需要    左 > [i] < 右  i位置的数才是最小的

思路：

如果0位置的数小于1位置的数，直接就返回0位置的数，如果不小的话就可以直接证明0位置的数大于1位置的数（因为条件中是不相等的），同理N-1位置的数也一样。**一开始下降最后上扬，中间必然存在局部最小**



这样0位置的数到1位置的数呈下降趋势，n-2~n-1位置的数呈上升

**左边的局部是下降，右边的局部是上扬，所以一定是存在局部最小的情况才可能上扬。**

![image-20230131202803674](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20230131202803674.png) 



 **当我们使用二分法用mid取中间值的时候，如果mid位置比他左边小，右边也小，那么我们也直接返回mid的位置就行了**

![image-20230131203044554](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20230131203044554.png) 



**如果上述情况不成立，如果mid不同时小于自己的左和自己的右，我们不妨设左边比他小，0~1位置的数是大于1位置的，他小局部是一个下降趋势，而mid-1~mid又是上扬的，那么结合上面两个条件，我们可以直接就可以断定0~mid之间必有局部最小，可以直接把右边砍掉。同理如果mid右边比他小，也一样**

![image-20230131203316394](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20230131203316394.png) 

先判断mid比不比左侧大，如果mid比左侧大我们直接不用管右边怎么样，直接砍掉找左边。如果mid没有比左边大，也一样

**第一版核心实现 + 对数器**

```java
package com.msb.arith1;

/**
 * 局部最小问题
 * 无序，但是任意两个相邻的数不相等
 * 例如:
 * 5位置的数一定不会4、6位置的数相等
 * 任意两个相邻的数一定不等
 * 虽然他是无序的，但是也可以使用二分法
 * 边界条件：
 * [0] < [1]  0为局部最小
 * [n-2] > [n-1]  n-1位置是局部最小
 * 左>[i]<右   这样i位置的数是局部最小
 */
public class LocalMinimum1 {


    /**
     * arr整体无序
     * arr相邻的数不相等！
     *
     * @param arr
     * @return
     */
    public static int onMinIndex(int[] arr) {
        // 如果只有一个数
        if (arr == null || arr.length == 0) {
            return -1;
        }

        // 一个数的时候默认0位置局部最小
        if (arr.length == 1) {
            return 0;
        }

        int N = arr.length;
        //====如果长度等于二，这两个if一定会返回===
        // 边界设置
        if (arr[0] < arr[1]) {
            return 0;
        }
        if (arr[N - 1] < arr[N - 2]) {
            return N - 1;
        }
        // =============
        // arr.length > 2
        int L = 0;
        int R = N - 1;
        int ans = -1;
        while (L <= R) {
            int mid = (L + R) / 2;
            //================旧写法====================
//            // 中间位置左右两边同时小
//            if (arr[mid] < arr[mid - 1] && arr[mid] < arr[mid] + 1) {
//                ans = mid;
//                break;
//            }
//            // 中间位置大于左边，那么直接放弃右边找左边的
//            if (arr[mid] > arr[mid - 1]) {
//                R = mid - 1;
//                continue;
//            }
//            // 中间位置大于右边，那么直接放弃左边找右边的
//            if (arr[mid] > arr[mid + 1]) {
//                L = mid + 1;
//                continue;
//            }
            // ========================================
            // 新写法

            // 中间位置左右两边同时小
            if (arr[mid] < arr[mid - 1] && arr[mid] < arr[mid] + 1) {
                ans = mid;
                break;
            } else {
                // 不同时小
                // 不同时小的情况有三种
                //  1.左 > mid mid < 右
                //  2.左 < mid mid < 右
                //  3.左 < mid mid > 右
                // 中间位置大于左边，那么直接放弃右边找左边的
                //  这个if的情况是2、3
                if (arr[mid] > arr[mid - 1]) {
                    R = mid - 1;
                } else {
                    //中间位置大于右边，那么直接放弃左边找右边的
                    //arr[mid] > arr[mid + 1] 一定大于
                    L = mid + 1;
                }
            }
        }
        return ans;
    }

    // 生成随机的数组,并且保证两个数之间要相邻不相等
    public static int[] randomArray(int maxLen, int maxValue) {
        int length = (int) (Math.random() * maxLen);
        int arr[] = new int[length];
        if (length > 0) {
            // 先把第一位的数随机出来
            arr[0] = (int) (Math.random() * maxValue);
            // 接下来从1位置的数开始生成，但是不能跟0位置的数一样
            for (int i = 1; i < length; i++) {
                do {
                    arr[i] = (int) (Math.random() * maxValue);
                    // 如果生成的数==前面那个数了，就重新生成，这样就能保证相邻不相等了
                } while (arr[i] == arr[i - 1]);
            }
        }
        return arr;
    }

    // 测试用
    public static boolean check(int[] arr, int minIndex) {
        // =0的情况局部最小返回的是-1
        if (arr.length == 0) {
            return minIndex == -1;
        }
        int left = minIndex - 1;
        int right = minIndex  + 1;
        // 如果生成的数组不越界，那就真的拿去比一下，如果越界了就可以认为他不破坏这个规则
        // 左边是否大于minIndex
        boolean leftBigger = left >= 0 ? arr[left] > arr[minIndex] : true;
        //                      如果是不越界真实的位置  并且右边的位置是否会大于局部最小位置
        boolean rightBigger = right < arr.length ? arr[right] > arr[minIndex] : true;
        return leftBigger && rightBigger;
    }

    public static void printArray(int[] arr) {
        for (int i : arr) {
            System.out.print(i + " ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        int maxLen = 10;
        int maxValue = 20;
        int testTime = 100000;
        System.out.println("测试开始");
        for (int i = 0; i < testTime; i++) {
            // 生成数组
            int[] arr = randomArray(maxLen, maxValue);
            int ans = onMinIndex(arr);
            boolean check = check(arr, ans);
            if (!check) {
                printArray(arr);
                System.out.println(ans);
                break;
            }
        }
        System.out.println("测试结束");
    }

}
```

执行结果为

![image-20240201132056711](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240201132056711.png) 

但是当我们将maxLen扩大的时候，发现会有下标数组越界的问题。

![image-20240201132137775](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240201132137775.png) 

问题是我们想要的是M-1位置和M+1位置还在L~R范围内，如果超过L~R了就会出现数组越界的问题。

 ![image-20240201132409399](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240201132409399.png) 



**会有一个问题，当二分到只剩两个了的时候，因为我们使用的条件都是mid左边和mid右边，如果只剩两个的时候会造成某一边没数据，导致数组下标越界，所以我们需要保证当只剩两位的时候直接比较这两位就行了，所以要限制这个数组三个数或三个数以上再判断**

解决的方式就是让L < R-1，限定一下L~R是三个数或者三个数以上在让他二分，如果不够三个数的话我们就单独验证这两个数谁是最小值返回。

修改过后的代码：

```java
    /**
     * arr整体无序
     * arr相邻的数不相等！
     * 解决数组越界问题
     * @param arr
     * @return
     */
    public static int onMinIndexAnswer(int[] arr) {
        // 如果只有一个数
        if (arr == null || arr.length == 0) {
            return -1;
        }

        // 一个数的时候默认0位置局部最小
        if (arr.length == 1) {
            return 0;
        }

        int N = arr.length;
        //====如果长度等于二，这两个if一定会返回===
        // 边界设置
        if (arr[0] < arr[1]) {
            return 0;
        }
        if (arr[N - 1] < arr[N - 2]) {
            return N - 1;
        }
        // =============
        // arr.length > 2
        int L = 0;
        int R = N - 1;
        while (L < R - 1) {
            int mid = (L + R) / 2;
            // 中间位置左右两边同时小
            if (arr[mid] < arr[mid - 1] && arr[mid] < arr[mid + 1]) {
               return mid;
            } else {
                if (arr[mid] > arr[mid - 1]) {
                    R = mid - 1;
                } else {
                    //中间位置大于右边，那么直接放弃左边找右边的
                    //arr[mid] > arr[mid + 1] 一定大于
                    L = mid + 1;
                }
            }
        }
        return arr[L] < arr[R] ? L : R;
    }
```



造成前面那版问题数组例子：[3,2,3,2,3]

![image-20230131210803135](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20230131210803135.png) 

![image-20240202152329741](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240202152329741.png) 



**二分不一定要有序，要再某一个规定下，比如：确定某一侧一定有就可以用二分法**



### 什么是常数操作



**等差数列求和公式**

 ![image-20240202152605744](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240202152605744.png)



#### **时间复杂度**

他是用来描述到底发生了几次常数操作的一个指标。

**常数操作就是他跟数据量没有关系，他就是固定时间的。**

**比如：int 1+1，int 100w + 100w这两个都是32位的整数这两个经历的过程是一样的。**

+、-、*、/、数组寻址等等都是常数操作，都是固定时间的。

当我们调用某一个语句的时候，他可能有些传参，调用的这一段语句是固定时间能完的，还是他是跟数据量有关的。如果他是跟数据量有关的语句他就不是一个常数操作，如果是跟数据量无关的操作他就是一个固定时间的操作。



### 什么是时间复杂度

以冒泡排序为例子：

![image-20240202153617056](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240202153617056.png) 

0-1之间谁大谁交换，我们先把这个时间设置为a操作，a是固定时间，后面的1-2，2-3.....这些都可以是常数操作，一共进行了7次交换。

![image-20240202153725245](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240202153725245.png) 

后续以此类推：7次、6次、5次......相当于是一个等差数列



### 等差数列求和公式

![image-20240202154006474](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240202154006474.png)

整个表达式中最高阶的东西就是他的时间复杂度。 

![image-20240202155653969](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240202155653969.png)

所以说冒泡排序就是复杂度为O(n^2)的算法。

复杂度不关心低阶项也不关心系数，他只关心最高阶是什么，这就叫做时间复杂度。



**为什么把时间复杂度做得怎么模糊呢**？

原因在于他就关心最高阶，当他的数据量很大的时候算法运行过程中的关系。



不管常数项多大，算法1的时间复杂度都是最高的

![image-20240202160056041](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240202160056041.png) 

不要系数，不要低阶项，因为如果n趋近于无穷，那么所有低阶项都变得不重要了，所以O(n)的算法就是比O(n^2)的算法好。

**决定这个算法运行时间的就是最高阶项的系数**。

所以时间复杂度是一个指标，他在于数据量很大的情况下，该怎么去描述算法时间之间的关系。



**二分的时间复杂度为：O(log2N),他会比O(N)低很多**



时间复杂度的概述图

![image-20240202160733742](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240202160733742.png) 

O(log2N)往往会忽略这个底，因为他比2大或者等于2，他出来的结果往往都会很小，所以可以忽略不计，后面默认都会写成O(logN)

常数:O(1)

估计时间复杂度用的都是最差的情况，要用怎么让这个流程最难受的情况来估计整个流程，假设最差情况。

![image-20240202161428729](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240202161428729.png)







### 什么是动态数组

规定长度之后不能再变的数组叫固定数组。

Java中的ArrayList就是动态数组。



### 动态数组使用和扩容

原来固定长度的时候，找到index位置的数的时间复杂度为O(1)固定时间的。



但是现在在ArrayList里面找index的数，这个行为中包含了另外一个行为就是扩容，扩容行为是否会影响ArrayList整体的表现？

当加入N个数的时候扩容行为的总代价是什么？（把数组扩容）

![image-20240219160408842](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240219160408842.png) 

扩容的过程为：1-2-4-8-16...-N

扩容代价为：1+2+4+8+16+...+N，这是一个等比数列，可以得出扩容的总代价为O(N)

加入N个数的时候代价为O(N)，那加入N个数的时候就是O(N)/N，均摊下来扩容代价到了某一步之后就变成了O(1)的一件小事。

所以总结：动态数组虽然有扩容，但是其实对于他的整体性能在时间复杂度的影响上是没有的，他做到了跟固定数组一样好还能支持动态扩容。但是并不是说他比固定数组就好，因为ArrayList当然会比固定数组要慢，但是这种慢只是常数时间的慢，从复杂度的角度来说的话是没有影响的。

所以从时间复杂度的角度上来说ArrayList和正常的固定数组一样还支持扩容，因为他的常数时间会比单纯的固定数组差一点，但是他只是不影响时间复杂度的差，在工程上我们几乎感觉不到。



### 哈希表和有序表的使用

在hash表中原生类型内部要值传递，非基础原生类型内部按照引用（内存地址作为key）传递。

以金庸为key他的所有作品为value，放到HashMap里面，问这条记录占用Hash表的字节数是多少

![image-20240219161643247](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240219161643247.png) 

答：金庸两个字的字节数+他所有作品的字节数



问HashMap里面的key和value都是Node对象，Key的Node里面放了个str为金庸，value的Node里面也有个str放了作品内容，问这个Hash表里面占用的字节数是多少

![image-20240219161754143](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240219161754143.png)

答：在hash表中他不会吧所有的字节都拷贝到hash表里面去，对于hash表来说你如果不是按值传递的，他在hash表空间占用的时候只是一个地址，所以两个node塞进去的话就是一个地址8字节、一个地址8字节，hash表的占用为16字节，不管你node占用多大，在hash表中就占用那么多。

![image-20240219162312778](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240219162312778.png) 





TreeMap<Integer,String>里面跟hash表一样，也是按值传递的。

但是他里面也很多工具方法。对于treeMap来说，内部会按照key排好序。

![image-20240219162455441](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240219162455441.png)

我们可以认为TreeMap上面的这些方法他的时间复杂度都是O(logN)级别的



如果是Node类型的呢？

有序表就不能直接用了，会报错，因为我们要求key一定要是可以比较的，如果不能比较是不被允许的。

![image-20240219162708201](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240219162708201.png)

如果你要自己定义接口的话，就需要自己去定义如何比较，不然用不了有序表。





## 单链表及其简单题目



### 介绍单链表和双链表

![image-20240219171709294](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240219171709294.png) 

### 单链表的反转

下面是一条链表，所谓的反转就是把指针全部都逆序了。

![image-20240219172137032](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240219172137032.png)



会有一个问题，当链表逆序之后，head引用要是还是指向a的话，后面的b,c,d都会不见，所以在这个情况下jvm会把这个链表给释放掉，因为没有任何引用去找到bcd。

![image-20240219172409513](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240219172409513.png)



所以我们需要写一个f()把头传进去Head = f(head)，我们在写这个函数的时候一定要写一个返回值，让这个头的值被使用，不然这个链表就会被当成垃圾回收。



任何一个引用都找不到剩下的空间，JVM会把它们认为是无用的，直接释放。**根可达**

![image-20240219172948264](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240219172948264.png)

单链表逆序代码

```java
public class RevertList {

    public static class Node {
        public int value;
        public Node next;

        public Node(int value) {
            this.value = value;
        }
    }
    
     /**
     * 单链表反转
     */
    public static Node reverseLinkedList(Node head) {

        Node pre = null;
        Node next = null;
        while (head != null) {

            next = head.next;
            head.next = pre;
            pre = head;
            head = next;
        }
        return pre;
    }
    public static void main(String[] args) {
        Node n1 = new Node(1);
        n1.next = new Node(2);
        n1.next.next = new Node(3);
        // 返回Head头部
        n1 = reverseLinkedList(n1);
        while (n1 != null) {
            System.out.print(n1.value + " ");
            n1 = n1.next;
        }
        System.out.println();
    }
 }
```



![image-20240219222312675](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240219222312675.png) 



### 双链表的反转

题目

![image-20240220130905419](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240220130905419.png) 



反转的结果：

![image-20240220131005368](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240220131005368.png)



双向链表的反转过程

![1](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/1.jpg) 

![2](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/2.jpg) 

![3](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/3.jpg) 

双向链表反转代码：

```java
public class RevertList {
   public static class DoubleNode {
        public int value;

        public DoubleNode last;

        public DoubleNode next;

        public DoubleNode(int value) {
            this.value = value;
        }
    }
   /**
     *  1-2-3-4-null
     *  1~2~3~4~null
     */
    /**
     * 双链表反转
     * @param head
     * @return
     */
    public static DoubleNode reverseDoubleLinkedList(DoubleNode head) {
        DoubleNode next = null;
        DoubleNode pre = null;
        while (head != null) {
            // 先把头的next节点记住
            next = head.next;
            head.next = pre;
            // 原先的last要反转指向next
            head.last = next;
            pre = head;
            head = next;
        }
        return pre;
    }
 }
```



### 用单链表结构实现队列

队列的话就是像排队一样先进先出，栈的话就像弹夹一样先进后出。

#### 队列

第一次插入

![image-20240220213629005](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240220213629005.png)

![image-20240220213859911](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240220213859911.png) 

**每加一个数都往尾巴加值，保证从head出发都可达**

![image-20240220215325926](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240220215325926.png) 



当所有的值都弹出之后，要让h和tail保持一致都为Null

![image-20240220215509718](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240220215509718.png) 



```java
package com.msb.arith2;

public class LinkedListToQueueAndStack {

    public static class Node<V> {

        public V value;
        public Node<V> next;

        public Node(V value) {
            this.value = value;
        }
    }

    public static class MyQueue<V> {
        private Node<V> head;
        private Node<V> tail;
        private int size;

        public MyQueue() {
            head = null;
            tail = null;
            size = 0;
        }

        public boolean isEmpty() {
            return size == 0;
        }

        public int size() {
            return size;
        }

        /**
         * 添加节点
         * @param value
         */
        public void offer(V value) {
            // 保证值一进来就先建出来一个节点
            Node<V> cur = new Node<V>(value);
            if (tail == null) {
                head = cur;
                tail = cur;
            } else {
                // 尾巴的next指针指向当前节点
                tail.next = cur;
                // 尾巴跳到当前节点位置
                tail = cur;
            }
            size ++;
        }

        /**
         * 弹出节点
         * @return
         */
        public V poll() {
            V ans = null;
            if (head != null) {
                // 从头开始弹出，先进先出的原理
                ans = head.value;
                head = head.next;
                size --;
            }
            // 当所有的值都弹出之后，要让h和tail保持一致都为Null
            if (head == null) {
                // 如果不这样释放，tail指向最后一个数，而h指向null，那这个tail就不会被释放，就是一个脏数据
                tail = null;
            }
            return ans;
        }

        public V peek() {
            V ans = null;
            if (head != null) {
                ans = head.value;
            }
            return ans;
        }

    }

}
```



#### 栈

压栈

![image-20240220221048333](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240220221048333.png)

弹出 

![image-20240220221158697](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240220221158697.png)



```java
public static class MyStack<V> {
        private Node<V> head;
        private int size;

        MyStack() {
            head = null;
            size = 0;
        }

        public boolean isEmpty() {
            return size == 0;
        }

        public int size() {
            return size;
        }

        public void push(V value) {
            Node<V> cur = new Node<>(value);
            if (head == null) {
                head = cur;
            } else {
                cur.next = head;
                head = cur;
            }
            size ++;
        }

        public V pop() {
            V ans = null;
            if (head != null) {
                ans = head.value;
                head = head.next;
                size --;
            }
            return ans;
        }

        public V peek() {
            return head != null ? head.value : null;
        }
    }
```





### 用双链表结构实现双端队列

可以头部加数据，头部出数据，也可以尾部加数据尾部出数据。

**![image-20240221130826911](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240221130826911.png) **



**单链表只支持头部加头部出，不支持尾部出，因为这样从尾部弹出的话会找不到之前的值。**

![image-20240221131038755](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240221131038755.png) 

代码示例：

```java
package com.msb.arith2;

/**
 * 双端链表队列
 */
public class DoubleLinkedListToDeque {

    public static class Node<V> {
        public V value;
        public Node<V> last;
        public Node<V> next;
        public Node(V v) {
            value = v;
            last = null;
            next = null;
        }
    }

    public static class MyDeque<V> {
        private Node<V> head;
        private Node<V> tail;
        private  int size;

        public MyDeque() {
            head = null;
            tail = null;
            size = 0;
        }

        public boolean isEmpty() {
            return size == 0;
        }

        public int size() {
            return size;
        }

        /**
         * 从头部加
         * @param value
         */
        public void pushHead(V value) {
            //当前节点
            Node<V> cur = new Node<V>(value);
            if (head == null) {
                head = cur;
                tail = cur;
            } else {
                // 新进来的next指针指向head
                cur.next = head;
                // 老的head的上一个节点last指针指向新进来的节点
                head.last = cur;
                // 因为cur的last指针没设置，那就默认指向Null
                // 头调到当前节点上去
                head = cur;
            }
            size ++;
        }

        /**
         * 尾巴加入
         * @param value
         */
        public void pushTail(V value) {
            //当前节点
            Node<V> cur = new Node<V>(value);
            if (head == null) {
                head = cur;
                tail = cur;
            } else {
                tail.next = cur;
                cur.last = tail;
                tail = cur;
            }
            size ++;
        }
    }
}

```





### K个节点的组内逆序调整

一个单向链表，给你一个k值如果是3，请把这个链表按照三个三个分组，不足3个的不管他，然后每组给他逆序调整

比如:

1-2-3-4-5-6-7-8

123一组456一组 78 不管他结果应该为

3-2-1-6-5-4-7-8这样的链式结构

![image-20240222192347369](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240222192347369.png)



**给定链表的开始节点，数到第k位把第k位的数据返回。**

```java
public static ListNode getGroupEnd(ListNode start, int k) {
                        // --k调到null就没有值了
        while (--k !=0 && start != null) {
            start = start.next;
        }
        return start;
    }
```

![image-20240223131030455](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240223131030455.png)

start != null

![image-20240223131205446](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240223131205446.png)

reverse函数功能为

![image-20240223131525600](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240223131525600.png)

先把s的next指针指向null，然后其他的指针除了k以外统一都往回指，并且在e往回值之前先把k的位置记住

![image-20240223131643000](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240223131643000.png) 

再让s的next指针指向k

![image-20240223131702444](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240223131702444.png) 





为什么要让end先往前一步，是因为当完成了开始和结束之后要把连表反过来指向。
// a-b-c-d-f ， 要把abcd反过来，要让a指向f这个工作，所以才要记这个位置。

因为到了e才停，而abcd这几个都是要干事的

1、

![image-20240225131017849](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240225131017849.png)

2、

![image-20240225131735156](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240225131735156.png)

3、

![image-20240225131753152](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240225131753152.png)



![image-20240225131806970](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240225131806970.png)

相关实现代码：

```java
package com.msb.arith2;

/**
 * K个节点的组内逆序调整
 * 一个单向链表，给你一个k值如果是3，请把这个链表按照三个三个分组，不足3个的不管他，然后每组给他逆序调整
 * 比如:
 * 1-2-3-4-5-6-7-8
 * 123一组456一组 78 不管他结果应该为
 * 3-2-1-6-5-4-7-8这样的链式结构
 */
public class ReverseNodesInKGroup {
    public static class ListNode {
        private ListNode next;
        private int size;

        public ListNode(ListNode next) {
            this.next = next;
        }
    }
    /**
     * 给定链表的开始节点，数到第k位把第k位的数据返回。
     * @param start
     * @param k
     * @return
     */
    public static ListNode getGroupEnd(ListNode start, int k) {
                        // --k调到null就没有值了
        while (--k !=0 && start != null) {
            start = start.next;
        }
        return start;
    }
    public static void reverse(ListNode start, ListNode end) {
        // 这里为什么要让他指向下一个节点是因为当完成了开始和结束之后要把链表反过来指向。
        // a-b-c-d-f // 要把abcd反过来，要让a指向f这个工作，所以才要记这个位置。
        end = end.next;
        ListNode pre = null;
        ListNode cur = start;
        ListNode next = null;
        while (cur != end) {
            next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        start.next = end;
    }
}
```



主逻辑的使用：

如果K=3

![image-20240226162803617](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240226162803617.png)

直接把头部定义为end节点，因为最终肯定都是要反向的，所以直接定end为head，新head一直都不动

![image-20240226163104459](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240226163104459.png)

反转

![image-20240226163155340](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240226163155340.png)



反转完后上一组的结尾节点lastStart为a

![image-20240226163307421](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240226163307421.png)

定义新一组的开头为上一组结尾节点的next

![image-20240226163453630](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240226163453630.png)

然后开始进行下一组的反转，因为k=3所以end蹦到了f

![image-20240226163700529](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240226163700529.png)

再反转

![image-20240226163800679](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240226163800679.png)

上一个节点的next指针指向这一回的end。

![image-20240226163859913](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240226163859913.png)

![image-20240226163925848](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240226163925848.png)

```java
/**
     * 主逻辑的使用
     *
     * @param head
     * @param k
     * @return
     */
    public static ListNode reverseKGroup(ListNode head, int k) {
        ListNode start = head;
        // 获取到k的一组的结束节点
        ListNode end = getGroupEnd(start, k);
        // 第一组都凑不齐直接返回老头部
        if (end == null) {
            return head;
        }
        // 第一组凑齐了，因为最终肯定是end为头结点，
        // 所以直接调整，head后续都不会动了，返回也是返回新头部
        head = end;
        // 反转
        reverse(start, end);
        // 上一组的结尾节点就是start
        ListNode lastEnd = start;
        while (lastEnd.next != null) {
            // 定义新一组的开头为上一组结尾节点的next
            start = lastEnd.next;
            end = getGroupEnd(start, k);
            if (end == null) {
                return head;
            }
            reverse(start, end);
            lastEnd.next = end;
            lastEnd = start;
        }
        // 正好是k的整数倍，直接返回
        return head;
    }
```



### 两个链表相加

算法题：

![image-20240227131139876](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240227131139876.png) 

这种题目的思路就是先把长链表和短链表找到，把他们区分开来。

例题：

3-4-6-1
7-9-7

![image-20240227131601495](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240227131601495.png) 

整个过程分三步走

1、L有、S有

2、S无、L有

3、S无、L无

![image-20240228130313131](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240228130313131.png)

因为两链表相加有进位，所以我们要准备一个进位信息。



例题1：

**第一阶段L有S也有**

![image-20240228130550580](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240228130550580.png)

3+7+0=10 % 10 = 0，所以有进位=1



![image-20240228130743289](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240228130743289.png)



![image-20240228130827351](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240228130827351.png)



**第二阶段，只有长链表有的阶段，S无L有**

只剩下最后一位和进位是1 的数，相加之后得出的结果为2，进位信息改为0

![image-20240228130948947](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240228130948947.png)

**第三阶段，L和S都无发现进位信息为0，直接返回**

![image-20240228131046046](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240228131046046.png)

**2440**

例题2：

**第一阶段**

![image-20240228131121070](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240228131121070.png)



![image-20240228131224071](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240228131224071.png)

![image-20240228131243153](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240228131243153.png)

![image-20240228131257316](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240228131257316.png)

**第二阶段**

![image-20240228131328396](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240228131328396.png)

![image-20240228131344204](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240228131344204.png)

![image-20240228131351937](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240228131351937.png)

第三阶段：

**进位为0，前面不要补节点**

![image-20240228131418826](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240228131418826.png) 

还有一题

![image-20240228131526918](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240228131526918.png)

代码实现：

```java
package com.msb.arith2;

/**
 * 两个链表相加
 */
public class AddTwoNumbers {


    public static class ListNode {
        private ListNode next;
        private int value;
        public ListNode(int value) {
            this.value = value;
        }
    }

    public static ListNode addTwoNumbers(ListNode head1, ListNode head2) {
        int len1 = listLength(head1);
        int len2 = listLength(head2);
        // 长短链表重定向·
        // 较长链表
        ListNode l = len1 >= len2 ? head1 : head2;
        // 较短链表
        ListNode s = l == head1 ? head2 : head1;
        ListNode curL = l;
        ListNode curS = s;
        ListNode last = curL;
        // 进位
        int carry = 0;
        // 相加的值
        int curNum = 0;
        // 第一阶段，长链表有，短链表也有
        // 短链表为空的时候第一阶段才结束
        while (curS != null) {
            // 相加的值为 长链表的值 + 短链表的值 + 进位信息
            curNum = curL.value + curS.value + carry;
            // 这里改长链表的值是复用长链表，而不是重新生成一个链表来存放，减少空间复杂度
            curL.value = (curNum % 10);
            carry = curNum / 10;
            // 长链表结束的标记位
            last = curL;
            curL = curL.next;
            curS = curS.next;
        }
        // 第二阶段，长链表有，短链表没有
        while (curL != null) {
            curNum = curL.value + carry;
            curL.value = (curNum % 10);
            carry = curNum / 10;
            last = curL;
            curL = curL.next;
        }
        // 第三阶段，
        // 长链表和短链表都没有，
        // 查看进位有没有，有的话就在这个链表后面补一个
        if (carry != 0) {
            last.next = new ListNode(1);
        }
        return l;
    }

    /**
     * 求链表长度
     * @param head
     * @return
     */
    public static int listLength(ListNode head){
        int len = 0;
        while (head != null) {
            len ++;
            head = head.next;
        }
        return len;
    }

}

```





### 位图的功能

拿每一位byte作为图像

节省空间，用位来代替数。

**可以做出一个集合，如果数字范围是非常确定的，最大值很确定，我们就可以用位图来实现收集数字来告诉我们这个数存在不存在**

**他的好处就是可以极大的压缩空间。**



### 位图的实现

以long数组来定义，8字节-64bit-64位

一个数右移6位相当于除了64

```java
public BitMap(int max) {
    // 右移6位 是除以64(2^6)的意思
    // (max+64) >> 6 -> (max+64) / 64
    bits = new long[(max + 64) >> 6];
}
```

例题：long a = 170这个数想要定位是第几个证书拥有这个170

arr[i]

第0个整数拥有的是0~63这些数

第1个整数拥有的是64~127这些数

第2个整数拥有的是128~191这些数

所以170属于哪个整数其实就是170/64 = 2

![image-20240301131244122](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240301131244122.png)

那这个170到底是这个整数的第几位呢？

170%64 从右往左数



num >> 6 -> num / 64 --> 定位到哪个整数
num % 64 -> num & 63

为什么？

num%64虽然是能实现，但是%的运算是比较慢的

为什么说他num % 64 -> num & 63

因为63是01111111

例题：



![image-20240303143410094](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240303143410094.png)

110110这个就代码num%64的结果

让num&63  结果跟 num % 64是一样的

![image-20240303143908619](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240303143908619.png)

![image-20240303143942519](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240303143942519.png)

为什么只选7位呢？

因为0~63是只选7位的

所以num%64的结果就是只保留后7位的状态，前面的其他位置都是0，所以他就等同于&63，因为63后7位都是1，并且全1则1,

比如：

0 1 0 1 1 1 0 1 1 0 1 1 - num

0 0 0 0 0 1 1 1 1 1 1 1 - 63

上下两个数&一下 就是 1011011 所以 %64就等同于 &63 他们得到的结果都是一样的

&63的效率一定会比%64的效率快很多。

位运算的效率会比正常的 + - * / 快10倍往上。



找到第几个整数或上第几位是描述num的，把他移到那个位置之后(1L <<)把他或到里面去，相当于把num标上了

```java
        public void add(int num) {
            // num >> 6 -> num / 64 --> 定位到哪个整数
            // num % 64 -> num & 63 num模64就是num与上63
            //该找到的第几号整数     第几位是描述num的
            bits[num >> 6] |= (1L << (num & 63));
            // 找到第几个整数或上第几位是描述num的，把他移到那个位置之后(1L <<)把他或到里面去，相当于把num标上了
        }
```

add 例题：

先定位是第几个整数：170 % 64 = 2 那就是第二个整数

再定位这个运算在arr[2]里面是第几位：170 % 64  = 42位

找到第二个整数arr[2]，所以在arr[2]里面我们要想办法把第42位的数标1，这样就代表170进去了。

arr[2] = arr[2] |(1<< 42)  --可以写成-->   arr[2] |= (1 << 42)

假如这个数组原始都为0，而把1向左移动42位，把他们两个或一下就等同于第42位上进去了1，再把他赋值到这个arr[2]数组上去。



delete例题：

同上，add是要给他把1填上，那删除的话就是在这个基础上把他改成0，就等同于把这一位删了。



例题：

比如arr只有10位，把第三位的1去掉

![image-20240303152716229](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240303152716229.png) 

与的情况就是

1 0 1 1 0 1 1 0 1 1 

1 1 1 1 1 1 0 1 1 1 

1 0 1 1 0 1 0 0 1 1

上面 两个数与一下就相当于把第三位 数变成0

我们操作1的话要把1向左移动3位 0 0 0 0 0 0 1 0 0 0出现了这个数，然后把这个数给他取给反~，就变成了 1 1 1 1 1 1 0 1 1 1 

```java
        public void delete(int num) {
            bits[num >> 6] &= ~(1L << (num & 63));
        }
```

![image-20240303154432575](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240303154432575.png) 

查一个数

例题：

跟上面是一样的，170 找第二个数arr[2] ，查第42位，如果他是1就说明存在，如果他是0就说明不存在

让他&第42位是1，其他都是0的值，如果&完的结果 !=0则说明第42位是1，如果等于0那就说明第42位是0

```java
public boolean contains(int num) {
    return (bits[num >> 6] & (1L << (num & 63))) != 0;
}
```



完整代码：

```java
package com.msb.arith3;

import java.util.HashSet;

/**
 * 位图的实现
 */
public class Code02_BitMap {

    public static class BitMap {
        //int 4字节 32bit 32位
        //long 8字节 64bit 64位
        private long[] bits;

        public BitMap(int max) {
            // 右移6位 是除以64(2^6)的意思
            // (max+64) >> 6 -> (max+64) / 64
            bits = new long[(max + 64) >> 6];
        }

        public void add(int num) {
            // num >> 6 -> num / 64 --> 定位到哪个整数
            // num % 64 -> num & 63 num模64就是num与上63
            //该找到的第几号整数     第几位是描述num的
            bits[num >> 6] |= (1L << (num & 63));
            // 找到第几个整数或上第几位是描述num的，把他移到那个位置之后(1L <<)把他或到里面去，相当于把num标上了
        }
        public void delete(int num) {
            bits[num >> 6] &= ~(1L << (num & 63));
        }
        public boolean contains(int num) {
            return (bits[num >> 6] & (1L << (num & 63))) != 0;
        }
    }

    public static void main(String[] args) {
        Integer max = 10000;
        System.out.println("测试开始!");
        BitMap bitMap = new BitMap(max);
        HashSet<Integer> set = new HashSet<>();
        int testTime = 1000000;
        for (int i = 0; i < testTime; i++) {
            int num = (int) (Math.random() * (max + 1));
            double decide = Math.random();
            if (decide < 0.333) {
                bitMap.add(num);
                set.add(num);
            } else if (decide < 0.666) {
                bitMap.delete(num);
                set.remove(num);
            } else {
                if (bitMap.contains(num) != set.contains(num)) {
                    System.out.println("Oops!");
                    break;
                }
            }
        }
        for (int num = 0; num <= max; num ++) {
            if (bitMap.contains(num) != set.contains(num)) {
                System.out.println("Oops!");
            }
        }
        System.out.println("测试结束!");
    }

}
```

错题示范：

下面代码中可以看到，用到的是1来向左移动，因为如果只拿1移动42位的话如果不加L的话他会认为1只有32位，这样他就拿不到移动42位正确的结果了，所以一定要写1L移动42位，因为单独的1没有64位只有32位，单独写1默认都是认为是整型。

![image-20240303233823057](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240303233823057.png)

完整代码：

```java
package com.msb.arith3;

import java.util.HashSet;

/**
 * 位图的实现
 */
public class Code02_BitMap {

    public static class BitMap {
        //int 4字节 32bit 32位
        //long 8字节 64bit 64位
        private long[] bits;

        public BitMap(int max) {
            // 右移6位 是除以64(2^6)的意思
            // (max+64) >> 6 -> (max+64) / 64
            bits = new long[(max + 64) >> 6];
        }

        public void add(int num) {
            // num >> 6 -> num / 64 --> 定位到哪个整数
            // num % 64 -> num & 63 num模64就是num与上63
            //该找到的第几号整数     第几位是描述num的
            bits[num >> 6] |= (1L << (num & 63));
            // 找到第几个整数或上第几位是描述num的，把他移到那个位置之后(1L <<)把他或到里面去，相当于把num标上了
        }
        public void delete(int num) {
            bits[num >> 6] &= ~(1L << (num & 63));
        }
        public boolean contains(int num) {
            return (bits[num >> 6] & (1L << (num & 63))) != 0;
        }
    }

    public static void main(String[] args) {
        Integer max = 10000;
        System.out.println("测试开始!");
        BitMap bitMap = new BitMap(max);
        HashSet<Integer> set = new HashSet<>();
        int testTime = 1000000;
        for (int i = 0; i < testTime; i++) {
            int num = (int) (Math.random() * (max + 1));
            double decide = Math.random();
            if (decide < 0.333) {
                bitMap.add(num);
                set.add(num);
            } else if (decide < 0.666) {
                bitMap.delete(num);
                set.remove(num);
            } else {
                if (bitMap.contains(num) != set.contains(num)) {
                    System.out.println("Oops!");
                    break;
                }
            }
        }
        for (int num = 0; num <= max; num ++) {
            if (bitMap.contains(num) != set.contains(num)) {
                System.out.println("Oops!");
            }
        }
        System.out.println("测试结束!");
    }

}
```



### 怎么使用位运算进行加减乘除

**其实使用代码的加减乘除在计算机底层一定都是用位运算实现的**。

位运算的加减乘除都是比手写的加减乘除快的。

但是用位运算在java里面实现加减乘除反而不如java自身原带的加减乘除快。



举个例子：

a = 46 ->  32 + 8 + 4 + 2 -> 二进制形式为：0101110

b =20 -> 16 + 4 -> 二进制形式为：               0010100

![image-20240306131553442](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240306131553442.png)



**异或运算^就是无进位相加**：

![image-20240306131939067](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240306131939067.png) 



a ^ b 无进位相加

![image-20240306132134240](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240306132134240.png) 

a和b的进位是什么

a & b 的结果在向左移动一位就是进位信息

![image-20240306132443896](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240306132443896.png) 





![image-20240307131720928](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240307131720928.png)



**原始的a+b是不是就等同于 a + b无进位相加的结果加上进位信息的结果，也就是a ^b + 进位信息。**

例子: a = 46，b = 20

a^b不进位相加的数58

a 0101110

b 0010100 ^

——————

​    0111010   = 58

a&b再进一位，进位信息的结果为8

a 0101110

b 0010100

——————

​    0000100

<< 1(向左移动一位)

​     0001000   = 8

所以原始的原始的a =46,b=20可以等同于

a'	0111010

b'	0001000

相当于是a' + b'

所以 a' + b'

a'^b'

a'	0111010

b'	0001000 ^

——————————

​		0110010



a'&b'

a'	0111010

b'	0001000 &

——————————

​		0001000

<< 1

——————————

​		0010000

所以原始的a'+b'就等同于

0110010+0010000

![image-20240307132941177](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240307132941177.png) 



a''	0110010

b''	0010000	^

————————————

​		0100010



a''	0110010

b''	0010000	&

————————————

​		0010000

<<	1

————————————

​		0100000



a'''	0100010

b'''	0100000	^

————————————

​		0000010



a'''	0100010

b'''	0100000	&

————————————

​		0100000

<<1

————————————

​		1000000



a''''	0000010

b''''	1000000	^

————————————

​		1000010



a''''	0000010

b''''	1000000	&

————————————

​		0000000

<<1

————————————

​		0000000

**什么时候进位补偿没了得出来的a就是答案，也就是上面的a'''':1000010=66**

**就让他们一直按照上面的方式来操作，总有进位信息消失的时候，等什么时候进位信息没了，无进位信息就是答案**

**计算机里面实现的加法就是上面的这套流程。**





### 使用位运算实现加法

```java
    public static int add(int a, int b) {
        int sum = a;
        // 为什么要递归的原因是因为无论如何都不能出现+号
        while (b != 0) {
            //计算a,b无进位相加的信息
            sum = a ^ b;
            // 计算进位信息赋值给b -> b'(等同于进位信息)
            b = (a & b) << 1;
            // a -> a' 无进位相加信息
            a = sum;
        }
        // 等到b的进位信息消失，就得出了最终结果
        return sum;
    }
```



### 使用位运算实现减肥

a-b相当于是a + b的相反数

b的相反数相当于 ~b+1，但是我们的实现是不能出现加减号的，所以需要有替换

替换成：add(a, add(~b, 1))



































































## 算法资料

算法课资料、规划、代码：
1，打开链接：https://cloud.fynote.com/share/s/7615

2，上面链接是所有课程介绍，打开“马士兵教育算法系列课程”，找到“通过世界上任何大厂算法面试扎实路线”，是学习路线。

3，课上所有代码：https://github.com/algorithmzuo

4，课上所有ppt文字合集、算法知识脉络及其脑图：https://github.com/algorithmzuo/class-notes

5，如果你不能翻墙，无法打开github，如下是马士兵代码平台算法课所有代码：https://git.mashibing.com/msb_14613/algorithm-class

6，每周算法直播课链接：https://www.mashibing.com/live/1240

根据1打开链接。可以熟悉整套课程，资料非常全：课程介绍、每节课梗概、讲述题目汇总、所有代码实现、知识脑图、学习路线，详细笔记全部都有，先熟悉一下。

接下来是规划路线。

==============

如果你的准备时间超过7个月，按照最稳妥的路线学习：

根据1和2打开，可以看到课程简介、学习顺序，因为你有时间掌握所有的课，所以我就推荐按顺序全看全练。

一周看课和练习一共投入12小时的话，整套课程6-7个月可拿下所有的850+题。即便进度慢，也可拿下600题，面大厂很稳。

==============

如果你准备时间不够7个月，可以按照高频内容先看的路线：

1. 新手班只看链表题目、二叉树题目题目

1）体系学习班，章节1~27全部，章节39～40只看有关“根据数据量猜解法”的部分。

2）大厂刷题班，章节28~38，打开资料里对应这门课的代码，找到class28～class38，每一个目录里都有“说明”，把说明文件看一下。详细列出了leetcode高频题目列表。

3）大厂刷题班，章节1~27

4）体系学习班，章节28~48，跳过四边形不等式、DC3算法的内容

5）大厂刷题班其他所有内容、每周直播课

==============

最后是学习注意点如下

不需要自己找题刷！我就推荐看课！只需要刷课上的题！因为课上覆盖了大厂需要的几乎所有题。题目总数850多个，其中包含600多的leetcode原题。几乎没有简单题，都是leetcode上最值得练的题，以及大厂真实面试题，已经为你选好了。当你想试试自己的学习状态，你可以每周三晚8点来参加算法直播课，都是大厂最新考的、不重复的算法题。

看课的时候，对每一个内容，看懂课上解析+自己独立写出来。每看懂一个题，就写总结笔记，可以只写你自己能看懂的话，但是要求笔记能帮你回忆起算法大概的流程，能在脑海中勾勒code怎么组织。这样的笔记对你复习很重要，复习就不需要看视频了，想不起来再翻视频。不要频繁复习！因为后面的题会把之前学过的内容反复练习，整套课自带复习效果。看懂+自己写出+笔记，持续推进即可。

===============

仔细阅读上面发的所有资料和提醒。

然后开始看课，练题。

过程中任何困惑求解答、debug不出错误、见到新的算法面试题目不会做。都可以官网发帖，或者通过班主任拉群联系到我。



