# 算法和数据结构新手班



## 什么是算法

1、有具体的问题

2、有设计解决这个问题的具体流程

3、有评价处理流程的可量化指标



## 算法的分类

分类非常之多

算法不挑语言



## 简单的功能代码



### 题目一：阶乘

![image-20220819131038419](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20220819131038419.png) 

当前阶乘的结果是上一步阶乘的结果乘以自己这一步。

时间复杂度、空间复杂度。



交换器

```JAVA
public static void convert(int[] arry, int i, int j) {
  int tmp = arry[i];
  arry[i] = arry[j];
  arry[j] = tmp;
}
```



### 题目二：选择排序

从小到大排序

每次找到最小值放到前面往后移动，直到全部排好

```java
    /**
     * 选择
     * @param arry
     */
    public static void selectSort(int[] arry) {
        if (arry.length < 2) {
            return;
        }
        int N = arry.length;
        for (int i = 0; i < N; i++) {
            int minIndex = i;
            for (int j = i + 1; j < N; j++) {
                minIndex = arry[minIndex] < arry[j] ? minIndex : j;
            }
            convert(arry, i, minIndex);
        }
    }
```



### 题目三：冒泡排序

相邻两个数之间比较交换

```java
    /**
     * 冒泡
     * @param arry
     */
    public static void popSort(int[] arry) {
        if (arry == null || arry.length < 2) {
            return;
        }
        int N = arry.length;
        // 0 ~ N - 1
        // 0 ~ end
        for (int end = N - 1; end > 0; end--) {
            // 0 ~ end 干一件事
            // 1 2 2 3 3 4
            for (int second = 1; second <= end; second++) {
                if (arry[second - 1] > arry[second]) {
                    convert(arry, second - 1, second);
                }
            }
        }
    }
```



### 题目四：插入排序

遍历数组，每个数都比对是否比前一个数小，如果小的话就换位置，继续向前比对，如果比前一个数大的话就停止比对。

相当于是从牌堆里面抓一张牌，从右往左找到合适的位置插入

每次遍历都要保证范围之间的有序

![image-20231203174310931](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20231203174310931.png) 



```java
    /**
     * 插入排序
     *
     * @param arry
     */
    public static void insertSort(int[] arry) {
        if (arry == null || arry.length < 2) {
            return;
        }
        // 0~0完成的数
        // 0~1
        // 0~2
        // 0~3
        // 0~n-1范围上有序
        int N = arry.length;
        for (int end = 1; end < N; end++) {
            // 当前数的位置
            int currentIdx = end;
            // 我当前数的位置前面有数   并且  当前这个位置的数左边的数，比我当前这个位置的数还要大，则进行位置的交换
            while (currentIdx - 1 >= 0 && arry[currentIdx - 1] > arry[currentIdx]) {
                // 当前位置左边的数和当前位置的数进行交换
                convert(arry, currentIdx - 1, currentIdx);
                // 然后往左移动
                currentIdx --;
                // 左边不在有数了，或者左边有数但是已经不大于你了，则跳出
            }
        }

    }
```



### 题目五：插入排序优化

```java
/**
     * 插入排序（优化）
     *
     * @param arry
     */
    public static void insertSortOptimize(int[] arry) {
        if (arry == null || arry.length < 2) {
            return;
        }
        // 0~0完成的数
        // 0~1
        // 0~2
        // 0~3
        // 0~n-1范围上有序
        int N = arry.length;
        for (int end = 1; end < N; end++) {
            // int pre = end -1;
            // pre就是我们现在处理的前一个数(新数的前一个位置)
            // 新数一开始就在end上所以新数前一个就是end - 1
            // pre >= 0
            // 如果前一个位置真的没有越界说明就是有前一个位置
//            arry[pre] > arry[pre + 1];
            // 而且前一个位置的数会大于新位置的数，arry[pre + 1]其实就是新位置的数现在在哪
            // 意思就是如果前一个位置的数会比后一个位置的数大，其实相当于当前的数就在pre + 1的位置，并且发现比pre位置还要小就交换。
            // pre --
            // 这样当前位置就来到的pre，所以就pre --，当前位置就继续往前
            for (int pre = end - 1; pre >= 0 && arry[pre] > arry[pre + 1]; pre--) {
                convert(arry, pre, pre + 1);
            }
        }
    }
```



## 前缀和数组、对数器和随机行为

### 什么叫数据结构

其实我们看到的数据结构在计算机里面的内存结构都是一块空间里面存放着值，并且存放了相对应的内存地址供他去指向。

任何数据结构都是由两种数据原件构成：

连续结构或者跳转结构，或者是跳转结构。

**数学概念为：线性、非线性**

1、数据结构是存储、组织数据的方式

2、精心选择的数据结构可以带来更高的运行或者存储效率

3、数据结构是很多算法得以进行的载体

![image-20231203225603963](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20231203225603963.png) 



### 最基本的数据结构



#### 题目一：

#### 查询数组位置中L位置到R位置的累加和，这个查询非常的频繁

![image-20231203230109937](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20231203230109937.png) 

**第一种设计：**

建立一个正方形表，左边的数加上自己就是，L~R的累加和。

![image-20231203230623505](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20231203230623505.png) 

L <= R的

这张表成立之后后续的查询就会非常快，直接从表里拿值就行。

这张表的空间复杂度为：S(T) = T(n^2/2)



**第二种数据结构：前缀和数**

建立一个help数组

![image-20231203231113405](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20231203231113405.png)

H[i] 代表的是arr一路从0累加到i的整体结构 

H[i]=arr[0...i]的累加和

例如我们要查 3~7之间的累加和sum(3~7)

H[7] = 0~7

H[2]=0~2

所以

H[3~7] = H[7]-H[2]

并且当L=0的时候直接就哪H[R]的累加和就行了

当L!=0的时候就等于H[R]-H[L-1]

**这两种方法各有各的优点，一般来说前缀和的方案比较好，但是并不是绝对的，因为如果查询非常频繁，可能百亿次，使用第一种方法更好，因为他是直接拿值返回给我们的，后续不需要进行任何运算。但是第二种的话还要减一下。**

**没有剂量，不谈毒性**

![image-20231203231855679](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20231203231855679.png) 

 

 



### 二分、复杂度、动态数组、哈希表和有序表



### 有序数组中找到num

```java
package com.msb.arith1;
/**
 * 有序数组中找到num
 * 二分法   数据都是有序的情况下
 * @author Karry
 * @date 2023-01-31  12:16
 */
public class Dichotomy {
    public static boolean find(int[] arr, int num) {
        if (arr == null || arr.length == 0) {
            return false;       
}
        //定义左边界
        int L = 0;
        int R = arr.length - 1;
        //arr[0...N-1]
        // 如果左边界比右边界大+就跳出循环
        while (L <= R) {
            int mid  = (L + R) / 2;
            if (arr[mid] == num) {
                return true;
                //当mid的值小于 num的时候我们不要左边界的数据了
                // 将L的值定义到mid + 1上  同理：右边界也一样
            } else if (arr[mid] < num) {
                L = mid + 1;
            } else if (arr[mid] > num) {
                R = mid - 1;           
}
        }
        return false;
    }
}
```





### 有序数组中找到=num最左的位置

例如：

[1,1,1,2,2,2,3,4,4,5,5,6]

 要找>=2的

![image-20230131193942785](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20230131193942785.png)



**使用二分法不一定要有序**





### 局部最小值问题



**一个数组无序，但是有条件就是任意两个相邻的数不相等。**



依然可以二分：

先拿两头来比喻

1.[0] < [1]  就可以直接证明 0位置的数最小

2.[N-2] > [N-1] 可以证明N-1位置的数是局部最小的，因为他们一个是左边的边界一个是右边的边界，只需要判断一遍就行了。

3.中间的话就需要    左 > [i] < 右  i位置的数才是最小的

思路：

如果0位置的数小于1位置的数，直接就返回0位置的数，如果不小的话就可以直接证明0位置的数大于1位置的数（因为条件中是不相等的），同理N-1位置的数也一样。**一开始下降最后上扬，中间必然存在局部最小**



这样0位置的数到1位置的数呈下降趋势，n-2~n-1位置的数呈上升

**左边的局部是下降，右边的局部是上扬，所以一定是存在局部最小的情况才可能上扬。**

![image-20230131202803674](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20230131202803674.png) 



 **当我们使用二分法用mid取中间值的时候，如果mid位置比他左边小，右边也小，那么我们也直接返回mid的位置就行了**

![image-20230131203044554](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20230131203044554.png) 



**如果上述情况不成立，如果mid不同时小于自己的左和自己的右，我们不妨设左边比他小，0~1位置的数是大于1位置的，他小局部是一个下降趋势，而mid-1~mid又是上扬的，那么结合上面两个条件，我们可以直接就可以断定0~mid之间必有局部最小，可以直接把右边砍掉。同理如果mid右边比他小，也一样**

![image-20230131203316394](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20230131203316394.png) 

先判断mid比不比左侧大，如果mid比左侧大我们直接不用管右边怎么样，直接砍掉找左边。如果mid没有比左边大，也一样

**第一版核心实现 + 对数器**

```java
package com.msb.arith1;

/**
 * 局部最小问题
 * 无序，但是任意两个相邻的数不相等
 * 例如:
 * 5位置的数一定不会4、6位置的数相等
 * 任意两个相邻的数一定不等
 * 虽然他是无序的，但是也可以使用二分法
 * 边界条件：
 * [0] < [1]  0为局部最小
 * [n-2] > [n-1]  n-1位置是局部最小
 * 左>[i]<右   这样i位置的数是局部最小
 */
public class LocalMinimum1 {


    /**
     * arr整体无序
     * arr相邻的数不相等！
     *
     * @param arr
     * @return
     */
    public static int onMinIndex(int[] arr) {
        // 如果只有一个数
        if (arr == null || arr.length == 0) {
            return -1;
        }

        // 一个数的时候默认0位置局部最小
        if (arr.length == 1) {
            return 0;
        }

        int N = arr.length;
        //====如果长度等于二，这两个if一定会返回===
        // 边界设置
        if (arr[0] < arr[1]) {
            return 0;
        }
        if (arr[N - 1] < arr[N - 2]) {
            return N - 1;
        }
        // =============
        // arr.length > 2
        int L = 0;
        int R = N - 1;
        int ans = -1;
        while (L <= R) {
            int mid = (L + R) / 2;
            //================旧写法====================
//            // 中间位置左右两边同时小
//            if (arr[mid] < arr[mid - 1] && arr[mid] < arr[mid] + 1) {
//                ans = mid;
//                break;
//            }
//            // 中间位置大于左边，那么直接放弃右边找左边的
//            if (arr[mid] > arr[mid - 1]) {
//                R = mid - 1;
//                continue;
//            }
//            // 中间位置大于右边，那么直接放弃左边找右边的
//            if (arr[mid] > arr[mid + 1]) {
//                L = mid + 1;
//                continue;
//            }
            // ========================================
            // 新写法

            // 中间位置左右两边同时小
            if (arr[mid] < arr[mid - 1] && arr[mid] < arr[mid] + 1) {
                ans = mid;
                break;
            } else {
                // 不同时小
                // 不同时小的情况有三种
                //  1.左 > mid mid < 右
                //  2.左 < mid mid < 右
                //  3.左 < mid mid > 右
                // 中间位置大于左边，那么直接放弃右边找左边的
                //  这个if的情况是2、3
                if (arr[mid] > arr[mid - 1]) {
                    R = mid - 1;
                } else {
                    //中间位置大于右边，那么直接放弃左边找右边的
                    //arr[mid] > arr[mid + 1] 一定大于
                    L = mid + 1;
                }
            }
        }
        return ans;
    }

    // 生成随机的数组,并且保证两个数之间要相邻不相等
    public static int[] randomArray(int maxLen, int maxValue) {
        int length = (int) (Math.random() * maxLen);
        int arr[] = new int[length];
        if (length > 0) {
            // 先把第一位的数随机出来
            arr[0] = (int) (Math.random() * maxValue);
            // 接下来从1位置的数开始生成，但是不能跟0位置的数一样
            for (int i = 1; i < length; i++) {
                do {
                    arr[i] = (int) (Math.random() * maxValue);
                    // 如果生成的数==前面那个数了，就重新生成，这样就能保证相邻不相等了
                } while (arr[i] == arr[i - 1]);
            }
        }
        return arr;
    }

    // 测试用
    public static boolean check(int[] arr, int minIndex) {
        // =0的情况局部最小返回的是-1
        if (arr.length == 0) {
            return minIndex == -1;
        }
        int left = minIndex - 1;
        int right = minIndex  + 1;
        // 如果生成的数组不越界，那就真的拿去比一下，如果越界了就可以认为他不破坏这个规则
        // 左边是否大于minIndex
        boolean leftBigger = left >= 0 ? arr[left] > arr[minIndex] : true;
        //                      如果是不越界真实的位置  并且右边的位置是否会大于局部最小位置
        boolean rightBigger = right < arr.length ? arr[right] > arr[minIndex] : true;
        return leftBigger && rightBigger;
    }

    public static void printArray(int[] arr) {
        for (int i : arr) {
            System.out.print(i + " ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        int maxLen = 10;
        int maxValue = 20;
        int testTime = 100000;
        System.out.println("测试开始");
        for (int i = 0; i < testTime; i++) {
            // 生成数组
            int[] arr = randomArray(maxLen, maxValue);
            int ans = onMinIndex(arr);
            boolean check = check(arr, ans);
            if (!check) {
                printArray(arr);
                System.out.println(ans);
                break;
            }
        }
        System.out.println("测试结束");
    }

}
```

执行结果为

![image-20240201132056711](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240201132056711.png) 

但是当我们将maxLen扩大的时候，发现会有下标数组越界的问题。

![image-20240201132137775](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240201132137775.png) 

问题是我们想要的是M-1位置和M+1位置还在L~R范围内，如果超过L~R了就会出现数组越界的问题。

 ![image-20240201132409399](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240201132409399.png) 



**会有一个问题，当二分到只剩两个了的时候，因为我们使用的条件都是mid左边和mid右边，如果只剩两个的时候会造成某一边没数据，导致数组下标越界，所以我们需要保证当只剩两位的时候直接比较这两位就行了，所以要限制这个数组三个数或三个数以上再判断**

解决的方式就是让L < R-1，限定一下L~R是三个数或者三个数以上在让他二分，如果不够三个数的话我们就单独验证这两个数谁是最小值返回。

修改过后的代码：

```java
    /**
     * arr整体无序
     * arr相邻的数不相等！
     * 解决数组越界问题
     * @param arr
     * @return
     */
    public static int onMinIndexAnswer(int[] arr) {
        // 如果只有一个数
        if (arr == null || arr.length == 0) {
            return -1;
        }

        // 一个数的时候默认0位置局部最小
        if (arr.length == 1) {
            return 0;
        }

        int N = arr.length;
        //====如果长度等于二，这两个if一定会返回===
        // 边界设置
        if (arr[0] < arr[1]) {
            return 0;
        }
        if (arr[N - 1] < arr[N - 2]) {
            return N - 1;
        }
        // =============
        // arr.length > 2
        int L = 0;
        int R = N - 1;
        while (L < R - 1) {
            int mid = (L + R) / 2;
            // 中间位置左右两边同时小
            if (arr[mid] < arr[mid - 1] && arr[mid] < arr[mid + 1]) {
               return mid;
            } else {
                if (arr[mid] > arr[mid - 1]) {
                    R = mid - 1;
                } else {
                    //中间位置大于右边，那么直接放弃左边找右边的
                    //arr[mid] > arr[mid + 1] 一定大于
                    L = mid + 1;
                }
            }
        }
        return arr[L] < arr[R] ? L : R;
    }
```



造成前面那版问题数组例子：[3,2,3,2,3]

![image-20230131210803135](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20230131210803135.png) 

![image-20240202152329741](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240202152329741.png) 



**二分不一定要有序，要再某一个规定下，比如：确定某一侧一定有就可以用二分法**



### 什么是常数操作



**等差数列求和公式**

 ![image-20240202152605744](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240202152605744.png)



#### **时间复杂度**

他是用来描述到底发生了几次常数操作的一个指标。

**常数操作就是他跟数据量没有关系，他就是固定时间的。**

**比如：int 1+1，int 100w + 100w这两个都是32位的整数这两个经历的过程是一样的。**

+、-、*、/、数组寻址等等都是常数操作，都是固定时间的。

当我们调用某一个语句的时候，他可能有些传参，调用的这一段语句是固定时间能完的，还是他是跟数据量有关的。如果他是跟数据量有关的语句他就不是一个常数操作，如果是跟数据量无关的操作他就是一个固定时间的操作。



### 什么是时间复杂度

以冒泡排序为例子：

![image-20240202153617056](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240202153617056.png) 

0-1之间谁大谁交换，我们先把这个时间设置为a操作，a是固定时间，后面的1-2，2-3.....这些都可以是常数操作，一共进行了7次交换。

![image-20240202153725245](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240202153725245.png) 

后续以此类推：7次、6次、5次......相当于是一个等差数列



### 等差数列求和公式

![image-20240202154006474](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240202154006474.png)

整个表达式中最高阶的东西就是他的时间复杂度。 

![image-20240202155653969](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240202155653969.png)

所以说冒泡排序就是复杂度为O(n^2)的算法。

复杂度不关心低阶项也不关心系数，他只关心最高阶是什么，这就叫做时间复杂度。



**为什么把时间复杂度做得怎么模糊呢**？

原因在于他就关心最高阶，当他的数据量很大的时候算法运行过程中的关系。



不管常数项多大，算法1的时间复杂度都是最高的

![image-20240202160056041](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240202160056041.png) 

不要系数，不要低阶项，因为如果n趋近于无穷，那么所有低阶项都变得不重要了，所以O(n)的算法就是比O(n^2)的算法好。

**决定这个算法运行时间的就是最高阶项的系数**。

所以时间复杂度是一个指标，他在于数据量很大的情况下，该怎么去描述算法时间之间的关系。



**二分的时间复杂度为：O(log2N),他会比O(N)低很多**



时间复杂度的概述图

![image-20240202160733742](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240202160733742.png) 

O(log2N)往往会忽略这个底，因为他比2大或者等于2，他出来的结果往往都会很小，所以可以忽略不计，后面默认都会写成O(logN)

常数:O(1)

估计时间复杂度用的都是最差的情况，要用怎么让这个流程最难受的情况来估计整个流程，假设最差情况。

![image-20240202161428729](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240202161428729.png)







### 什么是动态数组

规定长度之后不能再变的数组叫固定数组。

Java中的ArrayList就是动态数组。



### 动态数组使用和扩容

原来固定长度的时候，找到index位置的数的时间复杂度为O(1)固定时间的。



但是现在在ArrayList里面找index的数，这个行为中包含了另外一个行为就是扩容，扩容行为是否会影响ArrayList整体的表现？

当加入N个数的时候扩容行为的总代价是什么？（把数组扩容）

![image-20240219160408842](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240219160408842.png) 

扩容的过程为：1-2-4-8-16...-N

扩容代价为：1+2+4+8+16+...+N，这是一个等比数列，可以得出扩容的总代价为O(N)

加入N个数的时候代价为O(N)，那加入N个数的时候就是O(N)/N，均摊下来扩容代价到了某一步之后就变成了O(1)的一件小事。

所以总结：动态数组虽然有扩容，但是其实对于他的整体性能在时间复杂度的影响上是没有的，他做到了跟固定数组一样好还能支持动态扩容。但是并不是说他比固定数组就好，因为ArrayList当然会比固定数组要慢，但是这种慢只是常数时间的慢，从复杂度的角度来说的话是没有影响的。

所以从时间复杂度的角度上来说ArrayList和正常的固定数组一样还支持扩容，因为他的常数时间会比单纯的固定数组差一点，但是他只是不影响时间复杂度的差，在工程上我们几乎感觉不到。



### 哈希表和有序表的使用

在hash表中原生类型内部要值传递，非基础原生类型内部按照引用（内存地址作为key）传递。

以金庸为key他的所有作品为value，放到HashMap里面，问这条记录占用Hash表的字节数是多少

![image-20240219161643247](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240219161643247.png) 

答：金庸两个字的字节数+他所有作品的字节数



问HashMap里面的key和value都是Node对象，Key的Node里面放了个str为金庸，value的Node里面也有个str放了作品内容，问这个Hash表里面占用的字节数是多少

![image-20240219161754143](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240219161754143.png)

答：在hash表中他不会吧所有的字节都拷贝到hash表里面去，对于hash表来说你如果不是按值传递的，他在hash表空间占用的时候只是一个地址，所以两个node塞进去的话就是一个地址8字节、一个地址8字节，hash表的占用为16字节，不管你node占用多大，在hash表中就占用那么多。

![image-20240219162312778](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240219162312778.png) 





TreeMap<Integer,String>里面跟hash表一样，也是按值传递的。

但是他里面也很多工具方法。对于treeMap来说，内部会按照key排好序。

![image-20240219162455441](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240219162455441.png)

我们可以认为TreeMap上面的这些方法他的时间复杂度都是O(logN)级别的



如果是Node类型的呢？

有序表就不能直接用了，会报错，因为我们要求key一定要是可以比较的，如果不能比较是不被允许的。

![image-20240219162708201](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240219162708201.png)

如果你要自己定义接口的话，就需要自己去定义如何比较，不然用不了有序表。





## 单链表及其简单题目



### 介绍单链表和双链表

![image-20240219171709294](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240219171709294.png) 

### 单链表的反转

下面是一条链表，所谓的反转就是把指针全部都逆序了。

![image-20240219172137032](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240219172137032.png)



会有一个问题，当链表逆序之后，head引用要是还是指向a的话，后面的b,c,d都会不见，所以在这个情况下jvm会把这个链表给释放掉，因为没有任何引用去找到bcd。

![image-20240219172409513](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240219172409513.png)



所以我们需要写一个f()把头传进去Head = f(head)，我们在写这个函数的时候一定要写一个返回值，让这个头的值被使用，不然这个链表就会被当成垃圾回收。



任何一个引用都找不到剩下的空间，JVM会把它们认为是无用的，直接释放。**根可达**

![image-20240219172948264](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240219172948264.png)

单链表逆序代码

```java
public class RevertList {

    public static class Node {
        public int value;
        public Node next;

        public Node(int value) {
            this.value = value;
        }
    }
    
     /**
     * 单链表反转
     */
    public static Node reverseLinkedList(Node head) {

        Node pre = null;
        Node next = null;
        while (head != null) {

            next = head.next;
            head.next = pre;
            pre = head;
            head = next;
        }
        return pre;
    }
    public static void main(String[] args) {
        Node n1 = new Node(1);
        n1.next = new Node(2);
        n1.next.next = new Node(3);
        // 返回Head头部
        n1 = reverseLinkedList(n1);
        while (n1 != null) {
            System.out.print(n1.value + " ");
            n1 = n1.next;
        }
        System.out.println();
    }
 }
```



![image-20240219222312675](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240219222312675.png) 



### 双链表的反转

题目

![image-20240220130905419](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240220130905419.png) 



反转的结果：

![image-20240220131005368](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240220131005368.png)



双向链表的反转过程

![1](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/1.jpg) 

![2](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/2.jpg) 

![3](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/3.jpg) 

双向链表反转代码：

```java
public class RevertList {
   public static class DoubleNode {
        public int value;

        public DoubleNode last;

        public DoubleNode next;

        public DoubleNode(int value) {
            this.value = value;
        }
    }
   /**
     *  1-2-3-4-null
     *  1~2~3~4~null
     */
    /**
     * 双链表反转
     * @param head
     * @return
     */
    public static DoubleNode reverseDoubleLinkedList(DoubleNode head) {
        DoubleNode next = null;
        DoubleNode pre = null;
        while (head != null) {
            // 先把头的next节点记住
            next = head.next;
            head.next = pre;
            // 原先的last要反转指向next
            head.last = next;
            pre = head;
            head = next;
        }
        return pre;
    }
 }
```



### 用单链表结构实现队列

队列的话就是像排队一样先进先出，栈的话就像弹夹一样先进后出。

#### 队列

第一次插入

![image-20240220213629005](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240220213629005.png)

![image-20240220213859911](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240220213859911.png) 

**每加一个数都往尾巴加值，保证从head出发都可达**

![image-20240220215325926](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240220215325926.png) 



当所有的值都弹出之后，要让h和tail保持一致都为Null

![image-20240220215509718](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240220215509718.png) 



```java
package com.msb.arith2;

public class LinkedListToQueueAndStack {

    public static class Node<V> {

        public V value;
        public Node<V> next;

        public Node(V value) {
            this.value = value;
        }
    }

    public static class MyQueue<V> {
        private Node<V> head;
        private Node<V> tail;
        private int size;

        public MyQueue() {
            head = null;
            tail = null;
            size = 0;
        }

        public boolean isEmpty() {
            return size == 0;
        }

        public int size() {
            return size;
        }

        /**
         * 添加节点
         * @param value
         */
        public void offer(V value) {
            // 保证值一进来就先建出来一个节点
            Node<V> cur = new Node<V>(value);
            if (tail == null) {
                head = cur;
                tail = cur;
            } else {
                // 尾巴的next指针指向当前节点
                tail.next = cur;
                // 尾巴跳到当前节点位置
                tail = cur;
            }
            size ++;
        }

        /**
         * 弹出节点
         * @return
         */
        public V poll() {
            V ans = null;
            if (head != null) {
                // 从头开始弹出，先进先出的原理
                ans = head.value;
                head = head.next;
                size --;
            }
            // 当所有的值都弹出之后，要让h和tail保持一致都为Null
            if (head == null) {
                // 如果不这样释放，tail指向最后一个数，而h指向null，那这个tail就不会被释放，就是一个脏数据
                tail = null;
            }
            return ans;
        }

        public V peek() {
            V ans = null;
            if (head != null) {
                ans = head.value;
            }
            return ans;
        }

    }

}
```



#### 栈

压栈

![image-20240220221048333](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240220221048333.png)

弹出 

![image-20240220221158697](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240220221158697.png)



```java
public static class MyStack<V> {
        private Node<V> head;
        private int size;

        MyStack() {
            head = null;
            size = 0;
        }

        public boolean isEmpty() {
            return size == 0;
        }

        public int size() {
            return size;
        }

        public void push(V value) {
            Node<V> cur = new Node<>(value);
            if (head == null) {
                head = cur;
            } else {
                cur.next = head;
                head = cur;
            }
            size ++;
        }

        public V pop() {
            V ans = null;
            if (head != null) {
                ans = head.value;
                head = head.next;
                size --;
            }
            return ans;
        }

        public V peek() {
            return head != null ? head.value : null;
        }
    }
```





### 用双链表结构实现双端队列

可以头部加数据，头部出数据，也可以尾部加数据尾部出数据。

**![image-20240221130826911](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240221130826911.png) **



**单链表只支持头部加头部出，不支持尾部出，因为这样从尾部弹出的话会找不到之前的值。**

![image-20240221131038755](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240221131038755.png) 

代码示例：

```java
package com.msb.arith2;

/**
 * 双端链表队列
 */
public class DoubleLinkedListToDeque {

    public static class Node<V> {
        public V value;
        public Node<V> last;
        public Node<V> next;
        public Node(V v) {
            value = v;
            last = null;
            next = null;
        }
    }

    public static class MyDeque<V> {
        private Node<V> head;
        private Node<V> tail;
        private  int size;

        public MyDeque() {
            head = null;
            tail = null;
            size = 0;
        }

        public boolean isEmpty() {
            return size == 0;
        }

        public int size() {
            return size;
        }

        /**
         * 从头部加
         * @param value
         */
        public void pushHead(V value) {
            //当前节点
            Node<V> cur = new Node<V>(value);
            if (head == null) {
                head = cur;
                tail = cur;
            } else {
                // 新进来的next指针指向head
                cur.next = head;
                // 老的head的上一个节点last指针指向新进来的节点
                head.last = cur;
                // 因为cur的last指针没设置，那就默认指向Null
                // 头调到当前节点上去
                head = cur;
            }
            size ++;
        }

        /**
         * 尾巴加入
         * @param value
         */
        public void pushTail(V value) {
            //当前节点
            Node<V> cur = new Node<V>(value);
            if (head == null) {
                head = cur;
                tail = cur;
            } else {
                tail.next = cur;
                cur.last = tail;
                tail = cur;
            }
            size ++;
        }
    }
}

```





### K个节点的组内逆序调整

一个单向链表，给你一个k值如果是3，请把这个链表按照三个三个分组，不足3个的不管他，然后每组给他逆序调整

比如:

1-2-3-4-5-6-7-8

123一组456一组 78 不管他结果应该为

3-2-1-6-5-4-7-8这样的链式结构

![image-20240222192347369](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240222192347369.png)



**给定链表的开始节点，数到第k位把第k位的数据返回。**

```java
public static ListNode getGroupEnd(ListNode start, int k) {
                        // --k调到null就没有值了
        while (--k !=0 && start != null) {
            start = start.next;
        }
        return start;
    }
```

![image-20240223131030455](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240223131030455.png)

start != null

![image-20240223131205446](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240223131205446.png)

reverse函数功能为

![image-20240223131525600](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240223131525600.png)

先把s的next指针指向null，然后其他的指针除了k以外统一都往回指，并且在e往回值之前先把k的位置记住

![image-20240223131643000](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240223131643000.png) 

再让s的next指针指向k

![image-20240223131702444](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240223131702444.png) 





为什么要让end先往前一步，是因为当完成了开始和结束之后要把连表反过来指向。
// a-b-c-d-f ， 要把abcd反过来，要让a指向f这个工作，所以才要记这个位置。

因为到了e才停，而abcd这几个都是要干事的

1、

![image-20240225131017849](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240225131017849.png)

2、

![image-20240225131735156](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240225131735156.png)

3、

![image-20240225131753152](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240225131753152.png)



![image-20240225131806970](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240225131806970.png)

相关实现代码：

```java
package com.msb.arith2;

/**
 * K个节点的组内逆序调整
 * 一个单向链表，给你一个k值如果是3，请把这个链表按照三个三个分组，不足3个的不管他，然后每组给他逆序调整
 * 比如:
 * 1-2-3-4-5-6-7-8
 * 123一组456一组 78 不管他结果应该为
 * 3-2-1-6-5-4-7-8这样的链式结构
 */
public class ReverseNodesInKGroup {
    public static class ListNode {
        private ListNode next;
        private int size;

        public ListNode(ListNode next) {
            this.next = next;
        }
    }
    /**
     * 给定链表的开始节点，数到第k位把第k位的数据返回。
     * @param start
     * @param k
     * @return
     */
    public static ListNode getGroupEnd(ListNode start, int k) {
                        // --k调到null就没有值了
        while (--k !=0 && start != null) {
            start = start.next;
        }
        return start;
    }
    public static void reverse(ListNode start, ListNode end) {
        // 这里为什么要让他指向下一个节点是因为当完成了开始和结束之后要把链表反过来指向。
        // a-b-c-d-f // 要把abcd反过来，要让a指向f这个工作，所以才要记这个位置。
        end = end.next;
        ListNode pre = null;
        ListNode cur = start;
        ListNode next = null;
        while (cur != end) {
            next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        start.next = end;
    }
}
```



主逻辑的使用：

如果K=3

![image-20240226162803617](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240226162803617.png)

直接把头部定义为end节点，因为最终肯定都是要反向的，所以直接定end为head，新head一直都不动

![image-20240226163104459](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240226163104459.png)

反转

![image-20240226163155340](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240226163155340.png)



反转完后上一组的结尾节点lastStart为a

![image-20240226163307421](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240226163307421.png)

定义新一组的开头为上一组结尾节点的next

![image-20240226163453630](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240226163453630.png)

然后开始进行下一组的反转，因为k=3所以end蹦到了f

![image-20240226163700529](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240226163700529.png)

再反转

![image-20240226163800679](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240226163800679.png)

上一个节点的next指针指向这一回的end。

![image-20240226163859913](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240226163859913.png)

![image-20240226163925848](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240226163925848.png)

```java
/**
     * 主逻辑的使用
     *
     * @param head
     * @param k
     * @return
     */
    public static ListNode reverseKGroup(ListNode head, int k) {
        ListNode start = head;
        // 获取到k的一组的结束节点
        ListNode end = getGroupEnd(start, k);
        // 第一组都凑不齐直接返回老头部
        if (end == null) {
            return head;
        }
        // 第一组凑齐了，因为最终肯定是end为头结点，
        // 所以直接调整，head后续都不会动了，返回也是返回新头部
        head = end;
        // 反转
        reverse(start, end);
        // 上一组的结尾节点就是start
        ListNode lastEnd = start;
        while (lastEnd.next != null) {
            // 定义新一组的开头为上一组结尾节点的next
            start = lastEnd.next;
            end = getGroupEnd(start, k);
            if (end == null) {
                return head;
            }
            reverse(start, end);
            lastEnd.next = end;
            lastEnd = start;
        }
        // 正好是k的整数倍，直接返回
        return head;
    }
```



### 两个链表相加

算法题：

![image-20240227131139876](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240227131139876.png) 

这种题目的思路就是先把长链表和短链表找到，把他们区分开来。

例题：

3-4-6-1
7-9-7

![image-20240227131601495](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240227131601495.png) 

整个过程分三步走

1、L有、S有

2、S无、L有

3、S无、L无

![image-20240228130313131](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240228130313131.png)

因为两链表相加有进位，所以我们要准备一个进位信息。



例题1：

**第一阶段L有S也有**

![image-20240228130550580](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240228130550580.png)

3+7+0=10 % 10 = 0，所以有进位=1



![image-20240228130743289](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240228130743289.png)



![image-20240228130827351](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240228130827351.png)



**第二阶段，只有长链表有的阶段，S无L有**

只剩下最后一位和进位是1 的数，相加之后得出的结果为2，进位信息改为0

![image-20240228130948947](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240228130948947.png)

**第三阶段，L和S都无发现进位信息为0，直接返回**

![image-20240228131046046](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240228131046046.png)

**2440**

例题2：

**第一阶段**

![image-20240228131121070](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240228131121070.png)



![image-20240228131224071](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240228131224071.png)

![image-20240228131243153](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240228131243153.png)

![image-20240228131257316](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240228131257316.png)

**第二阶段**

![image-20240228131328396](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240228131328396.png)

![image-20240228131344204](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240228131344204.png)

![image-20240228131351937](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240228131351937.png)

第三阶段：

**进位为0，前面不要补节点**

![image-20240228131418826](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240228131418826.png) 

还有一题

![image-20240228131526918](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240228131526918.png)

代码实现：

```java
package com.msb.arith2;

/**
 * 两个链表相加
 */
public class AddTwoNumbers {


    public static class ListNode {
        private ListNode next;
        private int value;
        public ListNode(int value) {
            this.value = value;
        }
    }

    public static ListNode addTwoNumbers(ListNode head1, ListNode head2) {
        int len1 = listLength(head1);
        int len2 = listLength(head2);
        // 长短链表重定向·
        // 较长链表
        ListNode l = len1 >= len2 ? head1 : head2;
        // 较短链表
        ListNode s = l == head1 ? head2 : head1;
        ListNode curL = l;
        ListNode curS = s;
        ListNode last = curL;
        // 进位
        int carry = 0;
        // 相加的值
        int curNum = 0;
        // 第一阶段，长链表有，短链表也有
        // 短链表为空的时候第一阶段才结束
        while (curS != null) {
            // 相加的值为 长链表的值 + 短链表的值 + 进位信息
            curNum = curL.value + curS.value + carry;
            // 这里改长链表的值是复用长链表，而不是重新生成一个链表来存放，减少空间复杂度
            curL.value = (curNum % 10);
            carry = curNum / 10;
            // 长链表结束的标记位
            last = curL;
            curL = curL.next;
            curS = curS.next;
        }
        // 第二阶段，长链表有，短链表没有
        while (curL != null) {
            curNum = curL.value + carry;
            curL.value = (curNum % 10);
            carry = curNum / 10;
            last = curL;
            curL = curL.next;
        }
        // 第三阶段，
        // 长链表和短链表都没有，
        // 查看进位有没有，有的话就在这个链表后面补一个
        if (carry != 0) {
            last.next = new ListNode(1);
        }
        return l;
    }

    /**
     * 求链表长度
     * @param head
     * @return
     */
    public static int listLength(ListNode head){
        int len = 0;
        while (head != null) {
            len ++;
            head = head.next;
        }
        return len;
    }

}

```





### 位图的功能

拿每一位byte作为图像

节省空间，用位来代替数。

**可以做出一个集合，如果数字范围是非常确定的，最大值很确定，我们就可以用位图来实现收集数字来告诉我们这个数存在不存在**

**他的好处就是可以极大的压缩空间。**



### 位图的实现

以long数组来定义，8字节-64bit-64位

一个数右移6位相当于除了64

```java
public BitMap(int max) {
    // 右移6位 是除以64(2^6)的意思
    // (max+64) >> 6 -> (max+64) / 64
    bits = new long[(max + 64) >> 6];
}
```

例题：long a = 170这个数想要定位是第几个证书拥有这个170

arr[i]

第0个整数拥有的是0~63这些数

第1个整数拥有的是64~127这些数

第2个整数拥有的是128~191这些数

所以170属于哪个整数其实就是170/64 = 2

![image-20240301131244122](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240301131244122.png)

那这个170到底是这个整数的第几位呢？

170%64 从右往左数



num >> 6 -> num / 64 --> 定位到哪个整数
num % 64 -> num & 63

为什么？

num%64虽然是能实现，但是%的运算是比较慢的

为什么说他num % 64 -> num & 63

因为63是01111111

例题：



![image-20240303143410094](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240303143410094.png)

110110这个就代码num%64的结果

让num&63  结果跟 num % 64是一样的

![image-20240303143908619](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240303143908619.png)

![image-20240303143942519](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240303143942519.png)

为什么只选7位呢？

因为0~63是只选7位的

所以num%64的结果就是只保留后7位的状态，前面的其他位置都是0，所以他就等同于&63，因为63后7位都是1，并且全1则1,

比如：

0 1 0 1 1 1 0 1 1 0 1 1 - num

0 0 0 0 0 1 1 1 1 1 1 1 - 63

上下两个数&一下 就是 1011011 所以 %64就等同于 &63 他们得到的结果都是一样的

&63的效率一定会比%64的效率快很多。

位运算的效率会比正常的 + - * / 快10倍往上。



找到第几个整数或上第几位是描述num的，把他移到那个位置之后(1L <<)把他或到里面去，相当于把num标上了

```java
        public void add(int num) {
            // num >> 6 -> num / 64 --> 定位到哪个整数
            // num % 64 -> num & 63 num模64就是num与上63
            //该找到的第几号整数     第几位是描述num的
            bits[num >> 6] |= (1L << (num & 63));
            // 找到第几个整数或上第几位是描述num的，把他移到那个位置之后(1L <<)把他或到里面去，相当于把num标上了
        }
```

add 例题：

先定位是第几个整数：170 % 64 = 2 那就是第二个整数

再定位这个运算在arr[2]里面是第几位：170 % 64  = 42位

找到第二个整数arr[2]，所以在arr[2]里面我们要想办法把第42位的数标1，这样就代表170进去了。

arr[2] = arr[2] |(1<< 42)  --可以写成-->   arr[2] |= (1 << 42)

假如这个数组原始都为0，而把1向左移动42位，把他们两个或一下就等同于第42位上进去了1，再把他赋值到这个arr[2]数组上去。



delete例题：

同上，add是要给他把1填上，那删除的话就是在这个基础上把他改成0，就等同于把这一位删了。



例题：

比如arr只有10位，把第三位的1去掉

![image-20240303152716229](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240303152716229.png) 

与的情况就是

1 0 1 1 0 1 1 0 1 1 

1 1 1 1 1 1 0 1 1 1 

1 0 1 1 0 1 0 0 1 1

上面 两个数与一下就相当于把第三位 数变成0

我们操作1的话要把1向左移动3位 0 0 0 0 0 0 1 0 0 0出现了这个数，然后把这个数给他取给反~，就变成了 1 1 1 1 1 1 0 1 1 1 

```java
        public void delete(int num) {
            bits[num >> 6] &= ~(1L << (num & 63));
        }
```

![image-20240303154432575](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240303154432575.png) 

查一个数

例题：

跟上面是一样的，170 找第二个数arr[2] ，查第42位，如果他是1就说明存在，如果他是0就说明不存在

让他&第42位是1，其他都是0的值，如果&完的结果 !=0则说明第42位是1，如果等于0那就说明第42位是0

```java
public boolean contains(int num) {
    return (bits[num >> 6] & (1L << (num & 63))) != 0;
}
```



完整代码：

```java
package com.msb.arith3;

import java.util.HashSet;

/**
 * 位图的实现
 */
public class Code02_BitMap {

    public static class BitMap {
        //int 4字节 32bit 32位
        //long 8字节 64bit 64位
        private long[] bits;

        public BitMap(int max) {
            // 右移6位 是除以64(2^6)的意思
            // (max+64) >> 6 -> (max+64) / 64
            bits = new long[(max + 64) >> 6];
        }

        public void add(int num) {
            // num >> 6 -> num / 64 --> 定位到哪个整数
            // num % 64 -> num & 63 num模64就是num与上63
            //该找到的第几号整数     第几位是描述num的
            bits[num >> 6] |= (1L << (num & 63));
            // 找到第几个整数或上第几位是描述num的，把他移到那个位置之后(1L <<)把他或到里面去，相当于把num标上了
        }
        public void delete(int num) {
            bits[num >> 6] &= ~(1L << (num & 63));
        }
        public boolean contains(int num) {
            return (bits[num >> 6] & (1L << (num & 63))) != 0;
        }
    }

    public static void main(String[] args) {
        Integer max = 10000;
        System.out.println("测试开始!");
        BitMap bitMap = new BitMap(max);
        HashSet<Integer> set = new HashSet<>();
        int testTime = 1000000;
        for (int i = 0; i < testTime; i++) {
            int num = (int) (Math.random() * (max + 1));
            double decide = Math.random();
            if (decide < 0.333) {
                bitMap.add(num);
                set.add(num);
            } else if (decide < 0.666) {
                bitMap.delete(num);
                set.remove(num);
            } else {
                if (bitMap.contains(num) != set.contains(num)) {
                    System.out.println("Oops!");
                    break;
                }
            }
        }
        for (int num = 0; num <= max; num ++) {
            if (bitMap.contains(num) != set.contains(num)) {
                System.out.println("Oops!");
            }
        }
        System.out.println("测试结束!");
    }

}
```

错题示范：

下面代码中可以看到，用到的是1来向左移动，因为如果只拿1移动42位的话如果不加L的话他会认为1只有32位，这样他就拿不到移动42位正确的结果了，所以一定要写1L移动42位，因为单独的1没有64位只有32位，单独写1默认都是认为是整型。

![image-20240303233823057](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240303233823057.png)

完整代码：

```java
package com.msb.arith3;

import java.util.HashSet;

/**
 * 位图的实现
 */
public class Code02_BitMap {

    public static class BitMap {
        //int 4字节 32bit 32位
        //long 8字节 64bit 64位
        private long[] bits;

        public BitMap(int max) {
            // 右移6位 是除以64(2^6)的意思
            // (max+64) >> 6 -> (max+64) / 64
            bits = new long[(max + 64) >> 6];
        }

        public void add(int num) {
            // num >> 6 -> num / 64 --> 定位到哪个整数
            // num % 64 -> num & 63 num模64就是num与上63
            //该找到的第几号整数     第几位是描述num的
            bits[num >> 6] |= (1L << (num & 63));
            // 找到第几个整数或上第几位是描述num的，把他移到那个位置之后(1L <<)把他或到里面去，相当于把num标上了
        }
        public void delete(int num) {
            bits[num >> 6] &= ~(1L << (num & 63));
        }
        public boolean contains(int num) {
            return (bits[num >> 6] & (1L << (num & 63))) != 0;
        }
    }

    public static void main(String[] args) {
        Integer max = 10000;
        System.out.println("测试开始!");
        BitMap bitMap = new BitMap(max);
        HashSet<Integer> set = new HashSet<>();
        int testTime = 1000000;
        for (int i = 0; i < testTime; i++) {
            int num = (int) (Math.random() * (max + 1));
            double decide = Math.random();
            if (decide < 0.333) {
                bitMap.add(num);
                set.add(num);
            } else if (decide < 0.666) {
                bitMap.delete(num);
                set.remove(num);
            } else {
                if (bitMap.contains(num) != set.contains(num)) {
                    System.out.println("Oops!");
                    break;
                }
            }
        }
        for (int num = 0; num <= max; num ++) {
            if (bitMap.contains(num) != set.contains(num)) {
                System.out.println("Oops!");
            }
        }
        System.out.println("测试结束!");
    }

}
```



### 位运算知识点扩展

在使用位运算实现加法时，除了理解异或运算（XOR）可以用来进行无进位相加之外，还有几个关键的知识点：

1. **进位的处理**:
   - 位与运算（AND）用来确定哪些位在加法时会产生进位。
   - 进位结果需要左移一位，因为在二进制加法中，进位总是影响到下一位。

2. **循环或递归**:
   - 需要不断重复无进位加法和进位处理的步骤，直到没有新的进位产生。这个过程可以通过循环或递归实现。

3. **整数溢出**:
   - 在实际的程序中，需要注意整数溢出的问题。在某些编程语言中，当整数超过其表示范围时，它可能会回绕（wrap around）。
   - 对于有符号整数，需要特别注意符号位的处理，确保加法操作不会导致意外的符号变化。

4. **负数的表示（补码）**:
   - 在计算机系统中，负数通常使用补码形式表示。这意味着，要得到一个负数的位表示，你需要取其正值的位反码（每一位取反），然后加1。
   - 补码表示法允许加法和减法使用相同的硬件来实现，同时也简化了溢出的处理。

5. **位运算的性质**:
   - 异或运算具有一些特别的性质，比如自反性（\(a \oplus a = 0\)）和交换律（\(a \oplus b = b \oplus a\)），这些性质在位运算实现加法时非常有用。

6. **算术右移与逻辑右移**:
   - 在处理有符号整数时，算术右移（保留符号位）和逻辑右移（不保留符号位）的区别可能会影响到算法的行为。

7. **无符号与有符号的处理差异**:
   - 对于无符号整数，进位和溢出可以用相同的方式处理；但对于有符号整数，需要考虑符号位的影响。

理解这些知识点对于使用位运算实现加法至关重要。正确处理这些细节可以确保算法在不同的编程环境和不同类型的整数（无符号和有符号）上都能正常工作。



### 怎么使用位运算进行加减乘除

**其实使用代码的加减乘除在计算机底层一定都是用位运算实现的**。

位运算的加减乘除都是比手写的加减乘除快的。

但是用位运算在java里面实现加减乘除反而不如java自身原带的加减乘除快。



举个例子：

a = 46 ->  32 + 8 + 4 + 2 -> 二进制形式为：0101110

b =20 -> 16 + 4 -> 二进制形式为：               0010100

![image-20240306131553442](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240306131553442.png)



**异或运算^就是无进位相加**：

![image-20240306131939067](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240306131939067.png) 



a ^ b 无进位相加

![image-20240306132134240](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240306132134240.png) 

a和b的进位是什么

a & b 的结果在向左移动一位就是进位信息

![image-20240306132443896](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240306132443896.png) 





![image-20240307131720928](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240307131720928.png)



**原始的a+b是不是就等同于 a + b无进位相加的结果加上进位信息的结果，也就是a ^b + 进位信息。**

例子: a = 46，b = 20

a^b不进位相加的数58

a 0101110

b 0010100 ^

——————

​    0111010   = 58

a&b再进一位，进位信息的结果为8

a 0101110

b 0010100

——————

​    0000100

<< 1(向左移动一位)

​     0001000   = 8

所以原始的原始的a =46,b=20可以等同于

a'	0111010

b'	0001000

相当于是a' + b'

所以 a' + b'

a'^b'

a'	0111010

b'	0001000 ^

——————————

​		0110010



a'&b'

a'	0111010

b'	0001000 &

——————————

​		0001000

<< 1

——————————

​		0010000

所以原始的a'+b'就等同于

0110010+0010000

![image-20240307132941177](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240307132941177.png) 



a''	0110010

b''	0010000	^

————————————

​		0100010



a''	0110010

b''	0010000	&

————————————

​		0010000

<<	1

————————————

​		0100000



a'''	0100010

b'''	0100000	^

————————————

​		0000010



a'''	0100010

b'''	0100000	&

————————————

​		0100000

<<1

————————————

​		1000000



a''''	0000010

b''''	1000000	^

————————————

​		1000010



a''''	0000010

b''''	1000000	&

————————————

​		0000000

<<1

————————————

​		0000000

**什么时候进位补偿没了得出来的a就是答案，也就是上面的a'''':1000010=66**

**就让他们一直按照上面的方式来操作，总有进位信息消失的时候，等什么时候进位信息没了，无进位信息就是答案**

**计算机里面实现的加法就是上面的这套流程。**





### 使用位运算实现加法

```java
    public static int add(int a, int b) {
        int sum = a;
        // 为什么要递归的原因是因为无论如何都不能出现+号
        while (b != 0) {
            //计算a,b无进位相加的信息
            sum = a ^ b;
            // 计算进位信息赋值给b -> b'(等同于进位信息)
            b = (a & b) << 1;
            // a -> a' 无进位相加信息
            a = sum;
        }
        // 等到b的进位信息消失，就得出了最终结果
        return sum;
    }
```



### 使用位运算实现减法

a-b相当于是a + b的相反数

b的相反数相当于 ~b+1，但是我们的实现是不能出现加减号的，所以需要有替换

替换成：add(a, add(~b, 1))

```java
    /**
     * 使用位运算实现减法
     * 相当于是加上 b的相反数~b+1
     * 但是我们不能出现加号
     * 所以要变成
     * b的相反数是add(~b, 1)
     * <p>
     * 所以a-b为 add(a, add(~b,1))
     *
     * @param a
     * @param b
     * @return
     */
    public static int minus(int a, int b) {
        return add(a, negNum(b));
    }

```



### 使用位运算实现乘法

例子：

b一开始不等于0

![image-20240313132040500](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240313132040500.png) 





b&1之后不等于0，说明此时最末尾有1，所以就把当前的结果算到ans里面去

![image-20240313132110731](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240313132110731.png)

![image-20240313132257722](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240313132257722.png) 



a左移一位，b不带符号右移一位

![image-20240313132402605](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240313132402605.png) 

![image-20240313132414658](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240313132414658.png) 



b&1之后不等于0说明当前的a不用加到ans上面

![image-20240313132513397](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240313132513397.png)

然后a左移，b不带符号右移

![image-20240313132558352](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240313132558352.png) 



b&1不等于0，把当前的a放到ans里面

![image-20240313132627858](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240313132627858.png) 



然后a右移一位，b不带符号左移一位

![image-20240313132719658](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240313132719658.png) 

b等于0，直接返回ans。

```java
/**
     * 使用位运算实现乘法
     * @param a
     * @param b
     * @return
     */
    public static int multi(int a, int b) {
        int res = 0;
        while (b != 0) {
            if ((b & 1) != 0) {
                res = add(res, a);
            }
            // 左移一位
            a <<= 1;
            // 不带符号右移一位
            // 为什么要不带符号右移呢
            // 因为如果是b>>1的话他的左边就会拿符号位补，
            // 如果是负数的话左边的数就都是用1补，这样子代码就跑不完了。
            b >>>= 1;
        }
        return res;
    }
```





### 使用位运算实现除法

a/b，思路就是把这个b移动到最接近a的时候，但是又不比a大

![image-20240314131229766](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240314131229766.png)

![image-20240314131439353](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240314131439353.png)



![image-20240314131532291](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240314131532291.png) 

然后再把b移动到最接近a的数，得出最终结果

![image-20240314131604747](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240314131604747.png) 

疑问？结果的那两个1是怎么来的？



换过一题：
如果a/b=c的话，a是未知,b=00110,如果得到的结果c是01100,说明了 ，c=  0    1     1     0    0
																															 2^4 2^3 2^2 2^1 2^0

并且表达式可以理解为是:a=2^3 *b + 2^2*b，因为当我们算b * c的时候就等同于b * 4 + b * 8  也就是 b * 2^2+b * 2^3



所以当b为 01100和c为01110的时候，a相当于是他们两相乘。（注意下图和上面文字并不是一题）

![image-20240322132210806](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240322132210806.png)

所以需要反推， a - 2^? * b减完之后剩下的值是a'，再减去一个最近的 a' - 2^? * b，再减去最近的a'' - 2 ^? *b 这样依次的往下减，就得到了a的结果了。

![image-20240322132741441](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240322132741441.png)



再来一题：

![image-20240322132814287](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240322132814287.png)



b*c 因为第二位有1，则向左移动一位，得出的结果为 0 1 1 1 0 0，等同于b * 2，第三步相当于b * 4

![image-20240322192511877](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240322192511877.png) 













## 算法题



### 判断是否是平衡搜索二叉树

 原LeetCode110题

```
https://leetcode.cn/problems/balanced-binary-tree
```

**平衡树：在这棵树中，每一棵子树要满足，左树的高度和他右树的高度相差不超过1   <=1**

思路：

例如：我们想判断以x为头的数是不是平衡的？那么就得保证

1. x的左树整体都是平衡的，如果左树上有某个节点违反了规则的话，那整个树就都违反了，所以要让左树整体都是平衡树，右树也都是平衡树，当这两个条件满足之后，在判断左树和右树的高度超是否<=1，如果满足条件的话那x的整棵树就是平衡树。











### LeetCode102：二叉树按层遍历并收集节点

```java
package com.msb.arith5;

import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

/**
 * 二叉树的层序倒叙遍历
 * 给你二叉树的根节点 root ，返回其节点值的 层序遍历 。
 * （即逐层地，从左到右访问所有节点）。
 *输入：root = [3,9,20,null,null,15,7]
 * 输出：[[15,7],[9,20],[3]]
 * 示例 2：
 *
 * 输入：root = [1]
 * 输出：[[1]]
 * 示例 3：
 *
 * 输入：root = []
 * 输出：[]
 * 提示：
 *
 * 树中节点数目在范围 [0, 2000] 内
 * -1000 <= Node.val <= 1000
 */
public class LeetCode102 {

    public class TreeNode {
        private int val;
        private TreeNode left;
        private TreeNode right;
    }

    class Solution {
        public List<List<Integer>> levelOrder(TreeNode root) {
            List<List<Integer>> ans = new LinkedList<>();
            if (root == null) {
                return ans;
            }
            Queue<TreeNode> curTreeQueue = new LinkedList<>();
            curTreeQueue.add(root);
            while (!curTreeQueue.isEmpty()) {
                int size = curTreeQueue.size();
                List<Integer> curList = new LinkedList<>();
                for (int i = 0; i < size; i++) {
                    TreeNode cur = curTreeQueue.poll();
                    curList.add(cur.val);
                    if (cur.left != null) {
                        curTreeQueue.add(cur.left);
                    }
                    if (cur.right != null) {
                        curTreeQueue.add(cur.right);
                    }
                }
                ans.add(0, curList);
            }
            return ans;
        }
    }
}

```

**收集到每层的size,一次操作多少条数据进去,这一层就可以结束了。**
**queue是动态加的因为他是通过poll方法弹出的,弹出之后会将数的左孩子和右孩子都加进去，我们只要size对了，最终的结果就一定对**

**因为queue是动态的，所以不能使用queue.size来进行for循环，后面会往队列里面加数据的，这样会死循。**
**Queue 是一个接口，因为LinkedList实现的是Queue。**

**在java中Stack这个结构是比较坑的一个结构，他是可以自己实例化的，我们也可以像栈一样使用他，但是这个东西在用的时候java里面自己的实现是比较慢的，所以能用栈实现的东西，要是像优化执行时间的话别用这个Stack。**

**可以使用LinkedList双端队列来实现。**
**因为他是一个双端队列，他每次都是头进尾出的，类似栈的先进后出的概念。可以替代栈的实现功能。**



Stack用LinkedList进行替换

```java
    public static void main(String[] args) {

        Stack stack = new Stack();
        stack.add(1);
        stack.add(2);
        stack.add(3);
        while (!stack.isEmpty()) {
            System.out.println(stack.pop());
        }
        System.out.println("==============");
        LinkedList<Integer> linkedList = new LinkedList<>();
        // 用LinkedList尾巴加尾巴弹
        linkedList.addLast(1);
        linkedList.addLast(2);
        linkedList.addLast(3);
        while (!linkedList.isEmpty()) {
            System.out.println(linkedList.pollLast());
        }
    }
```

![image-20240629130252084](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240629130252084.png)

压测一下

```
int testTime = 100000;
```

```java
   public static void main(String[] args) {
        // 压测
        long start = System.currentTimeMillis();
        Stack stack = new Stack();
        int testTime = 1000000;
        for (int i = 0; i < testTime; i++) {
            stack.add(i);
        }
        while (!stack.isEmpty()) {
            stack.pop();
        }
        long end = System.currentTimeMillis();
        System.out.println(end - start);
        System.out.println("==============");
        start = System.currentTimeMillis();
        LinkedList<Integer> linkedList = new LinkedList<>();
        for (int i = 0; i < testTime; i++) {
            // 用LinkedList尾巴加尾巴弹
            linkedList.addLast(i);
        }
        while (!linkedList.isEmpty()) {
            linkedList.pollLast();
        }
        end = System.currentTimeMillis();
        System.out.println(end - start);
   }
```

![image-20240629131048106](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240629131048106.png)

**Java里面实现的Stack有点拉，可以用LinkedList去替代里面的方法，会比Stack快。但是如果量高了之后LinkedList的速度就慢下来了**

```
int testTime = 10000000;
```

![image-20240629131239219](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240629131239219.png)



所以还有一种最快的，但是就是需要条件了，如果你明确的知道你的长度是多长，就可以用数组来实现栈。

![image-20240629130544950](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240629130544950.png) 

```java
    public static void main(String[] args) {

//        Stack stack = new Stack();
//        stack.add(1);
//        stack.add(2);
//        stack.add(3);
//        while (!stack.isEmpty()) {
//            System.out.println(stack.pop());
//        }
//        System.out.println("==============");
//        LinkedList<Integer> linkedList = new LinkedList<>();
//        // 用LinkedList尾巴加尾巴弹
//        linkedList.addLast(1);
//        linkedList.addLast(2);
//        linkedList.addLast(3);
//        while (!linkedList.isEmpty()) {
//            System.out.println(linkedList.pollLast());
//        }
        // 压测
        System.out.println("===========栈自己==========");
        long start = System.currentTimeMillis();
        Stack stack = new Stack();
        int testTime = 10000000;
        for (int i = 0; i < testTime; i++) {
            stack.add(i);
        }
        while (!stack.isEmpty()) {
            stack.pop();
        }
        long end = System.currentTimeMillis();
        System.out.println(end - start);
        System.out.println("=======LinkedList替代=======");
        start = System.currentTimeMillis();
        LinkedList<Integer> linkedList = new LinkedList<>();
        for (int i = 0; i < testTime; i++) {
            // 用LinkedList尾巴加尾巴弹
            linkedList.addLast(i);
        }
        while (!linkedList.isEmpty()) {
            linkedList.pollLast();
        }
        end = System.currentTimeMillis();
        System.out.println(end - start);
        System.out.println("===========数组替代==========");
        //使用数组替代
        int stack2[] = new int[testTime];
        int index = 0;
        start = System.currentTimeMillis();
        for (int i = 0; i < testTime; i++) {
            stack2[index++] = i;
        }
        while (index!=0) {
            int a = stack2[--index];
        }
        end = System.currentTimeMillis();
        System.out.println(end - start);
    }
```

![image-20240629131624880](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240629131624880.png) 









### 判断是否是搜索二叉树

LeetCode98

以x为轴的数，怎么样才判断为搜索二叉树。

**左树如果是搜索二叉树，右树也是搜索二叉树，那左树的最大值肯定小于x，右树的最小值大于x，如果这些条件都成立那整棵树就是搜索二叉树，有任何一个违反都是不行的**

题解：

```java
class Solution {

    public boolean isValidBST(TreeNode root) {
        return process(root).isBST;
    }

    public static class Info {
        // 要让递归函数同等权
        private boolean isBST;
        private int max;
        private int min;

        public Info(boolean isBST, int max, int min) {
            this.isBST = isBST;
            this.max = max;
            this.min = min;
        }
    }

    public static Info process(TreeNode x) {

        if (x == null) {
            return null;
        }

        Info leftInfo = process(x.left);
        Info rightInfo = process(x.right);

        int max = x.val;
        int min = x.val;

        if (leftInfo != null) {
            max = Math.max(leftInfo.max, max);
            min = Math.min(leftInfo.min, min);
        }

        if (rightInfo != null) {
            max = Math.max(rightInfo.max, max);
            min = Math.min(rightInfo.min, min);
        }

        boolean isBST = true;
        // 两棵树有一颗不满足则不是搜索二叉树
        if (leftInfo != null && !leftInfo.isBST) {
            isBST = false;
        }
        if (rightInfo != null && !rightInfo.isBST) {
            isBST = false;
        }
        // 判断是否为搜索二叉树
        // 比左树的最大值大
        boolean maxLeftLessX = leftInfo == null ? true : (leftInfo.max < x.val);
        // 比右树的最小值小
        boolean minRightMoreX = rightInfo == null ? true : (rightInfo.min > x.val);
        if (!maxLeftLessX || !minRightMoreX) {
            isBST = false;
        }
        return new Info(isBST, max, min);
    }

}
```





### LeetCode112：能否组成路径和

LeetCode 112

```
https://leetcode.cn/problems/path-sum/description/
```

是否存在某个路径可以搞出一个规定好的累加和出来，路径必须头结点开始叶节点结束。

**路径必须从头结点开始叶节点结束才叫路径**

![image-20240710131544973](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240710131544973.png) 

1、如果x为空的时候他的上游不一定是叶节点，也有可能是根节点

![image-20240716195226362](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240716195226362.png) 



![image-20240716195757011](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240716195757011.png)



如果大于sum不用判断直接false返回可以吗？

不可以，因为如果树上的值有负值的话就没办法成立了。

![image-20240716200454097](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240716200454097.png) 

```java
package com.msb.arith5;


/**
 * 路径总和LeetCode112题
 * https://leetcode.cn/problems/path-sum/description/
 * 路径必须从头结点开始叶节点结束才叫路径
 * 给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。
 * 判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。
 * 如果存在，返回 true ；否则，返回 false 。
 * 叶子节点 是指没有子节点的节点。
 */
public class Code03_LeetCode112_PathSum {

    public static class TreeNode{
        private TreeNode left;
        private TreeNode right;
        private int val;

        public TreeNode(int val) {
            this.val = val;
        }
    }

    // 只关心到叶节点的时候判断是否修改
    public static boolean isSum = false;


    public boolean hasPathSum(TreeNode root, int targetSum) {
        if (root == null) {
            return isSum;
        }
        // 因为如果之前某一棵树已经被改成true了，要是在调用的话就不对了
        // 所以每次调这个方法就要先改成false，然后再看看这棵树有没有改成true然后把他返回
        isSum = false;
        // baseCase
        process(root, 0, targetSum);
        return isSum;
    }

    public static void process(TreeNode x, int preSum, int targetSum) {
        // 如果x为空的时候他的上游不一定是叶节点，也有可能是根节点
        if (x.left == null && x.right == null) {
            // 当左右两个节点都为空的时候,也就是x为叶节点的时候，之前从头一路累加下来的和为preSum
            boolean cur = preSum + x.val == targetSum;
            if (cur) {
                isSum = true;
            }
            return;
        }
        // x是非叶节点的时候  把自己的值加上
        preSum += x.val;
        if (x.left != null) {
            process(x.left, preSum, targetSum);
        } else {
            // 如果左树为空的时候不要传，因为我们的baseCase是叶节点来判断的时候，一定不要让x有空的时候
        }
        if (x.right != null) {
            process(x.right, preSum, targetSum);
        }
    }
}

```















### LeetCode113：路径总和II

给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。

```
https://leetcode.cn/problems/path-sum-ii/description/
```

```java
public class Code04_LeetCode113_PathSumII {

    public static class TreeNode {
        private TreeNode left;
        private TreeNode right;
        private int val;

        public TreeNode(int val) {
            this.val = val;
        }
    }

    public static List<List<Integer>> pathSum(TreeNode root, int sum) {
        List<List<Integer>> ans = new ArrayList<>();
        if (root == null) {
            return new ArrayList<>();
        }
        List<Integer> pathList = new ArrayList<>();
        process(root, pathList, 0, sum, ans);
        return ans;
    }

    public static void process(TreeNode x, List<Integer> path, int preSum, int sum, List<List<Integer>> ans) {
        if (x.left == null && x.right == null) {
            if (preSum + x.val == sum) {
                //达到了路径之和 添加到path中
                path.add(x.val);
                ans.add(copy(path));
                // 清理现场
                // 因为处理完之后叶节点是需要再返回到上层去的，因为还要继续往右边调用遍历节点
                // 如果不删掉的话，回调上游就不对了
                path.remove(path.size() - 1);
            }
            return;
        }

        // x非叶节点则开始处理数据
        path.add(x.val);
        // 按值传递的
        preSum += x.val;
        if (x.left != null) {
            process(x.left, path, preSum, sum, ans);
        }
        if (x.right != null) {
            process(x.right, path, preSum, sum, ans);
        }
        path.remove(path.size() - 1);
    }

    public static List<Integer> copy(List<Integer> path) {
        List<Integer> ans = new ArrayList<>();
        for (Integer integer : path) {
            ans.add(integer);
        }
        return ans;
    }

}
```

**如果轨迹信息要恢复到掉之前的样子的话就要恢复现场**



### 归并排序

MergeSort事件复杂度为O(n*logn)

![image-20240724194536949](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240724194536949.png) 



将不规则数据进行分割，然后将各个部分排序，最后合并

例1

![image-20240724194946432](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240724194946432.png) 

例2

![image-20240724195248453](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240724195248453.png) 



![image-20240724201220304](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240724201220304.png) 











#### 递归



左边部分就是L~mid，右边部分就是mid+1~R

![image-20240726195717920](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240726195717920.png) 





还需要些一个Merge函数来将两边的数据进行合并

![image-20240731130751750](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240731130751750.png)



第一步的实现，p1的数小于等于中心点M，并且p2的数没有超过R位置的数，也就是没有越界，其中一个越界都会跳出while

```java
        while (p1 <= M && p2 <= R) {
            // 指针拷贝的过程
            help[i ++] = arr[p1] <= arr[p2] ? arr[p1 ++] : arr[p2 ++];
        }
```

![image-20240731131700497](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240731131700497.png)

第二步判断那个不越界，然后把剩下的数拷贝到help数组中

![image-20240731132241334](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240731132241334.png)

最后一步help数组生成好之后将他拷贝会arr[]数组中，返回

代码实现

```java
package com.msb.arith6;

/**
 * 归并排序（递归实现）
 */
public class MergeSort_Recursion {

    /**
     * 递归方法实现
     *
     * @param arr
     */
    public void mergeSort(int[] arr) {
        if (arr.length < 2) {
            return;
        }
        process(arr, 0, arr.length - 1);
    }

    // 基于arr[L...R]范围上，请让这个范围的数有序
    public static void process(int[] arr, int L, int R) {
        // 只有一个数的时候就不需要做任何调整，因为已经有序了
        if (L == R) {
            return;
        }
        // 求中点
//        int mid = (L + R) / 2;
        // 下面的mid求值等同于上面的，
        // 因为L+R如果下表位置很大的话可能会越界的，
        // 所以换成地下的更加的安全
        int mid = L + ((R - L) >> 1);
        // 左边部分让他有序
        process(arr, L, mid);
        // 右边部分也让他有序
        process(arr, mid + 1, R);

    }

    // 左边部分就是L~M,右边部分其实是M + 1 ~ R
    public static void merge(int[] arr, int L, int M, int R) {
        // 定义一个数组 L ~ R 有几个数就准备多长的数组
        int help[] = new int[R - L + 1];
        int i = 0; // 是给help专门使用的,起始位置是i的0位置
        int p1 = L;
        int p2 = M + 1;
        // 边界条件,当两部分都没有越界的情况
        while (p1 <= M && p2 <= R) {
            // 指针拷贝的过程
            help[i ++] = arr[p1] <= arr[p2] ? arr[p1 ++] : arr[p2 ++];
        }

        // 上述while只要有一个越界就跳出循环,
        // 要么p1越界要吗p2越界,不可能出现共同越界的情况

        // 判断是哪个越界,然后把剩下的数都拷贝到help数组中
        // 下面的while虽然是顺序写的,但是只会进一个
        while (p1 <= M) {
            help[i ++] = arr[p1 ++];
        }
        while (p2 <= R) {
            help[i ++] = arr[p2 ++];
        }
        for (int i1 = 0; i1 < help.length; i1++) {
            arr[L + i1] = help[i1];
        }
    }

}

```



#### 非递归



**步长概念**

步长为1，一组一组往下Merge，谁大谁往后

![image-20240818102719053](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240818102719053.png)

在下一组

![image-20240818102822786](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240818102822786.png)

循此往复，知道最后一组不够步长了，也就是到了0没有组就不管了

![image-20240818102922366](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240818102922366.png)

再后来步长x2，左组是1,3  右组是0,2

![image-20240818103147056](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240818103147056.png)

Merge的结果

![image-20240818103203836](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240818103203836.png)

继续往下merger

![image-20240818103219572](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240818103219572.png)

结果

![image-20240818103243829](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240818103243829.png)

最后的0凑不成一个组，就不管了，然后步长继续x2

![image-20240818103319251](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240818103319251.png)

![image-20240818151730766](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240818151730766.png)

最后步长为8

![image-20240818151807264](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240818151807264.png)

右组和左组没有一样长也能够Merge，凑不够那就直接用凑不够的数来Merge

步长一旦超过总长度就停止

![image-20240818153306388](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240818153306388.png)

如果N是2^31-2的长度，有可能当步长到了2^30的时候，这个时候如果step再×一个2就溢出了因为他到了2^31 已经超过了最大长度2^31-1，应该如何防止这种溢出呢？

![image-20240818154654774](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240818154654774.png)



如果当step 大于等于总长度/2的时候直接退出，这样子就可以防止溢出

![image-20240818154806424](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240818154806424.png) 



**假设**系统整数最大值为15，当前步长Step已经来到了14，如果再*2的话肯定就溢出了（也就是来到step为8的时候），所以需要判断，如果小于14/2的话还可以继续再 * 2

![image-20240818161017999](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240818161017999.png)



描述mid

![image-20240818161521180](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240818161521180.png)





![image-20240818162044564](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240818162044564.png)



我们知道N-L是不可能越界的，如果N-L的长度>=step，也就是说如何N-L得到的数可以凑够step个，那么L+step-1就不越界，如果凑不够，那M就是N-1的位置

![image-20240818172456050](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240818172456050.png) 

##### MergeSort代码

第一组

![image-20240819222022211](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240819222022211.png)

下一组

![image-20240819222053841](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240819222053841.png)

最后一组不足step个，将步长*2

![image-20240819222150656](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240819222150656.png)



将代码抽象化出来

![image-20240819222255296](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240819222255296.png)

M位置

![image-20240819222440628](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240819222440628.png)



![image-20240819223112112](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240819223112112.png) 





右组的个数

![image-20240819223218598](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240819223218598.png)

够step个R来到的位置为 M + 1+ step - 1 => M +step

![image-20240819223329751](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240819223329751.png)



![image-20240819224021602](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240819224021602.png)



当step >= N/2的时候会使程序报错

![image-20240819225346123](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240819225346123.png)

但是把=去掉之后就没问题这是为什么？

![image-20240819225430171](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240819225430171.png)

**这是因为N/2是向下取整的**

加入一个数组长度为17，当他步长step到16时，17/2=8 因为是向下取整的，这个时候就不会把步长step为16的时候拿去处理，导致出错了。

![image-20240819225551072](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240819225551072.png)



![image-20240819225818507](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240819225818507.png)

code：

```java
package com.msb.arith6;

/**
 * 归并排序  非递归
 */
public class MergeSort_NonRecursion {

    // 递归方法实现
    public static void mergeSort1(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        process(arr, 0, arr.length - 1);
    }

    // arr[L...R]范围上，请让这个范围上的数，有序！
    public static void process(int[] arr, int L, int R) {
        if (L == R) {
            return;
        }
        // int mid = (L + R) / 2
        int mid = L + ((R - L) >> 1);
        process(arr, L, mid);
        process(arr, mid + 1, R);
        merge(arr, L, mid, R);
    }

    public static void mergeSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        // 步长（变化一定是2的某次方）
        int step = 1;
        int N = arr.length;
        // 当步长小于或者超过总长度的时候就可以停止
        while (step < N) {
            // 第一个左组
            int L = 0;
            // 每一个左组要小于N，防止越界
            while (L < N) {
                // 防止L+step-1是否越界
                int M = 0;
                // L...N-1 个数的计算为 N-1-L+1 => N-L
                // L~N的数有多少个，如果N~L的数能够可以凑够step个，
                // 那L+step-1就不越界，如果凑不够那Mid就是N-1的位置
                if (N - L >= step) {
                    M = L + step - 1;
                } else {
                    M = N - 1;
                }
                //N-1是最后一个下表，而后一个是我们凑够情况下的最后的位置，所以M位置肯定不比N-1的位置大
                //M = Math.min(N - 1, L + step - 1);// 需要检查L+step-1是否越界

                // 左组L...M
                //如果M位置来到的N-1也就是最后一个数的时候，说明没有右组，相当于可以结束了
                if (M == N - 1) {
                    break;
                }
                int R = 0;
                if (N - 1 - M >= step) {
                    //凑得够
//                    R = M + 1 + step - 1;
                    R = M + step;
                } else {
                    //凑不够
                    R = N - 1;
                }
                // 经历了上述步骤之后，现在的L...M就是左组，
                // M+1...R就是右组，可以merge了
                merge(arr, L, M, R);
                // 下一个左组的L为R +1 但是R+1有可能会越界
                if (R == N - 1) {
                    break;
                } else {
                    L = R + 1;
                }
            }
            //为了防止step*2超过整数最大值2^31-1溢出
            if (step > (N / 2)) {
                break;
            }
            step *= 2;
        }
    }

    public static void merge(int[] arr, int L, int M, int R) {
        int[] help = new int[R - L + 1];
        int i = 0;
        int p1 = L;
        int p2 = M + 1;
        while (p1 <= M && p2 <= R) {
            help[i++] = arr[p1] <= arr[p2] ? arr[p1++] : arr[p2++];
        }
        // 要么p1越界，要么p2越界
        // 不可能出现：共同越界
        while (p1 <= M) {
            help[i++] = arr[p1++];
        }
        while (p2 <= R) {
            help[i++] = arr[p2++];
        }
        for (i = 0; i < help.length; i++) {
            arr[L + i] = help[i];
        }
    }

    // for test
    public static void main(String[] args) {
        int testTime = 500000;
        int maxSize = 100;
        int maxValue = 100;
        System.out.println("测试开始");
        for (int i = 0; i < testTime; i++) {
            int[] arr1 = generateRandomArray(maxSize, maxValue);
            int[] arr2 = copyArray(arr1);
            mergeSort1(arr1);
            mergeSort(arr2);
            if (!isEqual(arr1, arr2)) {
                System.out.println("出错了！");
                printArray(arr1);
                printArray(arr2);
                break;
            }
        }
        System.out.println("测试结束");
    }

    // for test
    public static int[] generateRandomArray(int maxSize, int maxValue) {
        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
        }
        return arr;
    }

    // for test
    public static int[] copyArray(int[] arr) {
        if (arr == null) {
            return null;
        }
        int[] res = new int[arr.length];
        for (int i = 0; i < arr.length; i++) {
            res[i] = arr[i];
        }
        return res;
    }

    // for test
    public static boolean isEqual(int[] arr1, int[] arr2) {
        if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)) {
            return false;
        }
        if (arr1 == null && arr2 == null) {
            return true;
        }
        if (arr1.length != arr2.length) {
            return false;
        }
        for (int i = 0; i < arr1.length; i++) {
            if (arr1[i] != arr2[i]) {
                return false;
            }
        }
        return true;
    }

    // for test
    public static void printArray(int[] arr) {
        if (arr == null) {
            return;
        }
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }
}
```

时间复杂度

步长的变化是从2^0~2^N所以步长的变化时间复杂度为log2N回的变化，而没回的Merge是左组Merge右组所以时间复杂度为O(N)，因为每一次的log2N的步长变化都会伴随着Merge，所以总共的事件复杂度为O(N*log2N)

![image-20240819230024847](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240819230024847.png)



### 快排

#### 第一种：

给出一个数组，希望<=7的放左边，>7的放右边，内部可以无序，并且这个7要是小于等于7的最后一个数，要求时间复杂度O(N)，并且只使用有限几个变量。

![image-20240821233700622](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240821233700622.png)

例题：

![image-20240821233812487](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240821233812487.png)



我们在上图数组最左侧设置一个区域，这个区域叫小于等于区，拿最后一个数去划分，从左往右依次遍历

![image-20240822223439699](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240822223439699.png)

1、如果当前数<=p，<=区的下一个数和当前数做交换，<=区向右扩，当前数跳下一个。

2、 如果当前数>p的，当前数直接跳下一个。

最终结果

![image-20240822224245462](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240822224245462.png)

**Code**

```java
package com.msb.arith6;

public class PartitionAndQuickSort {


    /**
     * 划分
     *
     * @param arr
     */
    public static void splitNum(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }

        // 小于等于区的右边界
        int lessEqualsR = -1;
        // 当前数的位置
        int index = 0;
        // 最右侧的数
        int mostR = arr.length - 1;
        while (index < arr.length) {
            // 如果当前数<=p，<=区的下一个数和当前数做交换，<=区向右扩，当前数跳下一个。
            if (arr[index] <= arr[mostR]) {
//                swap(arr, lessEqualsR + 1, index);
//                lessEqualsR ++;
//                index ++;
                // 上面的三句并为了一句
                swap(arr, ++lessEqualsR, index++);
            } else {
                //如果当前数>p的，当前数直接跳下一个。
                index++;
            }
        }

    }

    public static void swap(int[] arr, int i, int j) {
        int temp = arr[j];
        arr[j] = arr[i];
        arr[i] = temp;
    }

    public static void main(String[] args) {
        int arr[] = {7, 3, 2, 1, 5, 7, 3, 8, 3, 4, 6, 4};
        splitNum(arr);
        printArray(arr);
    }

    public static void printArray(int[] arr) {
        if (arr == null) {
            return;
        }
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }
}

```



#### 第二种升级需求：

还是在一个数组中拿最后一个数进行划分，想将小于p的放左边，等于p的放中间，大于p的放右边，这三个区的内部都可以无序，但是要分成三层。

例题![image-20240822230559840](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240822230559840.png)

出了小于区以为还需要新增一个大于区

![image-20240822231040240](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240822231040240.png)

这样子就会产生3个条件：

1、当前数小于划分值p，当前数和小于区的下一个数交换，小于区域向右扩，当前数跳下一个。

2、当前数大于划分值p的时候，当前数和大于区前一个数做交换，大于区往左边扩，**当前数不动**（为什么不让当前数动呢，是因为交换过来的数是右边换过来的，还没进行比较处理，所以不能动）。

3、当前数等于划分值p的时候当前数直接跳下一个。

当当前数和大于区的边界撞上了之后最后一个数和大于区的第一个数进行交换就结束了。

![image-20240822232030464](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240822232030464.png)

再举一个例子。

![image-20240822232348905](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240822232348905.png)

![image-20240822232601097](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240822232601097.png)

最后一个数跟大于区的第一个数做交换

![image-20240822232624093](https://lyx-study-note-image.oss-cn-shenzhen.aliyuncs.com/img/image-20240822232624093.png)

**Code**

```java
package com.msb.arith6;

public class AdvancePartitionAndQuickSort {


    public static void splitNum2(int[] arr) {
        // 小于区的右边界
        int lessR = -1;
        int N = arr.length;
        // 大于区的左边界
        int moreL = N - 1;
        // 当前数
        int index = 0;
        // 划分值
        int p = N - 1;
        // index如果撞到了大于区的左边界就停止
        while (index < moreL) {
            //当前位置的数<p
            if (arr[index] < arr[p]) {
                swap(arr, ++lessR, index++);
            } else if (arr[index] > arr[p]) {
                //当前数<p,大于区的前一个数和当前数做交换,当前位置不动
//                swap(arr, moreL - 1, index);
//                moreL --;
                swap(arr, --moreL, index);
            } else {
                // 等于划分值
                index++;
            }
        }
        // 最后一个数要跟大于区域的第一个数做交换，
        swap(arr, moreL, p);
    }

    public static void main(String[] args) {
        int arr[] = {7, 3, 2, 1, 5, 7, 3, 8, 3, 4, 6, 7};
        splitNum2(arr);
        printArray(arr);
    }

    public static void printArray(int[] arr) {
        if (arr == null) {
            return;
        }
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }

    public static void swap(int[] arr, int i, int j) {
        int temp = arr[j];
        arr[j] = arr[i];
        arr[i] = temp;
    }

}
```











































































































































## 算法资料

算法课资料、规划、代码：
1，打开链接：https://cloud.fynote.com/share/s/7615

2，上面链接是所有课程介绍，打开“马士兵教育算法系列课程”，找到“通过世界上任何大厂算法面试扎实路线”，是学习路线。

3，课上所有代码：https://github.com/algorithmzuo

4，课上所有ppt文字合集、算法知识脉络及其脑图：https://github.com/algorithmzuo/class-notes

5，如果你不能翻墙，无法打开github，如下是马士兵代码平台算法课所有代码：https://git.mashibing.com/msb_14613/algorithm-class

6，每周算法直播课链接：https://www.mashibing.com/live/1240

根据1打开链接。可以熟悉整套课程，资料非常全：课程介绍、每节课梗概、讲述题目汇总、所有代码实现、知识脑图、学习路线，详细笔记全部都有，先熟悉一下。

接下来是规划路线。

==============

如果你的准备时间超过7个月，按照最稳妥的路线学习：

根据1和2打开，可以看到课程简介、学习顺序，因为你有时间掌握所有的课，所以我就推荐按顺序全看全练。

一周看课和练习一共投入12小时的话，整套课程6-7个月可拿下所有的850+题。即便进度慢，也可拿下600题，面大厂很稳。

==============

如果你准备时间不够7个月，可以按照高频内容先看的路线：

1. 新手班只看链表题目、二叉树题目题目

1）体系学习班，章节1~27全部，章节39～40只看有关“根据数据量猜解法”的部分。

2）大厂刷题班，章节28~38，打开资料里对应这门课的代码，找到class28～class38，每一个目录里都有“说明”，把说明文件看一下。详细列出了leetcode高频题目列表。

3）大厂刷题班，章节1~27

4）体系学习班，章节28~48，跳过四边形不等式、DC3算法的内容

5）大厂刷题班其他所有内容、每周直播课

==============

最后是学习注意点如下

不需要自己找题刷！我就推荐看课！只需要刷课上的题！因为课上覆盖了大厂需要的几乎所有题。题目总数850多个，其中包含600多的leetcode原题。几乎没有简单题，都是leetcode上最值得练的题，以及大厂真实面试题，已经为你选好了。当你想试试自己的学习状态，你可以每周三晚8点来参加算法直播课，都是大厂最新考的、不重复的算法题。

看课的时候，对每一个内容，看懂课上解析+自己独立写出来。每看懂一个题，就写总结笔记，可以只写你自己能看懂的话，但是要求笔记能帮你回忆起算法大概的流程，能在脑海中勾勒code怎么组织。这样的笔记对你复习很重要，复习就不需要看视频了，想不起来再翻视频。不要频繁复习！因为后面的题会把之前学过的内容反复练习，整套课自带复习效果。看懂+自己写出+笔记，持续推进即可。

===============

仔细阅读上面发的所有资料和提醒。

然后开始看课，练题。

过程中任何困惑求解答、debug不出错误、见到新的算法面试题目不会做。都可以官网发帖，或者通过班主任拉群联系到我。



